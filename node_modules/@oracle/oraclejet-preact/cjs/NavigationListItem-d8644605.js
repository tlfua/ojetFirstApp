/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var UNSAFE_NavigationList_themes_NavigationListStyles_css = require('./UNSAFE_NavigationList/themes/NavigationListStyles.css.js');
var utils_PRIVATE_collectionUtils = require('./utils/PRIVATE_collectionUtils.js');
var utils_UNSAFE_mergeProps = require('./utils/UNSAFE_mergeProps.js');
var hooks_PRIVATE_useCollectionFocusRing = require('./hooks/PRIVATE_useCollectionFocusRing.js');
var hooks_PRIVATE_useCurrentKey = require('./hooks/PRIVATE_useCurrentKey.js');
require('./UNSAFE_Text.js');
var hooks_UNSAFE_usePress = require('./hooks/UNSAFE_usePress.js');
require('./utils/UNSAFE_classNames.js');
var hooks_UNSAFE_useInteractionStyle = require('./hooks/UNSAFE_useInteractionStyle.js');
var hooks_UNSAFE_useComponentTheme = require('./hooks/UNSAFE_useComponentTheme.js');
var preact = require('preact');
var utils_UNSAFE_mergeInterpolations = require('./utils/UNSAFE_mergeInterpolations.js');
require('./utils/UNSAFE_interpolations/flexitem.js');
var UNSAFE_NavigationList_themes_redwood_NavigationListItemTheme = require('./UNSAFE_NavigationList/themes/redwood/NavigationListItemTheme.js');
var flexitem = require('./flexitem-939ec1ef.js');
var classNames = require('./classNames-d619a292.js');
var Text = require('./Text-4f1f698a.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Context used to pass navlist information without having to pass it to navlist children props.
 * We want to communicate information down to any interested navlist item children.
 */
const NavigationListContext = preact.createContext(null);

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Utility hook for consuming the NavigationListContext
 *
 * @returns The value of NavigationListContext provider
 */
function useNavigationListContext() {
    return hooks.useContext(NavigationListContext);
}

//Little hook to run some function before first render
const useWillMount = (callback) => {
    const willMount = hooks.useRef(true);
    if (willMount.current) {
        willMount.current = false;
        callback();
    }
};
const flexItemStyleInterpolations = utils_UNSAFE_mergeInterpolations.mergeInterpolations([
    ...Object.values(flexitem.flexitemInterpolations)
]);
const { class: labelContainerFlexItemClasses, ...labelContainerFlexItemStyle } = flexItemStyleInterpolations({
    alignSelf: 'center'
});
// default style class for items in NavigationList
const ITEM_STYLE_CLASS = 'oj-c-navigationlist-item';
const ITEM_SELECTOR = '.' + ITEM_STYLE_CLASS;
function useNavigationListItem({ itemRef, itemKey }) {
    const { onSelectionChange, selection, currentKey, showFocusRing, containsActiveElement, firstItemRenderedKey, onCurrentKeyChange } = useNavigationListContext();
    //Selection and focus state
    const isCurrent = currentKey === itemKey;
    useWillMount(() => {
        if (currentKey === undefined &&
            firstItemRenderedKey &&
            firstItemRenderedKey.current === undefined) {
            firstItemRenderedKey.current = itemKey;
        }
    });
    const isSelected = selection === itemKey;
    //Styling
    const { interactionProps, applyPseudoHoverStyle, applyHoverStyle, applyActiveStyle } = hooks_UNSAFE_useInteractionStyle.useInteractionStyle();
    const { classes: listItemClasses, styles: { labelContainerClasses } } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_NavigationList_themes_redwood_NavigationListItemTheme.NavigationListItemRedwoodTheme, {
        focusRing: showFocusRing ? 'isFocusRing' : 'notFocusRing',
        current: isCurrent ? 'isCurrent' : 'notCurrtent',
        selected: isSelected ? 'isSelected' : 'notSelected',
        hybridHover: applyHoverStyle ? 'isHybridHover' : 'notHybridHover',
        pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',
        active: applyActiveStyle ? 'isActive' : 'notActive'
    });
    hooks.useLayoutEffect(() => {
        //We just focus the item if the container is the active element
        if (containsActiveElement?.() && isCurrent) {
            itemRef?.current?.focus();
        }
    }, [isCurrent, containsActiveElement]);
    //Item handlers
    const handlePress = () => {
        onSelectionChange?.({ value: itemKey });
    };
    //Legacy navlist makes selection on keyDown, but since preact tabbar made selection after keyUp, will do the same
    //for preact navlist
    const { pressProps } = hooks_UNSAFE_usePress.usePress(handlePress);
    // We have to update current key if there no initial selection
    const onFocus = () => {
        if (currentKey === undefined) {
            onCurrentKeyChange({ value: itemKey });
        }
    };
    const onFocusProps = { onFocus };
    return {
        itemHandlers: utils_UNSAFE_mergeProps.mergeProps(interactionProps, pressProps, onFocusProps),
        itemClasses: classNames.classNames([listItemClasses, ITEM_STYLE_CLASS]),
        isItemFocusable: isCurrent || (firstItemRenderedKey?.current === itemKey && currentKey === undefined)
            ? true
            : false,
        isSelected,
        labelContainerClasses: classNames.classNames([labelContainerClasses, labelContainerFlexItemClasses]),
        labelContainerStyle: labelContainerFlexItemStyle
    };
}

/*TODO: JET-58534. Create a hook to share some logic between navlist and tabbar. Hook will be used inside this one. */
function useNavigationList({ containerRef, selection }) {
    //Ref used to track if the first item was already rendered
    const firstItemRenderedKey = hooks.useRef();
    const [currentKey, setCurrentKey] = hooks.useState(selection);
    const onCurrentKeyChange = hooks.useCallback(({ value }) => {
        setCurrentKey(value);
    }, []);
    const { currentKeyProps } = hooks_PRIVATE_useCurrentKey.useCurrentKey((element) => utils_PRIVATE_collectionUtils.keyExtractor(element, ITEM_SELECTOR), false, utils_PRIVATE_collectionUtils.getPrevNextKey(containerRef.current, currentKey, true, ITEM_SELECTOR), utils_PRIVATE_collectionUtils.getPrevNextKey(containerRef.current, currentKey, false, ITEM_SELECTOR), undefined, undefined, currentKey, onCurrentKeyChange);
    const [showFocusRing, focusRingProps] = hooks_PRIVATE_useCollectionFocusRing.useCollectionFocusRing((elem) => {
        return !!containerRef.current?.contains(elem);
    }, ['ArrowUp', 'ArrowDown']);
    const containsActiveElement = hooks.useCallback(() => {
        return !!containerRef?.current?.contains(document.activeElement);
    }, []);
    return {
        firstItemRenderedKey,
        showFocusRing,
        currentKey,
        onCurrentKeyChange,
        containsActiveElement,
        containerHandlers: utils_UNSAFE_mergeProps.mergeProps(focusRingProps, currentKeyProps)
    };
}

function NavigationList({ children, selection, onSelectionChange, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelLedBy }) {
    const containerRef = hooks.useRef(null);
    const { firstItemRenderedKey, showFocusRing, currentKey, onCurrentKeyChange, containsActiveElement, containerHandlers } = useNavigationList({
        containerRef: containerRef,
        selection
    });
    return (jsxRuntime.jsx("ul", { "aria-label": ariaLabel, "aria-labelledby": ariaLabelLedBy, role: "listbox", ref: containerRef, tabIndex: children ? -1 : 0, ...containerHandlers, class: UNSAFE_NavigationList_themes_NavigationListStyles_css.navigationListStyles.uListStyle, children: jsxRuntime.jsx(NavigationListContext.Provider, { value: {
                selection,
                onSelectionChange,
                onCurrentKeyChange,
                currentKey,
                showFocusRing,
                containsActiveElement,
                firstItemRenderedKey
            }, children: children }) }));
}

/*TODO: JET-58535. Add ripple effect when touching navigationListItem. */
function NavigationListItem({ itemKey, label }) {
    const itemRef = hooks.useRef(null);
    //Logic of the component handled here
    const { isItemFocusable, itemHandlers, itemClasses, isSelected, labelContainerClasses, labelContainerStyle } = useNavigationListItem({
        itemRef: itemRef,
        itemKey
    });
    return (jsxRuntime.jsx("li", { role: "option", ...itemHandlers, "data-oj-key": itemKey, class: itemClasses, tabIndex: isItemFocusable ? 0 : -1, "aria-selected": isSelected, ref: itemRef, children: label && (jsxRuntime.jsx("span", { class: labelContainerClasses, style: labelContainerStyle, children: jsxRuntime.jsx(Text.Text, { size: "inherit", weight: "inherit", variant: "inherit", children: label }) })) }));
}

exports.NavigationList = NavigationList;
exports.NavigationListItem = NavigationListItem;
//# sourceMappingURL=NavigationListItem-d8644605.js.map
