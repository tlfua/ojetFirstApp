/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var compat = require('preact/compat');
require('./utils/UNSAFE_classNames.js');

var utils_PRIVATE_tabbableUtils = require('./utils/PRIVATE_tabbableUtils.js');
var classNames = require('./classNames-d619a292.js');

const styles = {
  guard: "_72dli0"
};
/**
 * Styled FocusTrap sub-component to render non-visible focus guards
 */
const FocusGuard = compat.forwardRef(({
  onFocus
}, guardRef) => {
  return jsxRuntime.jsx("div", {
    class: styles.guard,
    onFocus: onFocus,
    ref: guardRef,
    tabIndex: 0
  });
});

/**
 * Trap focus within a DOM node.  When a user hits Tab or Shift+Tab, focus remains in the focus trap.
 */
const FocusTrap = ({
  autoFocusRef,
  children,
  isDisabled = false,
  restoreFocusRef
}) => {
  const trapRef = compat.useRef(null);
  const startGuardRef = compat.useRef(null);
  const endGuardRef = compat.useRef(null);
  const lastActiveElementRef = compat.useRef(null);
  // classes to be set on the children wrapper
  const classes = classNames.classNames([childrenStyles]);
  /**
   * contain focus if trap is enabled, and target is not already contained
   *
   * calling cases for side-effect of setting focus
   *   - on initial mount of (enabled) trap, where target is not inside trap
   *   - on enabling of a disabled trap, where target is not inside trap
   *   - target of click event is outside of trap.
   */
  const conditionallyContainFocus = compat.useCallback(target => {
    const trap = trapRef.current;
    //  short-circuit, if trap or target not valid
    if (isDisabled || !trap || !target) return;
    // just update ref if, target already has focus
    if (target && hasFocus([trap, startGuardRef.current, endGuardRef.current], target)) {
      lastActiveElementRef.current = target;
      return;
    }
    // set focus to last active tab-stop if lastElement is defined and inside trap
    if (lastActiveElementRef.current) {
      utils_PRIVATE_tabbableUtils.focusOn(lastActiveElementRef.current);
    } else {
      // otherwise just contain focus within trap as target is outside enabled trap and we have no last-known tab-stop
      utils_PRIVATE_tabbableUtils.focusWithin(trap);
    }
  }, [isDisabled]);
  // loop focus
  const handleStartGuardOnFocus = event => {
    if (isDisabled || !trapRef.current) return;
    utils_PRIVATE_tabbableUtils.focusOnEnd(trapRef.current);
    // prevent scroll jump and bubbling this event up as a focus event
    event.stopPropagation();
    event.preventDefault();
  };
  const handleEndGuardOnFocus = event => {
    if (isDisabled || !trapRef.current) return;
    utils_PRIVATE_tabbableUtils.focusOnStart(trapRef.current);
    // prevent scroll jump and bubbling guard event up as a focus event
    event.stopPropagation();
    event.preventDefault();
  };
  const handleTrapOnFocus = event => {
    lastActiveElementRef.current = event.target;
  };
  // handle initial render or re-render as enabled
  compat.useEffect(() => {
    const trap = trapRef.current;
    if (!trap || isDisabled) return;
    const originalActiveElement = utils_PRIVATE_tabbableUtils.getActiveElement(trap);
    // init focus
    if (autoFocusRef && autoFocusRef.current) {
      utils_PRIVATE_tabbableUtils.focusOn(autoFocusRef.current);
    } else {
      conditionallyContainFocus(originalActiveElement);
    }
    const restoreFocusRefForCleanup = restoreFocusRef;
    return () => {
      if (restoreFocusRefForCleanup === false) return;
      restoreFocusAfterUnmount(restoreFocusRefForCleanup?.current || originalActiveElement);
    };
  }, [autoFocusRef, conditionallyContainFocus, isDisabled, restoreFocusRef]);
  return jsxRuntime.jsxs(preact.Fragment, {
    children: [!isDisabled && jsxRuntime.jsx(FocusGuard, {
      onFocus: handleStartGuardOnFocus,
      ref: startGuardRef
    }), jsxRuntime.jsx("div", {
      onFocus: handleTrapOnFocus,
      ref: trapRef,
      class: classes,
      children: children
    }), !isDisabled && jsxRuntime.jsx(FocusGuard, {
      onFocus: handleEndGuardOnFocus,
      ref: endGuardRef
    })]
  });
};
// setTimeout ensures that unmount lifecycle has completed
const restoreFocusAfterUnmount = element => {
  if (element && utils_PRIVATE_tabbableUtils.isTabbableElement(element)) {
    setTimeout(() => {
      utils_PRIVATE_tabbableUtils.focusOn(element);
    }, 0);
  }
};
// is focus already contained?
const hasFocus = (elements, target) => {
  if (elements.length === 0) return false;
  const activeElement = target ?? utils_PRIVATE_tabbableUtils.getActiveElement(elements[0]);
  return elements.some(el => el === activeElement || el?.contains(activeElement));
};
// remove margins from children
const childrenStyles = "_14asjhp";

exports.FocusTrap = FocusTrap;
//# sourceMappingURL=FocusTrap-2209a89f.js.map
