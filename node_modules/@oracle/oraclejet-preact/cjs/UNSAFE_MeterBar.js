/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var utils_UNSAFE_size = require('./utils/UNSAFE_size.js');
require('./utils/UNSAFE_classNames.js');
var utils_UNSAFE_mergeProps = require('./utils/UNSAFE_mergeProps.js');
var hooks = require('preact/hooks');
var hooks_UNSAFE_useUser = require('./hooks/UNSAFE_useUser.js');
var hooks_PRIVATE_useDvtMeterEvents = require('./hooks/PRIVATE_useDvtMeterEvents.js');
var utils_PRIVATE_meterUtils = require('./utils/PRIVATE_meterUtils.js');
var PRIVATE_Meter = require('./PRIVATE_Meter.js');
var utils_UNSAFE_dvtCommonUtils = require('./utils/UNSAFE_dvtCommonUtils.js');
var UNSAFE_MeterBar_themes_MeterBarStyles_css = require('./UNSAFE_MeterBar/themes/MeterBarStyles.css.js');
var classNames = require('./classNames-d619a292.js');
var hooks_UNSAFE_useTabbableMode = require('./hooks/UNSAFE_useTabbableMode.js');
var hooks_UNSAFE_useComponentTheme = require('./hooks/UNSAFE_useComponentTheme.js');
var UNSAFE_MeterBar_themes_redwood_MeterBarTheme = require('./UNSAFE_MeterBar/themes/redwood/MeterBarTheme.js');
require('./UNSAFE_Theme.js');
require('./utils-b9f57550.js');
require('./Common/themes/themeContract.css.js');
require('./index-c3ee789d.js');
require('preact');
require('./Common.js');
require('./Common/themes.js');
require('./Common/themes/redwood/theme.js');
require('preact/compat');
require('./hooks/UNSAFE_useTooltip.js');
require('./hooks/UNSAFE_useId.js');
require('./UNSAFE_Floating.js');
require('./Floating-3415cf36.js');
require('./index-0a166c9e.js');
require('./utils/PRIVATE_floatingUtils.js');
require('./utils/PRIVATE_refUtils.js');
require('./hooks/UNSAFE_useOutsideClick.js');
require('./utils/UNSAFE_arrayUtils.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-recipes-createRuntimeFn.esm-8a4b93e4.js');
require('./vanilla-extract-dynamic.esm-4bc33829.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./utils/UNSAFE_logger.js');
require('./_curry1-6e9511bf.js');
require('./_curry2-53a902bf.js');
require('./UNSAFE_Layer.js');
require('./useThemeInterpolations-ee4e7934.js');
require('./hooks/UNSAFE_useColorScheme.js');
require('./hooks/UNSAFE_useScale.js');
require('./utils/UNSAFE_interpolations/theme.js');
require('./utils/UNSAFE_mergeInterpolations.js');
require('./_curry3-ad2313fd.js');
require('./_has-aa203696.js');
require('./hooks/UNSAFE_useHover.js');
require('./hooks/UNSAFE_useToggle.js');
require('./hooks/UNSAFE_useFocus.js');
require('./hooks/UNSAFE_useTouch.js');
require('./hooks/UNSAFE_useAnimation.js');
require('./useAnimation-802f3cdb.js');
require('./hooks/UNSAFE_useThemeInterpolations.js');
require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js');
require('./hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js');

require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js');

require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');


require('./UNSAFE_MeterBar/themes/redwood/MeterBarBaseTheme.css.js');

require('./UNSAFE_MeterBar/themes/redwood/MeterBarVariants.css.js');


/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the metric value of the clicked point.
 * @param event The PointerEvent
 * @param dimensionsRef Ref to stored dimensions of the meter bar.
 * @param min The minimum value of the meter bar.
 * @param max The maximum value of the meter bar.
 * @param step The step value of the meter bar.
 * @param orientation The orientation of the meter bar.
 * @param isRtl Whether the reading mode is 'rtl'
 * @returns The metric value of the clicked point.
 */
function getValue(event, dimensionsRef, min, max, step, orientation, isRtl) {
    const dims = dimensionsRef.current;
    if (!dims || dims.width === 0) {
        return undefined;
    }
    let val;
    if (orientation === 'horizontal') {
        const width = event.offsetX;
        val = min + ((max - min) * (isRtl ? dims.width - width : width)) / dims.width;
    }
    else {
        const height = dims.height - event.offsetY;
        val = min + ((max - min) * height) / dims.height;
    }
    val = Math.round(val / step) * step;
    return Math.max(min, Math.min(max, val));
}
/**
 * Returns the true dimension of the meter bar after first render. All dimensions are 0 for initial render.
 * @param element The meter bar track HTML element
 * @returns The dimension of the meter bar.
 */
function getDimensions(element) {
    if (!element) {
        return {
            width: 0,
            height: 0
        };
    }
    const trackDims = element.getBoundingClientRect();
    return {
        width: trackDims.width,
        height: trackDims.height
    };
}
/**
 * Returns object with 'start' and 'end' keys. Value for each key will be true if at least one ref line with correposnding position is present in meter bar.
 * @param lines The array of reference lines.
 * @returns Returns object with start and end keys.
 */
function getRefLinesInfo(lines) {
    let refLineInfo = { start: false, end: false };
    if (lines) {
        refLineInfo = lines.reduce((acc, cur) => {
            acc.start = acc.start || cur.position === 'start';
            acc.end = acc.end || cur.position === 'end' || cur.position == null;
            return acc;
        }, refLineInfo);
    }
    return refLineInfo;
}

function ReferenceLineBar({ orientation, percentage, color, position }) {
    const isHoriz = orientation === 'horizontal';
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const isRtl = direction === 'rtl';
    const isStartPos = position === 'start';
    return (jsxRuntime.jsx("div", { class: classNames.classNames([
            UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.referenceLinesBaseStyle,
            isHoriz ? UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.referenceLinesHorizontalStyle : UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.referenceLinesVerticalStyle,
            isStartPos
                ? isHoriz
                    ? UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.referenceLinesHoriontalStartStyle
                    : isRtl
                        ? UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.referenceLinesVerticalStartRtlStyle
                        : UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.referenceLinesVerticalStartLtrStyle
                : ''
        ]), style: {
            left: isHoriz && !isRtl ? percentage : undefined,
            right: isHoriz && isRtl ? percentage : undefined,
            bottom: isHoriz ? undefined : percentage,
            backgroundColor: utils_UNSAFE_dvtCommonUtils.getDvtThresholdColor(color)
        } }));
}

function ThresholdBar({ color, length, orientation, ...otherProps }) {
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const isHoriz = orientation === 'horizontal';
    const isRtl = direction === 'rtl';
    return (jsxRuntime.jsx("div", { class: classNames.classNames([
            UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.thresholdBarBaseStyle,
            isHoriz
                ? isRtl
                    ? UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.thresholdBarHorizontalBarTrackSectionRtlStyle
                    : UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.thresholdBarHorizontalBarTrackSectionLtrStyle
                : UNSAFE_MeterBar_themes_MeterBarStyles_css.styles.thresholdBarVerticalBarTrackSectionStyle,
            otherProps.class
        ]), style: {
            width: isHoriz ? length : '100%',
            height: isHoriz ? '100%' : length,
            backgroundColor: utils_UNSAFE_dvtCommonUtils.getDvtThresholdColor(color)
        } }));
}

/**
 * A Meter bar displays information graphically in a rectangular bar, highlighting a specific metric value's progress in relation to its min, max, or thresholds.
 */
function MeterBar({ max = 100, min = 0, value = 0, step = 1, length = '100%', size, orientation = 'horizontal', isTrackRendered = true, thresholdDisplay = 'all', indicatorSize = 1, ...props }) {
    utils_PRIVATE_meterUtils.validateRange(min, max, value, step);
    const currentInputRef = hooks.useRef();
    const isHoriz = orientation === 'horizontal';
    const barTrackRef = hooks.useRef(null);
    const dimensionsRef = hooks.useRef(getDimensions(null));
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const isRtl = direction === 'rtl';
    hooks.useEffect(() => {
        if (props.onCommit || props.onInput) {
            dimensionsRef.current = getDimensions(barTrackRef.current);
        }
    }, [size, length, orientation, props.onCommit, props.onInput]);
    const getValueFromEvent = (event) => {
        // only evaluate value from bar track
        if (event.target == barTrackRef.current) {
            return getValue(event, dimensionsRef, min, max, step, orientation, isRtl);
        }
        return;
    };
    const pointerEventsProps = hooks_PRIVATE_useDvtMeterEvents.usePointerEvents(value, getValueFromEvent, barTrackRef, currentInputRef, props.onCommit, props.onInput);
    const keyboardEventsProps = hooks_PRIVATE_useDvtMeterEvents.useKeyboardEvents(value, min, max, step, currentInputRef, props.onCommit, props.onInput);
    const { datatipContent, datatipProps } = hooks_PRIVATE_useDvtMeterEvents.useMeterDatatip(value, props.datatip, props['aria-describedby']);
    const ariaLabelProps = utils_PRIVATE_meterUtils.getMeterAriaProps(value, min, max, props['aria-label'], props['aria-labelledby'], props.thresholds);
    const mergedProps = utils_UNSAFE_mergeProps.mergeProps(pointerEventsProps, keyboardEventsProps, datatipProps, ariaLabelProps);
    const validIndicatorSize = Math.max(0, Math.min(1, indicatorSize));
    const valueBarLength = `${((value - min) * 100) / (max - min)}%`;
    const valueBarSize = `${validIndicatorSize * 100}%`;
    const { trackColor, indicatorColor } = utils_PRIVATE_meterUtils.getTrackAndIndicatorColor(value, thresholdDisplay, props.trackColor, props.indicatorColor, props.thresholds);
    const sizeStyle = getRefLinesInfo(props.referenceLines);
    const isInteractive = props.onCommit || props.onInput;
    const { isTabbable } = hooks_UNSAFE_useTabbableMode.useTabbableMode();
    const { classes, styles: { interactiveStyle, barValueBaseStyle, barValueVerticalStyle, barValueHorizontalStyle, barTrackBaseStyle, barTrackHorizontalSizeStyle, barTrackVerticalSizeStyle, barTrackMarginTopStyle, barTrackMarginStartStyle, barTrackMarginBottomStyle, barTrackMarginEndStyle, trackSectionHorizontalFirstStyle, trackSectionHorizontalLastStyle, trackSectionVerticalFirstStyle, trackSectionVerticalLastStyle, trackSectionRoundedCornersStyle } } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_MeterBar_themes_redwood_MeterBarTheme.MeterBarRedwoodTheme, {
        size,
        orientation
    });
    return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx("div", { tabIndex: !isTabbable ? -1 : 0, ...mergedProps, style: {
                    width: isHoriz ? utils_UNSAFE_size.sizeToCSS(length) : undefined,
                    height: isHoriz ? undefined : utils_UNSAFE_size.sizeToCSS(length)
                }, class: classNames.classNames([classes]), children: jsxRuntime.jsxs(PRIVATE_Meter.BarTrack, { ref: barTrackRef, orientation: orientation, color: !isTrackRendered || (thresholdDisplay === 'all' && props.thresholds)
                        ? 'transparent'
                        : trackColor, class: classNames.classNames([
                        barTrackBaseStyle,
                        isInteractive ? interactiveStyle : '',
                        isHoriz ? barTrackHorizontalSizeStyle : barTrackVerticalSizeStyle,
                        ...getMarginClass(sizeStyle, isHoriz, barTrackMarginTopStyle, barTrackMarginStartStyle, barTrackMarginBottomStyle, barTrackMarginEndStyle)
                    ]), children: [thresholdDisplay === 'all' &&
                            props.thresholds
                                ?.filter((threshold) => threshold.max > min && threshold.max <= max)
                                .sort((a, b) => a.max - b.max)
                                .map((threshold, index, thresholds) => {
                                const diff = index === 0 ? threshold.max - min : threshold.max - thresholds[index - 1].max;
                                const trackSectionLastStyle = isHoriz
                                    ? trackSectionHorizontalLastStyle
                                    : trackSectionVerticalLastStyle;
                                let trackSectionStyleClass = index === 0
                                    ? isHoriz
                                        ? trackSectionHorizontalFirstStyle
                                        : trackSectionVerticalFirstStyle
                                    : '';
                                if (threshold.max === max)
                                    trackSectionStyleClass =
                                        index === 0
                                            ? trackSectionRoundedCornersStyle // Single threshold from min to max
                                            : trackSectionLastStyle;
                                return (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [jsxRuntime.jsx(ThresholdBar, { class: trackSectionStyleClass, orientation: orientation, length: `${(diff * 100) / (max - min)}%`, color: threshold.color }), isTrackRendered && index === thresholds.length - 1 && threshold.max < max ? (jsxRuntime.jsx(ThresholdBar, { class: trackSectionLastStyle, color: trackColor, orientation: orientation, length: `${((max - thresholds[index].max) * 100) / (max - min)}%` })) : ('')] }));
                            }), jsxRuntime.jsx(PRIVATE_Meter.BarValue, { length: valueBarLength, size: valueBarSize, orientation: orientation, class: classNames.classNames([
                                barValueBaseStyle,
                                isHoriz ? barValueHorizontalStyle : barValueVerticalStyle
                            ]), color: indicatorColor }), props.referenceLines?.map((item) => (jsxRuntime.jsx(ReferenceLineBar, { color: item.color, orientation: orientation, percentage: `${((item.value - min) * 100) / (max - min)}%`, position: item.position })))] }) }), datatipContent] }));
}
const getMarginClass = function (info, isHoriz, barTrackMarginTopStyle, barTrackMarginStartStyle, barTrackMarginBottomStyle, barTrackMarginEndStyle) {
    const className = [];
    if (info.start) {
        className.push(isHoriz ? barTrackMarginTopStyle : barTrackMarginStartStyle);
    }
    if (info.end) {
        className.push(isHoriz ? barTrackMarginBottomStyle : barTrackMarginEndStyle);
    }
    return className;
};

exports.MeterBar = MeterBar;
//# sourceMappingURL=UNSAFE_MeterBar.js.map
