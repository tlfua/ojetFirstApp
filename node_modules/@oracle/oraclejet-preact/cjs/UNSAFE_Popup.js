/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
require('./UNSAFE_Floating.js');
var utils_PRIVATE_tabbableUtils = require('./utils/PRIVATE_tabbableUtils.js');
var utils_PRIVATE_refUtils = require('./utils/PRIVATE_refUtils.js');
require('./UNSAFE_FocusTrap.js');
var UNSAFE_Layer = require('./UNSAFE_Layer.js');
var compat = require('preact/compat');
var hooks_PRIVATE_useAnimationStatus = require('./hooks/PRIVATE_useAnimationStatus.js');
var utils_PRIVATE_floatingUtils = require('./utils/PRIVATE_floatingUtils.js');
var hooks_UNSAFE_useUser = require('./hooks/UNSAFE_useUser.js');
var hooks_UNSAFE_useComponentTheme = require('./hooks/UNSAFE_useComponentTheme.js');
var UNSAFE_Popup_themes_PopupContract_css = require('./UNSAFE_Popup/themes/PopupContract.css.js');
require('./utils/UNSAFE_stringUtils.js');
require('./utils/UNSAFE_classNames.js');
var UNSAFE_Popup_themes_redwood_PopupTheme = require('./UNSAFE_Popup/themes/redwood/PopupTheme.js');
var stringUtils = require('./stringUtils-27007290.js');
var Floating = require('./Floating-3415cf36.js');
var classNames = require('./classNames-d619a292.js');
var FocusTrap = require('./FocusTrap-2209a89f.js');
require('./index-0a166c9e.js');
require('./index-c3ee789d.js');
require('preact');
require('./Common.js');
require('./Common/themes.js');
require('./Common/themes/redwood/theme.js');
require('./Common/themes/themeContract.css.js');
require('./hooks/UNSAFE_useOutsideClick.js');
require('./utils/UNSAFE_arrayUtils.js');
require('./utils/UNSAFE_logger.js');
require('./_curry1-6e9511bf.js');
require('./_curry2-53a902bf.js');
require('./utils-b9f57550.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-recipes-createRuntimeFn.esm-8a4b93e4.js');
require('./vanilla-extract-dynamic.esm-4bc33829.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./_arity-353457ba.js');
require('./_curry3-ad2313fd.js');
require('./useThemeInterpolations-ee4e7934.js');
require('./hooks/UNSAFE_useColorScheme.js');
require('./hooks/UNSAFE_useScale.js');
require('./utils/UNSAFE_interpolations/theme.js');
require('./UNSAFE_Theme.js');
require('./utils/UNSAFE_mergeInterpolations.js');
require('./_has-aa203696.js');
require('./hooks/UNSAFE_useAnimation.js');
require('./useAnimation-802f3cdb.js');
require('./UNSAFE_Popup/themes/redwood/PopupBaseTheme.css.js');

require('./UNSAFE_Popup/themes/redwood/PopupVariants.css.js');



const animationStates = {
    opening: (node) => {
        const realPlacement = logicalSide(node.placement, node.direction);
        return {
            //zoomIn
            from: {
                scaleX: 0,
                scaleY: 0,
                opacity: 0,
                transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]
            },
            to: {
                scaleX: 1,
                scaleY: 1,
                opacity: 1,
                transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]
            },
            options: {
                duration: 200
            }
        };
    },
    closing: (node) => {
        const realPlacement = logicalSide(node.placement, node.direction);
        return {
            //zoomOut
            from: {
                scaleX: 1,
                scaleY: 1,
                opacity: 1,
                transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]
            },
            to: {
                scaleX: 0,
                scaleY: 0,
                opacity: 0,
                transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]
            },
            options: {
                duration: 200
            }
        };
    }
};
const _ANIMATION_TRANSFORM_ORIGIN_RULES = {
    top: 'center bottom',
    'top-right': 'right bottom',
    'top-left': 'left bottom',
    'top-right-corner': 'left bottom',
    'top-left-corner': 'right bottom',
    right: 'left center',
    'right-top': 'left top',
    'right-bottom': 'left bottom',
    'right-top-corner': 'left bottom',
    'right-bottom-corner': 'left top',
    bottom: 'center top',
    'bottom-right': 'right top',
    'bottom-left': 'left top',
    'bottom-right-corner': 'left top',
    'bottom-left-corner': 'right top',
    left: 'right center',
    'left-top': 'right top',
    'left-bottom': 'right bottom',
    'left-top-corner': 'right bottom',
    'left-bottom-corner': 'right top'
};
const logicalSide = (placement, direction) => {
    if (placement == null || direction == null)
        return 'bottom';
    const side = placement.split('-')[0];
    const alignment = placement.split('-')[1];
    const corner = placement.split('-')[2];
    const physicalSide = utils_PRIVATE_floatingUtils.normalizePosition(side, direction);
    const placements = [
        'top',
        'top-right',
        'top-left',
        'top-right-corner',
        'top-left-corner',
        'right',
        'right-top',
        'right-bottom',
        'right-top-corner',
        'right-bottom-corner',
        'bottom',
        'bottom-right',
        'bottom-left',
        'bottom-right-corner',
        'bottom-left-corner',
        'left',
        'left-top',
        'left-bottom',
        'left-top-corner',
        'left-bottom-corner'
    ];
    const newPlacement = placements.filter((placement) => (alignment &&
        corner &&
        placement === `${physicalSide}-${utils_PRIVATE_floatingUtils.normalizePosition(alignment, direction)}-${corner}`) ||
        (alignment &&
            !corner &&
            placement === `${physicalSide}-${utils_PRIVATE_floatingUtils.normalizePosition(alignment, direction)}`) ||
        (!alignment && placement === `${physicalSide}`))[0];
    if (!newPlacement) {
        return 'bottom';
    }
    return newPlacement;
};
function usePopupAnimation(props) {
    const { isOpen, isAnimatedOnMount, onTransitionEnd, placement } = props;
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const { setAnimationElementRef, animationElementRef, status } = hooks_PRIVATE_useAnimationStatus.useAnimationStatus({
        isOpen: isOpen,
        isAnimatedOnMount: isAnimatedOnMount,
        animationStates,
        onTransitionEnd
    });
    const popupElementRef = animationElementRef;
    //This is needed for the case if popup flips and changes the placement.
    hooks.useEffect(() => {
        if (popupElementRef != null && popupElementRef.current != null && status != 'unmounted') {
            popupElementRef.current.placement = placement;
            popupElementRef.current.direction = direction;
        }
    }, [popupElementRef, placement, direction, status]);
    return { setAnimationElementRef, status };
}

/**
 * A popup temporarily 'pops up' content in the foreground.
 */
const Popup = compat.forwardRef(({ anchorRef, children, isOpen = false, offset = { mainAxis: 0, crossAxis: 0 }, flipOptions = { mainAxis: true, crossAxis: true }, shiftOptions = { mainAxis: false, crossAxis: false }, onClose, initialFocus = 'auto', onClickOutside, placement = 'top', tail = 'none', onTransitionEnd, role = 'tooltip' }, ref) => {
    const [trapDisabled, setTrapDisabled] = hooks.useState(true);
    const launcherRef = hooks.useRef(null);
    const [popupBgColor, setPopupBgColor] = hooks.useState();
    const contentWrapperRef = hooks.useRef(null);
    //The animationPlacement is used for the case of flip.
    const [animationPlacement, setAnimationPlacement] = hooks.useState(placement);
    function launcherKeyDownCallback(event) {
        if (launcherRef.current === utils_PRIVATE_tabbableUtils.getActiveElement() && event.code === 'F6') {
            // Prevent default F6 handlers.
            // F6 is a standard Chrome address bar shortcut on Windows.
            event.preventDefault();
            event.stopPropagation();
            utils_PRIVATE_tabbableUtils.focusWithin(contentWrapperRef.current);
        }
    }
    const _onTransitionEnd = (isOpen) => {
        if (isOpen) {
            setInitialFocus();
            onTransitionEnd?.(true);
        }
        else {
            onTransitionEnd?.(false);
        }
    };
    // Animation
    const { setAnimationElementRef, status } = usePopupAnimation({
        isOpen,
        isAnimatedOnMount: true,
        onTransitionEnd: _onTransitionEnd,
        placement: animationPlacement
    });
    const stableRef = hooks.useMemo(() => utils_PRIVATE_refUtils.mergeRefs(setAnimationElementRef, ref), [setAnimationElementRef, ref]);
    const returnFocus = () => {
        // Try to return focus to 1.launcher or 2.anchor
        const launcherEl = launcherRef.current;
        const anchorEl = anchorRef.current;
        if (launcherEl) {
            utils_PRIVATE_tabbableUtils.focusOn(launcherEl);
            // Checking instanceof to avoid Coords type that can not be focused
        }
        else if (anchorEl && anchorEl instanceof Element) {
            utils_PRIVATE_tabbableUtils.focusOn(anchorEl);
        }
    };
    hooks.useEffect(() => {
        // Init closing
        if (!isOpen && status === 'opening') {
            // Only actively return focus to the launcher or anchor if the popup contained focus.
            // Otherwise, focus is already elsewhere on the page and should not be forced back
            // because that could reopen the popup again, which essentially prevents the user from
            // moving focus out of the launcher.
            if (contentWrapperRef.current?.contains(utils_PRIVATE_tabbableUtils.getActiveElement())) {
                returnFocus();
            }
        }
    }, [isOpen, status]);
    // Launcher handler
    hooks.useEffect(() => {
        if (isOpen && anchorRef.current instanceof Element) {
            // Remember launcher
            if (utils_PRIVATE_tabbableUtils.getActiveElement() === document.body) {
                launcherRef.current = anchorRef.current;
            }
            else {
                launcherRef.current = utils_PRIVATE_tabbableUtils.getActiveElement();
            }
            // Register F6 key handler to enter the Popup
            launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);
        }
        return () => {
            // Deregister F6 key handler
            launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);
        };
    }, [isOpen]);
    const setInitialFocus = () => {
        let derivedInitialFocus = initialFocus;
        if (initialFocus === 'auto') {
            // Modeless mode - do not steal focus by default
            derivedInitialFocus = 'none';
        }
        // Case: 'popup'
        // Focus on Popup container
        if (derivedInitialFocus === 'popup') {
            utils_PRIVATE_tabbableUtils.focusOn(contentWrapperRef.current);
        }
        // Case: 'firstFocusable'
        // Focus on first tabbable in the Popup container or container itself if there is none
        if (derivedInitialFocus === 'firstFocusable') {
            utils_PRIVATE_tabbableUtils.focusWithin(contentWrapperRef.current);
        }
    };
    const getMainAxisOffset = (offset) => {
        let calcOffset = 0;
        if (offset) {
            // @ts-ignore as OffsetFunction is going to be removed
            // Property 'mainAxis' does not exist on type 'OffsetFunction'.
            calcOffset = typeof offset === 'number' ? offset : offset.mainAxis || 0;
            if (tail === 'simple') {
                calcOffset += 5;
            }
        }
        return calcOffset;
    };
    const getCrossAxisOffset = (offset) => {
        if (!offset) {
            return 0;
        }
        else {
            // @ts-ignore as OffsetFunction is going to be removed
            // Property 'crossAxis' does not exist on type 'OffsetFunction'.
            return typeof offset === 'number' ? 0 : offset.crossAxis || 0;
        }
    };
    const finalOffset = {
        mainAxis: getMainAxisOffset(offset),
        crossAxis: getCrossAxisOffset(offset)
    };
    // Preact FocusEvent mapping
    // onFocus - focusin
    // onBlur - focusout
    //
    // https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/relatedTarget
    // Event name   target                           relatedTarget
    // blur         The EventTarget losing focus     The EventTarget receiving focus (if any).
    // focus        The EventTarget receiving focus  The EventTarget losing focus (if any)
    // focusin      The EventTarget receiving focus  The EventTarget losing focus (if any)
    // focusout     The EventTarget losing focus     The EventTarget receiving focus (if any)
    const handleOnFocus = (event) => {
        // Executing this listener means that element receiving focus lives within Popup.
        // We are checking which element is loosing focus to avoid activating FocusTrap when focus
        // travels among elements within FocusTrap.
        // To enable FocusTrap the element that looses focus must live out of the Popup or is Popup's container.
        if (!contentWrapperRef.current?.contains(event.relatedTarget) ||
            event.relatedTarget === contentWrapperRef.current) {
            // Do not activate focusTrap if the event.target is Popup itself - if we clicked on Popup's container
            // We should be able to focus Popup container without activating FocusTrap
            if (event.target != contentWrapperRef.current) {
                // Enable FocusTrap.
                setTrapDisabled(false);
            }
        }
    };
    const handleOnBlur = (event) => {
        // Executing this listener means that an element living within Popup is loosing focus.
        // We are checking which element is receiving focus to avoid disabling FocusTrap when focs
        // travels among elements within FocusTrap.
        // To disable FocusTrap element the element that receives focus must live out of the Popup or is Popup's container.
        if (!contentWrapperRef.current?.contains(event.relatedTarget) ||
            event.relatedTarget === contentWrapperRef.current) {
            // Disable FocusTrap.
            setTrapDisabled(true);
        }
    };
    const handlePopupKeyDown = (event) => {
        const currentlyFocusedEl = utils_PRIVATE_tabbableUtils.getActiveElement();
        const wrapperEl = contentWrapperRef.current;
        const launcherEl = launcherRef.current;
        if (wrapperEl === currentlyFocusedEl || wrapperEl?.contains(currentlyFocusedEl)) {
            switch (event.code) {
                case 'Escape': {
                    onClose?.(event);
                    break;
                }
                case 'F6':
                    // Prevent default F6 handlers.
                    // F6 is a standard Chrome address bar shortcut on Windows.
                    event.preventDefault();
                    event.stopPropagation();
                    // Focus launcher
                    if (launcherEl) {
                        utils_PRIVATE_tabbableUtils.focusOn(launcherEl);
                    }
                    // Disable FocusTrap
                    setTrapDisabled(true);
                    break;
                case 'Tab':
                    // If tabbing out of the popup when the popup itself has focus and the focus trap is
                    // disabled, transfer focus back to the launcher.  Don't let the browser then
                    // transfer focus itself from there like it normally would.
                    if (event.target === contentWrapperRef.current && trapDisabled) {
                        // Focus launcher
                        if (launcherEl) {
                            utils_PRIVATE_tabbableUtils.focusOn(launcherEl);
                            // Prevent the browser from transferring focus itself.
                            event.preventDefault();
                        }
                    }
                    break;
            }
        }
    };
    const onPosition = hooks.useCallback((data) => {
        if (placement !== data.placement) {
            //if flips happens we need to change the placement in the animations.
            setAnimationPlacement(data.placement);
        }
    }, [setAnimationPlacement, placement]);
    hooks.useLayoutEffect(() => {
        if (status === 'unmounted' ||
            contentWrapperRef.current == null ||
            popupBgColor != null ||
            tail === 'none')
            return;
        const backgroundColorVar = stringUtils.getVarName(UNSAFE_Popup_themes_PopupContract_css.popupVars.backgroundColor);
        const computedStyle = getComputedStyle(contentWrapperRef.current);
        setPopupBgColor(computedStyle.getPropertyValue(backgroundColorVar));
    }, [status, contentWrapperRef, popupBgColor, tail]);
    // Styles
    const { baseTheme, classes } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_Popup_themes_redwood_PopupTheme.PopupRedwoodTheme);
    const isMounted = status !== 'unmounted';
    return (isMounted && (jsxRuntime.jsx(UNSAFE_Layer.Layer, { children: jsxRuntime.jsx(Floating.Floating, { ref: stableRef, backgroundColor: popupBgColor, anchorRef: anchorRef, placement: placement, offsetValue: finalOffset, flipOptions: flipOptions, shiftOptions: shiftOptions, onClickOutside: onClickOutside, tail: tail, onPosition: onPosition, children: jsxRuntime.jsx("div", { ref: contentWrapperRef, tabIndex: -1, role: role, className: classNames.classNames([baseTheme, classes]), onFocus: handleOnFocus, onBlur: handleOnBlur, onKeyDown: handlePopupKeyDown, children: jsxRuntime.jsx(FocusTrap.FocusTrap, { isDisabled: trapDisabled, restoreFocusRef: false, children: children }) }) }) })));
});

exports.Popup = Popup;
//# sourceMappingURL=UNSAFE_Popup.js.map
