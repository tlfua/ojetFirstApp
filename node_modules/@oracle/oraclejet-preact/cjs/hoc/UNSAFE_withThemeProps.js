/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var preact = require('preact');
var compat = require('preact/compat');
var UNSAFE_Environment = require('../index-c3ee789d.js');
var UNSAFE_Theme = require('../UNSAFE_Theme.js');
require('../Common.js');
require('../Common/themes.js');
require('../Common/themes/redwood/theme.js');
require('../Common/themes/themeContract.css.js');
require('preact/hooks');
require('../utils-b9f57550.js');

/**
 * Higher Order Component that allows you to wrap an existing component with an EnvironmentProvider
 * containing the desired colorScheme and scale context. The returned component contains all the props
 * of the wrapped component with the addition of the `colorScheme` and `scale` props.
 *
 * This should be used when nesting an alternate colorScheme (ie dark palette sub-form within a global light
 * palette). You can use this HOC instead of manually applying colorScheme classnames to DOM elements. This also
 * eliminates the need to add additional DOM wrapper elements.
 */
const withThemeProps = (WrappedComponent) => {
    const displayName = WrappedComponent.displayName || WrappedComponent.name || 'ComponentWithProvider';
    const ComponentWithProvider = compat.forwardRef(({ colorScheme, scale, ...props }, ref) => {
        // if no ref is supplied, create one
        const wrapRef = (ref || preact.createRef());
        compat.useEffect(() => {
            if (wrapRef.current) {
                const { classList } = wrapRef.current;
                if (!classList)
                    return;
                // dynamically apply the appropriate colorscheme classname to ref element
                if (colorScheme) {
                    const schemes = [
                        UNSAFE_Theme.LIGHT_CLASS,
                        UNSAFE_Theme.DARK_CLASS,
                        UNSAFE_Theme.INVERT_CLASS,
                        UNSAFE_Theme.COLORSCHEME_DEPENDENT_CLASS
                    ];
                    schemes.map((current) => classList.remove(current));
                    if (colorScheme === 'dark') {
                        classList.add(UNSAFE_Theme.DARK_CLASS);
                        classList.add(UNSAFE_Theme.INVERT_CLASS);
                    }
                    else {
                        classList.add(UNSAFE_Theme.LIGHT_CLASS);
                    }
                    classList.add(UNSAFE_Theme.COLORSCHEME_DEPENDENT_CLASS);
                }
                // dynamically apply the appropriate scale classname to ref element
                if (scale) {
                    const scales = [UNSAFE_Theme.SCALE_SM_CLASS, UNSAFE_Theme.SCALE_MD_CLASS, UNSAFE_Theme.SCALE_LG_CLASS, UNSAFE_Theme.SCALE_DEPENDENT_CLASS];
                    scales.map((current) => classList.remove(current));
                    classList.add(`${scale === 'sm' ? UNSAFE_Theme.SCALE_SM_CLASS : scale === 'md' ? UNSAFE_Theme.SCALE_MD_CLASS : UNSAFE_Theme.SCALE_LG_CLASS}`);
                    classList.add(UNSAFE_Theme.SCALE_DEPENDENT_CLASS);
                }
            }
        }, [wrapRef, colorScheme]);
        // wrap component with new colorscheme context
        return (jsxRuntime.jsx(UNSAFE_Environment.EnvironmentProvider, { environment: { colorScheme, scale }, children: jsxRuntime.jsx(WrappedComponent, { ...props, ref: wrapRef }) }));
    });
    ComponentWithProvider.displayName = `withThemeProps(${displayName})`;
    return ComponentWithProvider;
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

exports.withThemeProps = withThemeProps;
//# sourceMappingURL=UNSAFE_withThemeProps.js.map
