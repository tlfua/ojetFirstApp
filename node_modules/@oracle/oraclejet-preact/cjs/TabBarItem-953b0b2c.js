/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var utils_PRIVATE_collectionUtils = require('./utils/PRIVATE_collectionUtils.js');
var utils_UNSAFE_mergeProps = require('./utils/UNSAFE_mergeProps.js');
require('./utils/UNSAFE_classNames.js');
var hooks_PRIVATE_useCollectionFocusRing = require('./hooks/PRIVATE_useCollectionFocusRing.js');
var hooks_PRIVATE_useCurrentKey = require('./hooks/PRIVATE_useCurrentKey.js');
require('./UNSAFE_Flex.js');
var hooks_UNSAFE_useUser = require('./hooks/UNSAFE_useUser.js');
var UNSAFE_TabBar_themes_TabBarStyles_css = require('./UNSAFE_TabBar/themes/TabBarStyles.css.js');
var classNames = require('./classNames-d619a292.js');
var Flex = require('./Flex-2eb09dad.js');
var hooks_UNSAFE_usePress = require('./hooks/UNSAFE_usePress.js');
require('./UNSAFE_Text.js');
var preact = require('preact');
var utils_UNSAFE_mergeInterpolations = require('./utils/UNSAFE_mergeInterpolations.js');
require('./utils/UNSAFE_interpolations/flexitem.js');
var hooks_UNSAFE_useComponentTheme = require('./hooks/UNSAFE_useComponentTheme.js');
var UNSAFE_TabBar_themes_redwood_TabBarItemTheme = require('./UNSAFE_TabBar/themes/redwood/TabBarItemTheme.js');
var flexitem = require('./flexitem-939ec1ef.js');
var Text = require('./Text-4f1f698a.js');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Context used to pass TabBar information without having to pass it to TabBar children props.
 * We want to communicate information down to any interested TabBar item children.
 */
const TabBarContext = preact.createContext(null);

function TabBar({ children, layout = 'stretch', selection, onSelectionChange }) {
    const rootRef = hooks.useRef(null);
    const isFirstItemRendered = hooks.useRef(false);
    const [currentKey, setCurrentKey] = hooks.useState(selection);
    const [showFocusRing, focusRingProps] = hooks_PRIVATE_useCollectionFocusRing.useCollectionFocusRing((elem) => {
        return !!rootRef.current?.contains(elem);
    }, ['ArrowRight', 'ArrowLeft']);
    const ITEM_SELECTOR = '.' + 'oj-c-tabbar-item';
    const { currentKeyProps } = hooks_PRIVATE_useCurrentKey.useCurrentKey((element) => utils_PRIVATE_collectionUtils.keyExtractor(element, ITEM_SELECTOR), false, undefined, undefined, utils_PRIVATE_collectionUtils.getPrevNextKey(rootRef.current, currentKey, true, ITEM_SELECTOR), utils_PRIVATE_collectionUtils.getPrevNextKey(rootRef.current, currentKey, false, ITEM_SELECTOR), currentKey, (detail) => setCurrentKey(detail.value));
    //If selection is undefined the currentKey would be undefined in that case keyboard
    //navigation using useCurrentKey is not possible as it expects a valid currentKey
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const isRtl = direction === 'rtl';
    const onKeyDown = hooks.useCallback((event) => {
        if (currentKey === undefined) {
            if (event.key === 'ArrowRight' || (!isRtl && event.key === 'ArrowLeft')) {
                const targetKey = event.target.getAttribute('data-oj-key');
                if (targetKey) {
                    const nextKey = utils_PRIVATE_collectionUtils.getPrevNextKey(rootRef.current, targetKey, false, ITEM_SELECTOR)();
                    if (nextKey !== null) {
                        setCurrentKey(nextKey);
                    }
                }
            }
        }
    }, [currentKey]);
    const onKeyDownProps = { onKeyDown };
    hooks.useEffect(() => {
        isFirstItemRendered.current = false;
    });
    const isActiveElement = hooks.useCallback(() => {
        return !!rootRef?.current?.contains(document.activeElement);
    }, []);
    const tabBarClass = classNames.classNames([UNSAFE_TabBar_themes_TabBarStyles_css.styles.tabBarBase]);
    return (jsxRuntime.jsx(TabBarContext.Provider, { value: {
            selection,
            onSelectionChange,
            currentKey,
            showFocusRing,
            layout,
            isActiveElement,
            isFirstItemRendered
        }, children: jsxRuntime.jsx("div", { class: tabBarClass, role: 'tablist', ref: rootRef, tabIndex: children ? -1 : 0, "aria-multiselectable": false, ...utils_UNSAFE_mergeProps.mergeProps(onKeyDownProps, currentKeyProps, focusRingProps), children: jsxRuntime.jsx(Flex.Flex, { direction: "row", gap: "8x", children: children }) }) }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Utility hook for consuming the TabBarContext
 *
 * @returns The value of TabBarContext provider
 */
function useTabBarContext() {
    return hooks.useContext(TabBarContext);
}

const ITEM_STYLE_CLASS = 'oj-c-tabbar-item';
function TabBarItem({ itemKey, label, startContent, endContent }) {
    const tabBarItemRef = hooks.useRef(null);
    const { onSelectionChange, selection, currentKey, showFocusRing, layout, isActiveElement, isFirstItemRendered } = useTabBarContext();
    const isCurrent = currentKey === itemKey;
    let tabIndex = isCurrent ? 0 : -1;
    //If currentKey is undefined, in order to tab to a TabBarItem, the first TabBarItem should set its tabindex to 0
    if (currentKey === undefined && isFirstItemRendered && !isFirstItemRendered.current) {
        tabIndex = 0;
        isFirstItemRendered.current = true;
    }
    //Selection
    const handlePress = () => {
        onSelectionChange?.({ value: itemKey });
    };
    const { pressProps } = hooks_UNSAFE_usePress.usePress(handlePress);
    const isSelected = selection === itemKey;
    hooks.useLayoutEffect(() => {
        if (isActiveElement?.() && isCurrent) {
            tabBarItemRef?.current?.focus();
        }
    }, [isCurrent, isActiveElement]);
    const { classes, styles: { tabBarItemStartContent, tabBarItemEndContent } } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TabBar_themes_redwood_TabBarItemTheme.TabBarItemRedwoodTheme, {
        selection: isSelected ? 'isSelected' : 'notSelected',
        current: isCurrent ? 'isCurrent' : 'notCurrent',
        focusRing: showFocusRing ? 'showFocusRing' : 'noFocusRing'
    });
    const tabBarItem = classNames.classNames([classes, ITEM_STYLE_CLASS]);
    const tabBarItemStartContentClasses = classNames.classNames([tabBarItemStartContent]);
    const tabBarItemEndContentClasses = classNames.classNames([tabBarItemEndContent]);
    //instead of specifying flex: '1 0 auto' in cssProps var
    const styleInterpolations = utils_UNSAFE_mergeInterpolations.mergeInterpolations([
        ...Object.values(flexitem.flexitemInterpolations)
    ]);
    const flexDimensions = styleInterpolations({
        flex: layout === 'stretch' ? '1 0 auto' : '0 0 auto'
    });
    return (jsxRuntime.jsx("div", { "data-oj-key": itemKey, class: tabBarItem, role: "tab", ref: tabBarItemRef, ...pressProps, "aria-selected": isSelected, tabIndex: tabIndex, style: flexDimensions, children: jsxRuntime.jsxs(Flex.Flex, { height: "11x", minWidth: "14x", direction: "row", gap: "2x", align: "center", justify: "center", flex: "1 1 auto", children: [startContent && jsxRuntime.jsx("span", { class: tabBarItemStartContentClasses, children: startContent }), label && (jsxRuntime.jsx(Text.Text, { size: "md", weight: "semiBold", children: label })), endContent && jsxRuntime.jsx("span", { class: tabBarItemEndContentClasses, children: endContent })] }) }));
}

exports.TabBar = TabBar;
exports.TabBarItem = TabBarItem;
//# sourceMappingURL=TabBarItem-953b0b2c.js.map
