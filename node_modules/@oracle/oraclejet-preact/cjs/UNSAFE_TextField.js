/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var ReadonlyTextFieldInput = require('./ReadonlyTextFieldInput-df771dd2.js');
var jsxRuntime = require('preact/jsx-runtime');
var hooks_UNSAFE_useFormContext = require('./hooks/UNSAFE_useFormContext.js');
var UNSAFE_LabelValueLayout = require('./UNSAFE_LabelValueLayout.js');
require('./utils/UNSAFE_classNames.js');
var hooks_UNSAFE_useFormFieldContext = require('./hooks/UNSAFE_useFormFieldContext.js');
var hooks_UNSAFE_useComponentTheme = require('./hooks/UNSAFE_useComponentTheme.js');
var hooks_UNSAFE_useInputGroupContext = require('./hooks/UNSAFE_useInputGroupContext.js');
var hooks_UNSAFE_useUser = require('./hooks/UNSAFE_useUser.js');
var UNSAFE_TextField_themes_redwood_TextFieldTheme = require('./UNSAFE_TextField/themes/redwood/TextFieldTheme.js');
var UNSAFE_Label_themes_redwood_LabelTheme = require('./UNSAFE_Label/themes/redwood/LabelTheme.js');
var UNSAFE_TextField_themes_redwood_FormLayoutTheme = require('./UNSAFE_TextField/themes/redwood/FormLayoutTheme.js');
var UNSAFE_TextField_themes_redwood_ReadonlyTextFieldTheme = require('./UNSAFE_TextField/themes/redwood/ReadonlyTextFieldTheme.js');
var classNames = require('./classNames-d619a292.js');
require('./UNSAFE_Flex.js');
var Flex = require('./Flex-2eb09dad.js');
var UNSAFE_Skeleton_themes_redwood_SkeletonTheme = require('./UNSAFE_Skeleton/themes/redwood/SkeletonTheme.js');
var TextFieldInput = require('./TextFieldInput-28035e98.js');
var preact = require('preact');
var hooks_UNSAFE_useDebounce = require('./hooks/UNSAFE_useDebounce.js');
var hooks_UNSAFE_useTranslationBundle = require('./hooks/UNSAFE_useTranslationBundle.js');
var UNSAFE_LiveRegion = require('./UNSAFE_LiveRegion.js');
require('./hooks/UNSAFE_useAccessibleContext.js');
require('preact/hooks');
require('./hooks/UNSAFE_useTabbableMode.js');
require('./utils/UNSAFE_interpolations/text.js');

require('./index-8a92ac2f.js');
require('./utils/UNSAFE_mergeInterpolations.js');
require('./_curry1-6e9511bf.js');
require('./_curry3-ad2313fd.js');
require('./_curry2-53a902bf.js');
require('./_has-aa203696.js');
require('./UNSAFE_TextField/themes/redwood/ReadonlyTextFieldInputTheme.js');
require('./UNSAFE_TextField/themes/ReadonlyTextFieldInputStyles.css.js');

require('./UNSAFE_TextField/themes/redwood/ReadonlyTextFieldInputVariants.css.js');
require('./vanilla-extract-recipes-createRuntimeFn.esm-8a4b93e4.js');
require('./utils/UNSAFE_size.js');
require('./UNSAFE_Theme.js');
require('./utils-b9f57550.js');
require('./Common/themes/themeContract.css.js');

require('./UNSAFE_Radio/themes/redwood/RadioTheme.js');
require('./UNSAFE_Radio/themes/RadioStyles.css.js');

require('./UNSAFE_Radio/themes/redwood/RadioBaseTheme.css.js');

require('./UNSAFE_Radio/themes/redwood/RadioVariants.css.js');
require('./utils/UNSAFE_interpolations/dimensions.js');
require('./utils/UNSAFE_arrayUtils.js');
require('./utils/UNSAFE_interpolations/boxalignment.js');
require('./keys-65201aa4.js');
require('./utils/UNSAFE_interpolations/flexbox.js');
require('./flexbox-8cd3009d.js');
require('./utils/UNSAFE_interpolations/flexitem.js');
require('./flexitem-939ec1ef.js');
require('./utils/UNSAFE_logger.js');
require('./UNSAFE_TextField/themes/TextFieldStyles.css.js');



require('./UNSAFE_TextField/themes/redwood/TextFieldBaseTheme.css.js');

require('./UNSAFE_TextField/themes/redwood/TextFieldVariants.css.js');

require('./UNSAFE_Label/themes/LabelStyles.css.js');

require('./UNSAFE_Label/themes/redwood/LabelBaseTheme.css.js');

require('./UNSAFE_Label/themes/redwood/LabelVariants.css.js');
require('./UNSAFE_TextField/themes/FormLayoutStyles.css.js');
require('./UNSAFE_TextField/themes/redwood/FormLayoutBaseTheme.css.js');

require('./index-c3ee789d.js');
require('./Common.js');
require('./Common/themes.js');
require('./Common/themes/redwood/theme.js');
require('preact/compat');
require('./UNSAFE_TextField/themes/ReadonlyTextFieldStyles.css.js');

require('./UNSAFE_TextField/themes/redwood/ReadonlyTextFieldVariants.css.js');

require('./UNSAFE_Skeleton/themes/SkeletonStyles.css.js');
require('./UNSAFE_Skeleton/themes/redwood/SkeletonBaseTheme.css.js');

require('./UNSAFE_Skeleton/themes/redwood/SkeletonVariants.css.js');
require('./hooks/UNSAFE_useTextFieldInputHandlers.js');
require('./utils/PRIVATE_clientHints.js');
require('./clientHints-b9e7be1e.js');
require('./utils/UNSAFE_mergeProps.js');
require('./UNSAFE_TextField/themes/redwood/TextFieldInputTheme.js');
require('./UNSAFE_TextField/themes/TextFieldInputStyles.css.js');

require('./UNSAFE_TextField/themes/redwood/TextFieldInputVariants.css.js');

const StartTopLabelReadonlyTextField = ({ outerClassNames, innerClassNames, label, labelEdge, labelStartWidth, compactUserAssistance, inlineUserAssistance, children, ...props }) => {
    return (jsxRuntime.jsxs("div", { ...props, class: outerClassNames, children: [compactUserAssistance, jsxRuntime.jsx(UNSAFE_LabelValueLayout.LabelValueLayout, { label: label, labelEdge: labelEdge, labelStartWidth: labelStartWidth, children: jsxRuntime.jsx("div", { class: innerClassNames, children: children }) }), inlineUserAssistance] }));
};
const InsideLabelReadonlyTextField = ({ outerClassNames, innerClassNames, compactUserAssistance, inlineUserAssistance, children, ...props }) => {
    return (jsxRuntime.jsxs("div", { ...props, class: outerClassNames, children: [compactUserAssistance, jsxRuntime.jsx("div", { class: innerClassNames, children: children }), inlineUserAssistance] }));
};
const ReadonlyTextField = ({ label, labelEdge, children, variant, ...props }) => {
    const { isFormLayout, isReadonly: isReadonlyForm } = hooks_UNSAFE_useFormContext.useFormContext();
    const { isLoading } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
    const hasInsideLabel = label !== undefined && labelEdge === 'inside';
    const isInsideNonReadonlyForm = isFormLayout && !isReadonlyForm;
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const isLtr = direction === 'ltr';
    const inputGroupContext = hooks_UNSAFE_useInputGroupContext.useInputGroupContext();
    const hasGroupContext = inputGroupContext !== null;
    // depending on browser direction, apply the appropriate styling.
    // when 'rtl' the flex row direction is reversed.
    const inputGroupPosition = inputGroupContext
        ? inputGroupContext.last
            ? isLtr
                ? 'groupRight'
                : 'groupLeft'
            : inputGroupContext.index === 0
                ? isLtr
                    ? 'groupLeft'
                    : 'groupRight'
                : 'groupMiddle'
        : undefined;
    const { classes, styles } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, {
        readonly: 'isReadonly'
    });
    const { baseTheme: labelBaseTheme } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_Label_themes_redwood_LabelTheme.LabelRedwoodTheme);
    const { baseTheme: formLayoutTheme } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_FormLayoutTheme.FormLayoutRedwoodTheme);
    const { classes: readonlyClassNames } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_ReadonlyTextFieldTheme.ReadonlyTextFieldRedwoodTheme, {
        insideNonReadonlyForm: isInsideNonReadonlyForm
            ? 'isInsideNonReadonlyForm'
            : 'notInsideNonReadonlyForm',
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        textarea: variant === 'textarea' ? 'isTextArea' : 'notTextArea',
        loading: isLoading ? 'isLoading' : 'notLoading',
        withinGroup: hasGroupContext ? 'isWithinGroup' : undefined,
        inputGroupPosition
    });
    const { formControlBase } = styles;
    const outerClassNames = classNames.classNames([classes, formControlBase, formLayoutTheme, labelBaseTheme]);
    if (label !== undefined && (labelEdge === 'start' || labelEdge === 'top')) {
        return (jsxRuntime.jsx(StartTopLabelReadonlyTextField, { outerClassNames: outerClassNames, innerClassNames: readonlyClassNames, label: label, labelEdge: labelEdge, ...props, children: children }));
    }
    return (jsxRuntime.jsxs(InsideLabelReadonlyTextField, { outerClassNames: outerClassNames, innerClassNames: readonlyClassNames, ...props, children: [label, children] }));
};

// Renders the oj-text-field-container dom which includes the
// start, middle (where the inside label and inputElem goes),
// and end pieces of the form component.
// This does not include user assistance because that is rendered outside the
// oj-text-field-container; that is rendered in the TextField component.
const TextFieldContent = ({ contentVariant = 'input', insideLabel, mainContent, startContent, statusVariant = 'none', styleVariant = 'default', endContent, resize, rootRef, hasZeroStartMargin }) => {
    const { isDisabled, isFocused, isLoading } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const isLtr = direction === 'ltr';
    const hasInsideLabel = insideLabel !== undefined;
    const inputGroupContext = hooks_UNSAFE_useInputGroupContext.useInputGroupContext();
    const hasGroupContext = inputGroupContext !== null;
    // depending on browser direction, apply the appropriate styling.
    // when 'rtl' the flex row direction is reversed.
    const inputGroupPosition = inputGroupContext
        ? inputGroupContext.last
            ? isLtr
                ? 'groupRight'
                : 'groupLeft'
            : inputGroupContext.index === 0
                ? isLtr
                    ? 'groupLeft'
                    : 'groupRight'
                : 'groupMiddle'
        : undefined;
    const { variantClasses, styles: { textFieldContainerBase } } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, {
        statusVariant,
        styleVariant,
        contentVariant,
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        focused: isFocused ? 'isFocused' : 'notFocused',
        disabled: isDisabled ? 'isDisabled' : 'notDisabled',
        loading: isLoading ? 'isLoading' : 'notLoading',
        resize: resize ?? 'none',
        withinGroup: hasGroupContext ? 'isWithinGroup' : undefined,
        inputGroupPosition
    });
    const { variantClasses: startContentStyles } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, {
        startContent: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        startContentMargin: hasZeroStartMargin ? 'noStartMargin' : 'hasStartMargin',
        startContentDisabled: isDisabled ? 'isDisabled' : 'notDisabled'
    });
    const { variantClasses: middleStyles } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, { middleContent: contentVariant });
    const { variantClasses: endContentStyles } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, { endContent: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel' });
    return (jsxRuntime.jsxs("div", { role: "presentation", class: classNames.classNames([variantClasses, textFieldContainerBase]), ref: rootRef, children: [startContent && (jsxRuntime.jsx("span", { class: startContentStyles, children: jsxRuntime.jsx(Flex.Flex, { justify: "center", align: "center", hasZeroMargins: true, children: startContent }) })), jsxRuntime.jsxs("div", { class: middleStyles, children: [insideLabel, mainContent] }), endContent && (jsxRuntime.jsx("span", { class: endContentStyles, children: jsxRuntime.jsx(Flex.Flex, { justify: "center", align: "center", hasZeroMargins: true, children: endContent }) }))] }));
};

const StyledTextField = ({ hasInsideLabel = false, variant = 'default', ...props }) => {
    // because of the mismatch of height for inputs with inside labels and no labels,
    // we'll have to set everything to the same min-height while within an input group context.
    // Here we'll look to see if it's present and apply the style as needed
    const groupContext = hooks_UNSAFE_useInputGroupContext.useInputGroupContext();
    const { isReadonly } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
    const { baseTheme: formLayoutTheme } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_FormLayoutTheme.FormLayoutRedwoodTheme);
    const { baseTheme: labelBaseTheme } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_Label_themes_redwood_LabelTheme.LabelRedwoodTheme);
    const { classes: textFieldClasses, styles } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme, {
        readonly: isReadonly ? 'isReadonly' : 'notReadonly',
        formControlInsideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel',
        withinGroup: groupContext !== null ? 'isWithinGroup' : undefined
    });
    const { formControlBase, textFieldBase, textFieldEmbedded } = styles;
    // because TextField components reference Skeleton scoped vars, we need to bring in the Skeleton base theme
    // to pick up the scoped var definitions.
    const { baseTheme: skeletonBaseTheme } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_Skeleton_themes_redwood_SkeletonTheme.SkeletonRedwoodTheme);
    const classes = classNames.classNames([
        skeletonBaseTheme,
        formControlBase,
        textFieldBase,
        variant === 'embedded' && textFieldEmbedded,
        textFieldClasses,
        formLayoutTheme,
        labelBaseTheme
    ]);
    return jsxRuntime.jsx("div", { ...props, class: classes });
};

// TODO: Do we need named props for start/endContent, or could they just be children that get
// wrapped in a flex layout?  (from review on 3/8/22)
// TODO: Instead of passing the inputElem, label, and userAssistance as named props here, should we
// have a separate layout component that lays them out, which could just be passed as a child
// to the TextField?  (from review on 3/8/22)
const TextField = ({ contentVariant, id, endContent, mainContent, startContent, compactUserAssistance, inlineUserAssistance, label, labelEdge, labelStartWidth, mainFieldRef, resize, statusVariant, styleVariant, hasZeroStartMargin, onFocus, onBlur, onKeyDown, onMouseDown, onMouseEnter, onMouseLeave }) => {
    // TODO: What are the implications for interoperability between new preact-based form components
    // and the existing JET oj-form-layout?  The preact form components create their own start/top
    // labels, while oj-form-layout expects to create those itself and wire them to the existing form
    // components through attributes like labelled-by.  (from review on 3/8/22)
    // TODO: How should a parent form component render component-specific content within TextField,
    // for example an aria live region?  Instead of a children prop on TextField, could the parent
    // component pass comp-specific content through other props, like inputElem?   The parent could
    // have its own component that composes inputElem with additional DOM.  (from review on 3/8/22)
    const isStartTop = label !== undefined && (labelEdge === 'start' || labelEdge === 'top');
    const textFieldContent = (jsxRuntime.jsx(TextFieldContent, { contentVariant: contentVariant, endContent: endContent, mainContent: mainContent, resize: resize, rootRef: mainFieldRef, startContent: startContent, statusVariant: statusVariant, styleVariant: styleVariant, hasZeroStartMargin: hasZeroStartMargin, ...(!isStartTop ? { insideLabel: label } : {}) }));
    const innerContent = (jsxRuntime.jsxs(jsxRuntime.Fragment, { children: [compactUserAssistance, textFieldContent, inlineUserAssistance] }));
    const styledTextFieldChildren = isStartTop ? (jsxRuntime.jsx(UNSAFE_LabelValueLayout.LabelValueLayout, { label: label, labelEdge: labelEdge, labelStartWidth: labelStartWidth, children: innerContent })) : (innerContent);
    return (jsxRuntime.jsx(StyledTextField, { id: id, hasInsideLabel: label !== undefined && labelEdge === 'inside', onfocusin: onFocus, onfocusout: onBlur, onKeyDown: onKeyDown, onMouseDown: onMouseDown, onMouseEnter: onMouseEnter, onMouseLeave: onMouseLeave, variant: styleVariant, children: styledTextFieldChildren }));
};

const MAX_LENGTH_UPDATE_DELAY = 500;
function MaxLengthLiveRegion({ isMaxLengthExceeded, maxLength, valueLength = 0 }) {
    // Comment copied from InputBase.js in Big JET:
    // Only update the aria-live div when the user has paused for more than
    // 500 milliseconds. That way, we avoid queued up aria-live messages which
    // would be annoying and not helpful. The 500ms was agreed upon in the
    // accessibility review meeting.
    const debouncedRemainingChars = hooks_UNSAFE_useDebounce.useDebounce(maxLength - valueLength, MAX_LENGTH_UPDATE_DELAY);
    const translations = hooks_UNSAFE_useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const maxLengthExceededTranslatedString = translations.formControl_maxLengthExceeded({
        MAX_LENGTH: `${maxLength}`
    });
    const remainingCharsTranslatedString = translations.formControl_maxLengthRemaining({
        CHARACTER_COUNT: `${debouncedRemainingChars}`
    });
    return (jsxRuntime.jsxs(preact.Fragment, { children: [jsxRuntime.jsx(UNSAFE_LiveRegion.LiveRegion, { children: remainingCharsTranslatedString }), isMaxLengthExceeded && (jsxRuntime.jsx(UNSAFE_LiveRegion.LiveRegion, { type: "assertive", children: maxLengthExceededTranslatedString }))] }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

exports.ReadonlyTextFieldInput = ReadonlyTextFieldInput.ReadonlyTextFieldInput;
exports.TextFieldInput = TextFieldInput.TextFieldInput;
exports.getInputId = TextFieldInput.getInputId;
exports.MaxLengthLiveRegion = MaxLengthLiveRegion;
exports.ReadonlyTextField = ReadonlyTextField;
exports.TextField = TextField;
//# sourceMappingURL=UNSAFE_TextField.js.map
