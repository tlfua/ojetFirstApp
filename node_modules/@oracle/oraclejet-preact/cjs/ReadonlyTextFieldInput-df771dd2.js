/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks_UNSAFE_useAccessibleContext = require('./hooks/UNSAFE_useAccessibleContext.js');
var hooks_UNSAFE_useFormContext = require('./hooks/UNSAFE_useFormContext.js');
var hooks_UNSAFE_useTabbableMode = require('./hooks/UNSAFE_useTabbableMode.js');
require('./utils/UNSAFE_classNames.js');
var utils_UNSAFE_interpolations_text = require('./utils/UNSAFE_interpolations/text.js');
var utils_UNSAFE_mergeInterpolations = require('./utils/UNSAFE_mergeInterpolations.js');
var hooks_UNSAFE_useFormFieldContext = require('./hooks/UNSAFE_useFormFieldContext.js');
var hooks_UNSAFE_useComponentTheme = require('./hooks/UNSAFE_useComponentTheme.js');
var UNSAFE_TextField_themes_redwood_ReadonlyTextFieldInputTheme = require('./UNSAFE_TextField/themes/redwood/ReadonlyTextFieldInputTheme.js');
var hooks_UNSAFE_useTranslationBundle = require('./hooks/UNSAFE_useTranslationBundle.js');
var classNames = require('./classNames-d619a292.js');

/**
 * Merge multiple ids into a space-separated list
 * @param ids The ids to be merged
 * @returns The space separated string of ids
 */
function mergeIDs(...ids) {
    return ids.filter(Boolean).join(' ') || undefined;
}
function ReadonlyTextFieldInput({ 'aria-describedby': ariaDescribedBy, 'aria-label': ariaLabel, 'aria-labelledby': inputLabelledBy, autoFocus, as = 'div', elementRef, hasEmptyLabel, hasInsideLabel = false, inlineUserAssistance, innerReadonlyField, rows, type, value = '', variant, ...props }) {
    const translations = hooks_UNSAFE_useTranslationBundle.useTranslationBundle('@oracle/oraclejet-preact');
    const loadingAriaLabel = translations.formControl_loading();
    const { isFormLayout, isReadonly: isReadonlyForm } = hooks_UNSAFE_useFormContext.useFormContext();
    const { isLoading } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
    const ariaLabelForReadonly = isLoading ? loadingAriaLabel : ariaLabel;
    // get classes for text align
    const interpolations = [...Object.values(utils_UNSAFE_interpolations_text.textInterpolations)];
    const styleInterpolations = utils_UNSAFE_mergeInterpolations.mergeInterpolations(interpolations);
    const { class: styleInterpolationClasses } = styleInterpolations(props);
    const { classes: themeClasses } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_ReadonlyTextFieldInputTheme.ReadonlyTextFieldInputRedwoodTheme, {
        textarea: variant === 'textarea' ? 'isTextArea' : 'notTextArea',
        formLayout: isFormLayout ? 'isFormLayout' : 'notFormLayout',
        readonlyForm: isReadonlyForm ? 'isReadonlyForm' : 'notReadonlyForm',
        insideLabel: hasInsideLabel ? 'hasInsideLabel' : 'noInsideLabel'
    });
    const readonlyDivClasses = classNames.classNames([themeClasses, styleInterpolationClasses]);
    // JET-52914 - Implement Tabbable mode API contract in InputText
    // spread tabbableModeProps on component
    const { isTabbable, tabbableModeProps } = hooks_UNSAFE_useTabbableMode.useTabbableMode();
    // JET-52089: add unsafe API for specifying an external label which is added to ariaLabelledBy on the input or div,
    // only when labelEdge is 'none' and label is ''. Since ariaLabelledBy takes precedence over all other
    // kinds of labels, this helps to ensure we don't override a meaningful label.
    const { UNSAFE_ariaLabelledBy } = hooks_UNSAFE_useAccessibleContext.useAccessibleContext();
    const ariaLabelledBy = hasEmptyLabel
        ? mergeIDs(inputLabelledBy, UNSAFE_ariaLabelledBy)
        : inputLabelledBy;
    if (as === 'input') {
        return (jsxRuntime.jsx("input", { "aria-describedby": ariaDescribedBy, "aria-label": ariaLabelForReadonly, "aria-labelledby": ariaLabelledBy, autofocus: autoFocus, class: readonlyDivClasses, readonly: true, 
            // @ts-ignore
            ref: elementRef, type: type, value: value, ...(!isTabbable && tabbableModeProps) }));
    }
    if (as === 'textarea') {
        return (jsxRuntime.jsx("textarea", { "aria-describedby": ariaDescribedBy, "aria-label": ariaLabelForReadonly, "aria-labelledby": ariaLabelledBy, autofocus: autoFocus, class: readonlyDivClasses, readonly: true, 
            // @ts-ignore
            ref: elementRef, rows: rows, ...(!isTabbable && tabbableModeProps), children: value }));
    }
    return (jsxRuntime.jsx("div", { "aria-describedby": ariaDescribedBy, "aria-label": ariaLabelForReadonly, "aria-labelledby": ariaLabelledBy, "aria-readonly": true, autofocus: autoFocus, class: readonlyDivClasses, 
        // @ts-ignore
        ref: elementRef, role: "textbox", ...tabbableModeProps, children: value }));
}

exports.ReadonlyTextFieldInput = ReadonlyTextFieldInput;
//# sourceMappingURL=ReadonlyTextFieldInput-df771dd2.js.map
