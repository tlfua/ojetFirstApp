/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var hooks = require('preact/hooks');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook for handling focus ring management in Collection components.
 *
 * @param contains function that returns true if the Collection contains the specified element.
 * @param navigationKeys set of keys that are considered as navigation keys for Collection.
 * @param isVisibleFocusLostOnClick boolean or function that returns a boolean that states if focus is going to be visible after a click
 * @returns
 */
function useCollectionFocusRing(contains, navigationKeys, isVisibleFocusLostOnClick = true) {
    const [focusRingVisible, setFocusRingVisible] = hooks.useState(false);
    const recentPointerRef = hooks.useRef(false);
    const blurDoneBecauseTabChangeRef = hooks.useRef(false);
    // We need to clear this out when using touching devices
    // TODO: We need to confirm if this type is correct or has to be changed
    const pointerDownTimerRef = hooks.useRef();
    const onFocus = hooks.useCallback(() => {
        if (!focusRingVisible &&
            recentPointerRef.current === false &&
            !blurDoneBecauseTabChangeRef.current) {
            setFocusRingVisible(true);
        }
        blurDoneBecauseTabChangeRef.current = false;
    }, [focusRingVisible]);
    const onBlur = hooks.useCallback((e) => {
        /* Between leaving the old element and entering the new element the active element
        is the document/body itself. This is not the case when blur is produced when changing tab.
        In this last case the document.active element is the same as the target of the blur method.*/
        if (e.target === document.activeElement) {
            blurDoneBecauseTabChangeRef.current = true;
        }
        setTimeout(() => {
            if (focusRingVisible && !contains(document.activeElement)) {
                // remove focus ring
                setFocusRingVisible(false);
            }
        }, FOCUS_SHIFT_TIMEOUT);
    }, [focusRingVisible, contains]);
    const onPointerDown = hooks.useCallback((e) => {
        const getIsVisibleFocusLostOnClick = typeof isVisibleFocusLostOnClick === 'function'
            ? isVisibleFocusLostOnClick(e.target)
            : isVisibleFocusLostOnClick;
        if (focusRingVisible && getIsVisibleFocusLostOnClick) {
            setFocusRingVisible(false);
        }
        recentPointerRef.current = true;
        pointerDownTimerRef.current = setTimeout(() => {
            recentPointerRef.current = false;
        }, FOCUS_SHIFT_TIMEOUT);
    }, [focusRingVisible, isVisibleFocusLostOnClick]);
    //onFocus is called after pointerDown on desktop devices, but for touch ones focus is triggered after touch end
    const onTouchEnd = hooks.useCallback(() => {
        clearTimeout(pointerDownTimerRef.current);
        recentPointerRef.current = true;
        setTimeout(() => {
            recentPointerRef.current = false;
        }, FOCUS_SHIFT_TIMEOUT);
    }, []);
    const onKeyDown = hooks.useCallback((event) => {
        if (navigationKeys.indexOf(event.key) > -1) {
            if (!focusRingVisible) {
                setFocusRingVisible(true);
            }
        }
    }, [focusRingVisible, navigationKeys]);
    const focusRingProps = { onFocus, onBlur, onPointerDown, onKeyDown, onTouchEnd };
    return [focusRingVisible, focusRingProps];
}
const FOCUS_SHIFT_TIMEOUT = 200;

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

exports.useCollectionFocusRing = useCollectionFocusRing;
//# sourceMappingURL=PRIVATE_useCollectionFocusRing.js.map
