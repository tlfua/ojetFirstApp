{"version":3,"file":"PRIVATE_useAnimationStatus.js","sources":["../../../src/hooks/PRIVATE_useAnimationStatus/useAnimationStatus.ts"],"sourcesContent":["import { useRef, useCallback, useState, useEffect } from 'preact/hooks';\nimport { useAnimation, UseAnimationConfig } from '../UNSAFE_useAnimation';\nimport { RefObject } from 'preact';\n\ntype AnimationCallback = UseAnimationConfig<AnimationStatus, HTMLElement>['onAnimationEnd'];\ntype AnimationStates = UseAnimationConfig<AnimationStatus, HTMLElement>['animationStates'];\n\n/**\n * Animation Status\n * 'unmounted' indicates the element is unmounted from the screen. No transitions should be applied.\n * 'initial' indicates the element is mounted, but stays hidden and is in the initial state\n * 'opening' indicates the element is in the opening state, visible and begins transitioning in.\n * 'closing' indicates the element is in the closing state, visible and begins transitioning out\n * The animation state lifecycle is as follows: 'unmounted' => 'initial' => 'opening' => 'closing' => 'unmounted'\n */\nexport type AnimationStatus = 'unmounted' | 'initial' | 'opening' | 'closing';\n\n/**\n * The AnimationStatus hook properties\n */\nexport type AnimationStatusProps = {\n  /**\n   * isOpen property indicates that animation should change to status opening\n   */\n  isOpen: boolean;\n  /**\n   * If isAnimatedOnMount true, the animation should start on mount\n   */\n  isAnimatedOnMount: boolean;\n  /**\n   * animationStates is the configuration of the animations, how the element should be animated\n   */\n  animationStates: AnimationStates;\n  /**\n   * The callback called after animation is finished\n   * @returns\n   */\n  onTransitionEnd?: (isOpen: boolean) => void;\n};\n\nexport function useAnimationStatus<E extends HTMLElement>({\n  isOpen,\n  isAnimatedOnMount,\n  animationStates,\n  onTransitionEnd\n}: AnimationStatusProps): {\n  /**\n   * status is the animation status\n   */\n  status: AnimationStatus;\n  /**\n   * animationElementRef is the reference of the element that is animated\n   */\n  animationElementRef: RefObject<E | null>;\n  /**\n   * setAnimationElementRef is a callback that should be used to set up element for the animation\n   * @param node an element that animation should be applied to\n   * @returns\n   */\n  setAnimationElementRef: (node: E | null) => void;\n} {\n  const [status, setStatus] = useState<AnimationStatus>(isOpen ? 'initial' : 'unmounted');\n  const animationElementRef = useRef<E | null>(null);\n  const [animationElement, _setAnimationElement] = useState<E | null>(null);\n\n  const { nodeRef } = useAnimation<AnimationStatus, HTMLElement>(status, {\n    animationStates,\n    isAnimatedOnMount: isAnimatedOnMount,\n    onAnimationEnd: useCallback<NonNullable<AnimationCallback>>(() => {\n      if (status === 'opening') {\n        onTransitionEnd?.(true);\n      } else if (!isOpen) {\n        Object.assign(animationElement!.style, {\n          visibility: null\n        });\n        setStatus('unmounted');\n        onTransitionEnd?.(false);\n      }\n    }, [status, isOpen, onTransitionEnd, animationElement])\n  });\n\n  // We need setRef callback in order to set up visibility and node for the animation\n  // before it gets rendered in the next render cycle, i.e. when status === 'initial' the component is rendered,\n  // after component is rendered but is not yet painted references are applied, here we have the chance to set visibility to hidden\n  // and set up animation node.\n  const setAnimationRef = useCallback(\n    (node: E | null) => {\n      if (animationElementRef.current !== node) {\n        animationElementRef.current = node;\n        // Component will be visually hidden when status is 'initial' to avoid flickering.\n        // Flickering happens because it gets rendered before animation happens\n        // in next render cycle\n        if (node != null && status == 'initial') {\n          Object.assign(node.style, {\n            visibility: 'hidden'\n          });\n        }\n        nodeRef(node);\n        _setAnimationElement(node);\n      }\n    },\n    [status, nodeRef]\n  );\n\n  useEffect(() => {\n    // 1. Ignore status update on initial render\n    if (status === 'unmounted' && !isOpen) {\n      return;\n    }\n    // 2. Mount visually hidden component\n    // Component gets mounted\n    if (status === 'unmounted' && isOpen) {\n      setStatus('initial');\n      return;\n    }\n\n    // 3. Setup animation\n    // Component has been mounted.\n    // We will kick out animation as node is already present in DOM.\n    if (status === 'initial' && isOpen) {\n      setStatus('opening');\n      return;\n    }\n\n    // 4. Unhide component.\n    if (status === 'opening' && isOpen) {\n      Object.assign(animationElement!.style, {\n        visibility: 'visible'\n      });\n      return;\n    }\n\n    // 5. Closing\n    if (!isOpen) {\n      setStatus('closing');\n    }\n  }, [isOpen, animationElement, status]);\n\n  return {\n    status,\n    animationElementRef,\n    setAnimationElementRef: setAnimationRef\n  };\n}\n"],"names":["useState","useRef","useAnimation","useCallback","useEffect"],"mappings":";;;;;;;;;AAwCM,SAAU,kBAAkB,CAAwB,EACxD,MAAM,EACN,iBAAiB,EACjB,eAAe,EACf,eAAe,EACM,EAAA;AAgBrB,IAAA,MAAM,CAAC,MAAM,EAAE,SAAS,CAAC,GAAGA,cAAQ,CAAkB,MAAM,GAAG,SAAS,GAAG,WAAW,CAAC,CAAC;AACxF,IAAA,MAAM,mBAAmB,GAAGC,YAAM,CAAW,IAAI,CAAC,CAAC;IACnD,MAAM,CAAC,gBAAgB,EAAE,oBAAoB,CAAC,GAAGD,cAAQ,CAAW,IAAI,CAAC,CAAC;AAE1E,IAAA,MAAM,EAAE,OAAO,EAAE,GAAGE,yBAAY,CAA+B,MAAM,EAAE;QACrE,eAAe;AACf,QAAA,iBAAiB,EAAE,iBAAiB;AACpC,QAAA,cAAc,EAAEC,iBAAW,CAAiC,MAAK;YAC/D,IAAI,MAAM,KAAK,SAAS,EAAE;AACxB,gBAAA,eAAe,GAAG,IAAI,CAAC,CAAC;AACzB,aAAA;iBAAM,IAAI,CAAC,MAAM,EAAE;AAClB,gBAAA,MAAM,CAAC,MAAM,CAAC,gBAAiB,CAAC,KAAK,EAAE;AACrC,oBAAA,UAAU,EAAE,IAAI;AACjB,iBAAA,CAAC,CAAC;gBACH,SAAS,CAAC,WAAW,CAAC,CAAC;AACvB,gBAAA,eAAe,GAAG,KAAK,CAAC,CAAC;AAC1B,aAAA;SACF,EAAE,CAAC,MAAM,EAAE,MAAM,EAAE,eAAe,EAAE,gBAAgB,CAAC,CAAC;AACxD,KAAA,CAAC,CAAC;;;;;AAMH,IAAA,MAAM,eAAe,GAAGA,iBAAW,CACjC,CAAC,IAAc,KAAI;AACjB,QAAA,IAAI,mBAAmB,CAAC,OAAO,KAAK,IAAI,EAAE;AACxC,YAAA,mBAAmB,CAAC,OAAO,GAAG,IAAI,CAAC;;;;AAInC,YAAA,IAAI,IAAI,IAAI,IAAI,IAAI,MAAM,IAAI,SAAS,EAAE;AACvC,gBAAA,MAAM,CAAC,MAAM,CAAC,IAAI,CAAC,KAAK,EAAE;AACxB,oBAAA,UAAU,EAAE,QAAQ;AACrB,iBAAA,CAAC,CAAC;AACJ,aAAA;YACD,OAAO,CAAC,IAAI,CAAC,CAAC;YACd,oBAAoB,CAAC,IAAI,CAAC,CAAC;AAC5B,SAAA;AACH,KAAC,EACD,CAAC,MAAM,EAAE,OAAO,CAAC,CAClB,CAAC;IAEFC,eAAS,CAAC,MAAK;;AAEb,QAAA,IAAI,MAAM,KAAK,WAAW,IAAI,CAAC,MAAM,EAAE;YACrC,OAAO;AACR,SAAA;;;AAGD,QAAA,IAAI,MAAM,KAAK,WAAW,IAAI,MAAM,EAAE;YACpC,SAAS,CAAC,SAAS,CAAC,CAAC;YACrB,OAAO;AACR,SAAA;;;;AAKD,QAAA,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,EAAE;YAClC,SAAS,CAAC,SAAS,CAAC,CAAC;YACrB,OAAO;AACR,SAAA;;AAGD,QAAA,IAAI,MAAM,KAAK,SAAS,IAAI,MAAM,EAAE;AAClC,YAAA,MAAM,CAAC,MAAM,CAAC,gBAAiB,CAAC,KAAK,EAAE;AACrC,gBAAA,UAAU,EAAE,SAAS;AACtB,aAAA,CAAC,CAAC;YACH,OAAO;AACR,SAAA;;QAGD,IAAI,CAAC,MAAM,EAAE;YACX,SAAS,CAAC,SAAS,CAAC,CAAC;AACtB,SAAA;KACF,EAAE,CAAC,MAAM,EAAE,gBAAgB,EAAE,MAAM,CAAC,CAAC,CAAC;IAEvC,OAAO;QACL,MAAM;QACN,mBAAmB;AACnB,QAAA,sBAAsB,EAAE,eAAe;KACxC,CAAC;AACJ;;;;"}