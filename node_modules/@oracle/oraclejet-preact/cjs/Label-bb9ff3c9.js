/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks_UNSAFE_useFormFieldContext = require('./hooks/UNSAFE_useFormFieldContext.js');
require('./utils/UNSAFE_classNames.js');
var hooks_UNSAFE_useFormContext = require('./hooks/UNSAFE_useFormContext.js');
var hooks_UNSAFE_useComponentTheme = require('./hooks/UNSAFE_useComponentTheme.js');
var UNSAFE_UserAssistance = require('./UNSAFE_UserAssistance.js');
var UNSAFE_TextField_themes_redwood_TextFieldTheme = require('./UNSAFE_TextField/themes/redwood/TextFieldTheme.js');
var UNSAFE_Label_themes_redwood_LabelTheme = require('./UNSAFE_Label/themes/redwood/LabelTheme.js');
var classNames = require('./classNames-d619a292.js');

const StyledLabel = ({ hasValue, readonly, disabled, isFocused, isRequiredShown, helpIconId, helpSourceLink, helpSourceText, userAssistanceDensity = 'reflow', variant = 'inside', parentComponentVariant = 'textField', ...props }) => {
    const { isFormLayout, isReadonly: isReadonlyForm, labelWrapping } = hooks_UNSAFE_useFormContext.useFormContext();
    const isInside = variant === 'inside' || variant === 'insideError' || variant === 'insideWarning';
    const inTextField = parentComponentVariant === 'textField';
    // because variants have to match strings, we have to take any boolean props and convert
    // them to a string value, (ie prefixed with "is" or "non")
    const { classes, styles: { uaDensityCompactLabel, uaDensityCompactLabelStart, uaDensityCompactLabelTopInside } } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_Label_themes_redwood_LabelTheme.LabelRedwoodTheme, {
        labelWrapping,
        position: variant,
        inside: isInside ? 'isInside' : 'notInside',
        inEnabledForm: isFormLayout && !isReadonlyForm ? 'isInEnabledForm' : 'notInEnabledForm',
        readonly: readonly ? 'isReadonly' : 'notReadonly',
        focused: isFocused ? 'isFocused' : 'nonFocused',
        formLayout: isFormLayout ? 'isFormLayout' : 'nonFormLayout',
        readonlyForm: isReadonlyForm ? 'isReadonlyForm' : 'notReadonlyForm',
        value: hasValue ? 'hasValue' : 'noValue',
        valueOrFocus: hasValue || isFocused ? 'hasValueOrFocus' : 'noValueOrFocus',
        animatedWhenInside: inTextField ? 'isAnimated' : 'notAnimated',
        disabled: inTextField && disabled ? 'isDisabled' : 'nonDisabled',
        userAssistanceDensity
    });
    const { baseTheme: textFieldTheme } = hooks_UNSAFE_useComponentTheme.useComponentTheme(UNSAFE_TextField_themes_redwood_TextFieldTheme.TextFieldRedwoodTheme);
    // TODO: We need to decide whether to standardize on 'class' or 'className'.  Otherwise, we'll
    // run into issues destructuring style interpolations, for example having to concatenate both.
    const compactLabelStyles = classNames.classNames([
        uaDensityCompactLabel,
        variant === 'start' ? uaDensityCompactLabelStart : uaDensityCompactLabelTopInside
    ]);
    const compactUADLabel = jsxRuntime.jsx("label", { ...props, class: compactLabelStyles });
    return userAssistanceDensity === 'compact' ? (jsxRuntime.jsxs("div", { class: classNames.classNames([classes, textFieldTheme]), children: [variant !== 'start' && compactUADLabel, jsxRuntime.jsx(UNSAFE_UserAssistance.CompactLabelAssistance, { isRequiredShown: isRequiredShown, helpIconId: helpIconId, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, labelEdge: variant === 'top' || variant === 'start' ? variant : 'inside' }), variant === 'start' && compactUADLabel] })) : (jsxRuntime.jsx("label", { ...props, class: classNames.classNames([classes, textFieldTheme]) }));
};
const Label = ({ forId, ...props }) => {
    const { hasValue, isDisabled, isFocused, isReadonly } = hooks_UNSAFE_useFormFieldContext.useFormFieldContext();
    return (jsxRuntime.jsx(StyledLabel, { for: forId, hasValue: hasValue, disabled: isDisabled, isFocused: isFocused, readonly: isReadonly, ...props }));
};

exports.Label = Label;
//# sourceMappingURL=Label-bb9ff3c9.js.map
