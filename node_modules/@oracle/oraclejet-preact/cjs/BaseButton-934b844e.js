/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');
var hooks_UNSAFE_usePress = require('./hooks/UNSAFE_usePress.js');
var hooks_UNSAFE_useHover = require('./hooks/UNSAFE_useHover.js');
var hooks_UNSAFE_useActive = require('./hooks/UNSAFE_useActive.js');
require('./utils/UNSAFE_classNames.js');
var compat = require('preact/compat');

var utils_UNSAFE_interpolations_dimensions = require('./utils/UNSAFE_interpolations/dimensions.js');
var utils_UNSAFE_mergeInterpolations = require('./utils/UNSAFE_mergeInterpolations.js');
require('./utils/PRIVATE_clientHints.js');
var hooks_UNSAFE_useTabbableMode = require('./hooks/UNSAFE_useTabbableMode.js');
var utils_UNSAFE_mergeProps = require('./utils/UNSAFE_mergeProps.js');
var clientHints$1 = require('./clientHints-b9e7be1e.js');
var classNames = require('./classNames-d619a292.js');

const activeStyles = {
  backgroundImage: 'linear-gradient(var(--oj-c-PRIVATE-DO-NOT-USE-base-button-bg-overlay-active), var(--oj-c-PRIVATE-DO-NOT-USE-base-button-bg-overlay-active))',
  borderColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-base-button-border-color-active)',
  color: 'var(--oj-c-PRIVATE-DO-NOT-USE-base-button-text-color-active)'
};
const hoverStyles = {
  backgroundImage: 'linear-gradient(var(--oj-c-PRIVATE-DO-NOT-USE-base-button-bg-overlay-hover),var(--oj-c-PRIVATE-DO-NOT-USE-base-button-bg-overlay-hover))',
  borderColor: 'var(--oj-c-PRIVATE-DO-NOT-USE-base-button-border-color-hover)',
  color: 'var(--oj-c-PRIVATE-DO-NOT-USE-base-button-text-color-hover)'
};
const compStyles = {
  base: "dm6hqn",
  hover: "kgrszk",
  active: "n1wxnl",
  pseudohover: "_1mqvirp",
  pseudohoverSpan: "_1s421ht",
  unstyled: "_12grf24",
  min: "_1mzktz6",
  fill: "ttum7r",
  container: "_1r8anug",
  embedded: "_121deep",
  noBorderRadiusStart: "_3rrg2e",
  noBorderRadiusEnd: "csvgys",
  disabled: "_1ue1b6i",
  bottom: "_1p0u02i"
};
const childrenStyles = "_1001vmp";
const interpolations = [...Object.values(utils_UNSAFE_interpolations_dimensions.dimensionInterpolations)];
const styleInterpolations = utils_UNSAFE_mergeInterpolations.mergeInterpolations(interpolations);
const clientHints = clientHints$1.getClientHints();
// :active only works on IOS devices if a touch handler exists
const iosProps = clientHints.platform === 'ios' ? {
  ontouchstart: function () {}
} : {};
const isHybrid = clientHints$1.getClientHints().hoverSupport === 'events';
const roleProps = (elType, hidden) => {
  switch (elType) {
    case 'link':
      return {
        role: 'link'
      };
    case 'button':
      return {};
    default:
      return hidden ? {
        role: 'none'
      } : {
        role: 'button'
      };
  }
};
const BaseButton = compat.forwardRef(({
  variant = 'outlined',
  isDisabled = false,
  isRepeat = false,
  size = 'md',
  elementDetails = {
    type: 'button'
  },
  styling = ['default'],
  edge = 'none',
  'aria-label': accessibleLabel,
  'aria-hidden': ariaHidden,
  'aria-expanded': ariaExpanded,
  'aria-roledescription': ariaRoledescription,
  'aria-haspopup': ariaHasPopup,
  'aria-describedby': ariaDescribedBy,
  onBlur,
  onFocus,
  onMouseEnter,
  onMouseLeave,
  onTouchEnd,
  onTouchStart,
  ...props
}, ref) => {
  const pressHandler = e => {
    if (props.onAction) {
      props.onAction({
        reason: e.type == 'keyup' ? 'keyboard' : 'pointer'
      });
    }
  };
  const {
    pressProps
  } = hooks_UNSAFE_usePress.usePress(pressHandler, {
    isDisabled,
    isRepeat
  });
  const isStyled = name => {
    return styling.indexOf(name) > -1;
  };
  const {
    hoverProps,
    isHover
  } = hooks_UNSAFE_useHover.useHover({
    isDisabled: !isHybrid
  });
  const {
    activeProps,
    isActive
  } = hooks_UNSAFE_useActive.useActive();
  const {
    class: cls,
    ...styles
  } = styleInterpolations(props);
  const {
    type: elementType = 'button',
    ...elementProps
  } = {
    ...elementDetails
  };
  const role = roleProps(elementType, ariaHidden ?? false);
  const ElementType = elementDetails.type;
  const isSpan = ElementType == 'span';
  const isBaseButton = ElementType == 'button';
  const {
    isTabbable
  } = hooks_UNSAFE_useTabbableMode.useTabbableMode();
  const rootStyles = classNames.classNames([!isStyled('unstyled') && compStyles.base, isStyled('unstyled') && compStyles.unstyled, isStyled('embedded') && compStyles.embedded, isStyled('container') && compStyles.container, isStyled('noBorderRadiusStart') && compStyles.noBorderRadiusStart, isStyled('noBorderRadiusEnd') && compStyles.noBorderRadiusEnd, isStyled('active') && compStyles.active, isStyled('fill') && compStyles.fill, isStyled('min') && compStyles.min, `oj-c-base-button-${variant}`, `oj-c-base-button-${size}`, isDisabled && compStyles.disabled, edge === 'bottom' && compStyles.bottom, !isHybrid && !isSpan && !isActive && compStyles.pseudohover, !isHybrid && isSpan && !isActive && !isDisabled && !isStyled('container') && compStyles.pseudohoverSpan, isHybrid && isHover && !isActive && !isDisabled && !isStyled('container') && compStyles.hover, !isStyled('container') && isActive && !isDisabled && compStyles.active, childrenStyles]);
  const globalEventProps = {
    onBlur,
    onFocus,
    onMouseEnter,
    onMouseLeave,
    onTouchEnd,
    onTouchStart
  };
  const mergedProps = utils_UNSAFE_mergeProps.mergeProps(elementProps, pressProps, iosProps, hoverProps, isStyled('container') ? {} : activeProps, isBaseButton ? {} : {
    'aria-disabled': isDisabled
  }, globalEventProps);
  const wrapperClasses = classNames.classNames([cls, rootStyles]);
  return jsxRuntime.jsx(ElementType
  // The ref casting was done to satisfy TS compiler, when the forwardRef had to be updated to ForwardedRef.
  , {
    // The ref casting was done to satisfy TS compiler, when the forwardRef had to be updated to ForwardedRef.
    ref: ref,
    disabled: isDisabled,
    class: wrapperClasses,
    style: styles,
    autofocus: props['autofocus'],
    title: props.title,
    tabIndex: isDisabled || !isTabbable ? -1 : 0,
    "aria-label": accessibleLabel,
    "aria-haspopup": ariaHasPopup ? 'menu' : undefined,
    "aria-describedby": ariaDescribedBy,
    "aria-hidden": ariaHidden,
    "aria-roledescription": ariaRoledescription,
    "aria-expanded": ariaExpanded,
    ...mergedProps,
    ...role,
    children: props.children
  });
});

exports.BaseButton = BaseButton;
//# sourceMappingURL=BaseButton-934b844e.js.map
