/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

var jsxRuntime = require('preact/jsx-runtime');

var UNSAFE_Grid = require('./UNSAFE_Grid.js');
require('./utils/UNSAFE_classNames.js');
var classNames = require('./classNames-d619a292.js');
require('./UNSAFE_Text.js');
var hooks_UNSAFE_useTabbableMode = require('./hooks/UNSAFE_useTabbableMode.js');
var Text = require('./Text-4f1f698a.js');

const childrenStyles = "aum1n0";
// TODO: revisit idea of negative margin when selector has a proper API for handling spacing
// Jira: JET-54543
// negative margin added to selector
const selectorStyles = "_1ao9mn4";
// most content will be vertically centered
const centerVerticalStyles = "dprr4x";
// extra spacing is needed between meta, trailing, and action components
const leftPaddingStyles = "_1dkd4c6";
// the central text area displays overline, primary, secondary, and tertiary in a column
const flexColumnStyles$1 = "emn4j9";
// "extra" components in row 1 and the link in row 2 are justified on the righthand side of the list item layout
const flexRowStyles = "_7h83vg";
const rightJustifyStyles = "_19o6j82";
const rowAlignStyles = "_1rc1gid";
function ListItemLayout({
  children,
  selector,
  leading,
  primary,
  secondary,
  tertiary,
  overline,
  metadata,
  trailing,
  action,
  quaternary,
  navigation
}) {
  // generate grid skeleton, adding cells based on which props are defined
  const {
    columnsTemplate,
    firstCell,
    secondCell,
    lastCell,
    hasSecondRow
  } = getColumnsTemplate(selector, leading, metadata, trailing, action, quaternary, navigation);
  // if ListItemLayout component has a child (ListItemTextLayout) then render that instead of individual props
  const textArea = children ? jsxRuntime.jsx("div", {
    className: childrenStyles,
    children: children
  }) : jsxRuntime.jsxs("div", {
    className: flexColumnStyles$1,
    children: [jsxRuntime.jsx("div", {
      children: overline
    }), jsxRuntime.jsx("div", {
      children: primary
    }), jsxRuntime.jsx("div", {
      children: secondary
    }), jsxRuntime.jsx("div", {
      children: tertiary
    })]
  });
  // a second row is needed when quaternary or navigation are defined
  const secondRow = hasSecondRow ? [firstCell && jsxRuntime.jsx("span", {
    children: " "
  }), secondCell && jsxRuntime.jsx("span", {
    children: " "
  }), jsxRuntime.jsx("div", {
    className: rowAlignStyles,
    children: quaternary
  }), lastCell && jsxRuntime.jsx("div", {
    className: rightJustifyStyles,
    children: navigation
  })] : null;
  return jsxRuntime.jsxs(UNSAFE_Grid.Grid, {
    gap: "4x",
    gridTemplateColumns: columnsTemplate,
    children: [firstCell, secondCell, jsxRuntime.jsx("div", {
      className: centerVerticalStyles,
      children: textArea
    }), lastCell, secondRow]
  });
}
function getColumnsTemplate(selector, leading, metadata, trailing, action, quaternary, navigation) {
  const columnsTemplateBuilder = [];
  let firstCell = null;
  if (selector) {
    columnsTemplateBuilder.push('auto');
    firstCell = jsxRuntime.jsx("div", {
      className: selectorStyles,
      children: selector
    });
  }
  let secondCell = null;
  if (leading) {
    columnsTemplateBuilder.push('auto');
    secondCell = jsxRuntime.jsx("div", {
      className: centerVerticalStyles,
      children: leading
    });
  }
  columnsTemplateBuilder.push('1fr'); // Text area always gets 1 full fraction of allotted space
  let lastCell = null;
  if (metadata || trailing || action || navigation) {
    columnsTemplateBuilder.push('auto');
    lastCell = jsxRuntime.jsxs("div", {
      className: flexRowStyles,
      children: [jsxRuntime.jsx("div", {
        className: classNames.classNames([centerVerticalStyles, metadata ? leftPaddingStyles : '']),
        children: metadata
      }), jsxRuntime.jsx("div", {
        className: classNames.classNames([centerVerticalStyles, trailing ? leftPaddingStyles : '']),
        children: trailing
      }), jsxRuntime.jsx("div", {
        className: classNames.classNames([centerVerticalStyles, action ? leftPaddingStyles : '']),
        children: action
      })]
    });
  }
  const columnsTemplate = columnsTemplateBuilder.join(' ');
  const hasSecondRow = quaternary || navigation ? true : false;
  return {
    columnsTemplate,
    firstCell,
    secondCell,
    lastCell,
    hasSecondRow
  };
}

const textVariants = {
    primary: 'primary',
    secondary: 'primary',
    tertiary: 'secondary',
    quaternary: 'secondary',
    overline: 'secondary',
    metadata: 'secondary'
};
const textSizes = {
    primary: 'md',
    secondary: 'sm',
    tertiary: 'xs',
    quaternary: 'sm',
    overline: 'xs',
    metadata: 'sm'
};
const textLineClamps = {
    primary: undefined,
    secondary: 2,
    tertiary: 2,
    quaternary: 2,
    overline: 1,
    metadata: 1
};
function ListItemText({ children, variant }) {
    const { isTabbable } = hooks_UNSAFE_useTabbableMode.useTabbableMode();
    const textContent = (jsxRuntime.jsx(Text.Text, { variant: textVariants[variant], size: textSizes[variant], lineClamp: textLineClamps[variant], children: children }));
    return isTabbable ? jsxRuntime.jsx("div", { tabIndex: 0, children: textContent }) : textContent;
}

const flexColumnStyles = "_18rdkei";
function ListItemTextLayout({
  primary,
  secondary,
  tertiary,
  overline
}) {
  return jsxRuntime.jsxs("div", {
    className: flexColumnStyles,
    children: [jsxRuntime.jsx(ListItemText, {
      variant: "overline",
      children: overline
    }), jsxRuntime.jsx(ListItemText, {
      variant: "primary",
      children: primary
    }), jsxRuntime.jsx(ListItemText, {
      variant: "secondary",
      children: secondary
    }), jsxRuntime.jsx(ListItemText, {
      variant: "tertiary",
      children: tertiary
    })]
  });
}

exports.ListItemLayout = ListItemLayout;
exports.ListItemText = ListItemText;
exports.ListItemTextLayout = ListItemTextLayout;
//# sourceMappingURL=ListItemTextLayout-a41ac4a2.js.map
