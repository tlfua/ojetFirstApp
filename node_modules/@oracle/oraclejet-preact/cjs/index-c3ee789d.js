/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

var preact = require('preact');
require('./Common.js');
var Common_themes_redwood_theme = require('./Common/themes/redwood/theme.js');
var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
var compat = require('preact/compat');

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Default environment created for the application
 */
const DefaultEnvironment = {
    user: {
        locale: document.documentElement.getAttribute('lang') || 'en',
        direction: document.documentElement.getAttribute('dir')?.toLowerCase() === 'rtl' ? 'rtl' : 'ltr',
        forcedColors: window.matchMedia?.('(forced-colors: active)')?.matches ? 'active' : 'none'
    },
    theme: Common_themes_redwood_theme.Redwood,
    colorScheme: 'light',
    scale: 'lg',
    currentBgColor: undefined
};
const EnvironmentContext = preact.createContext(DefaultEnvironment);

const LayerContext = preact.createContext({});

const LayerHost = compat.forwardRef((_props, ref) => {
    return jsxRuntime.jsx("div", { id: "__oj_layerhost_container", ref: ref });
});
LayerHost.displayName = 'Forwarded<LayerHost>';

function LayerManager({ children }) {
    const [defaultHost, setDefaultHost] = compat.useState();
    //const context = useContext(LayerContext);
    const defaultHostRef = compat.useCallback((el) => {
        // ref callbacks fire after the component has been unnmounted so we do not
        // want to set state in this use-case
        if (el !== null) {
            setDefaultHost(el);
        }
    }, []);
    return (jsxRuntime.jsx(LayerContext.Consumer, { children: (value) => {
            const defaultHostContext = defaultHost ? { getHost: () => defaultHost } : {};
            const layerContext = value.getHost ? value : defaultHostContext;
            return (jsxRuntime.jsxs(LayerContext.Provider, { value: layerContext, children: [children, !value.getHost && jsxRuntime.jsx(LayerHost, { ref: defaultHostRef })] }));
        } }));
}

// Custom merge function
function mergeEnvironment(env1, env2) {
    const userValue = Object.assign({}, env1.user, env2?.user);
    const themeValue = Object.assign({}, env1.theme, env2?.theme);
    // Merge translation values - one level merge
    const targetTranslations = Object.assign({}, env1.translations);
    const sourceTranslations = env2?.translations || {};
    Object.keys(sourceTranslations).forEach((key) => {
        let newVal = sourceTranslations[key];
        if (targetTranslations[key]) {
            // merge is needed
            newVal = Object.assign({}, targetTranslations[key], newVal);
        }
        targetTranslations[key] = newVal;
    });
    return {
        user: userValue,
        theme: themeValue,
        translations: targetTranslations,
        colorScheme: env2?.colorScheme ?? env1.colorScheme,
        scale: env2?.scale ?? env1.scale,
        currentBgColor: env2?.currentBgColor ?? env1.currentBgColor
    };
}
/**
 * The RootEnvironmentProvider component bootstraps essential services and
 * must be placed at the root of any application using components from '@oracle/oraclejet-preact'.
 * Minimally, the application must load the appropriate translation bundle for the user's locale
 * and set it on the RootEnvironmentProvider.
 */
function RootEnvironmentProvider({ children, environment }) {
    const mergedEnvironment = hooks.useMemo(() => mergeEnvironment(DefaultEnvironment, environment), [environment]);
    return (jsxRuntime.jsx(EnvironmentContext.Provider, { value: mergedEnvironment, children: jsxRuntime.jsx(LayerManager, { children: children }) }));
}
/**
 * The EnvironmentProvider is a component that should be used by the application when there is a need to overwrite
 * environment values for a subtree.
 * The component receives an Environment object that will be merged into the values provided by the nearest ancestor Provider.
 * The new environment will be passed to the component's children.
 * Note that some environment values cannot be overwritten. See the description of the Environment type for the list of values
 * that can be replaced.
 */
function EnvironmentProvider({ children, environment }) {
    const consumerEnv = hooks.useContext(EnvironmentContext);
    const mergedEnvironment = hooks.useMemo(() => mergeEnvironment(consumerEnv, environment), [consumerEnv, environment]);
    return (jsxRuntime.jsx(EnvironmentContext.Provider, { value: mergedEnvironment, children: children }));
}

exports.DefaultEnvironment = DefaultEnvironment;
exports.EnvironmentContext = EnvironmentContext;
exports.EnvironmentProvider = EnvironmentProvider;
exports.LayerContext = LayerContext;
exports.LayerManager = LayerManager;
exports.RootEnvironmentProvider = RootEnvironmentProvider;
//# sourceMappingURL=index-c3ee789d.js.map
