/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var jsxRuntime = require('preact/jsx-runtime');
var hooks = require('preact/hooks');
require('./utils/UNSAFE_classNames.js');
var UNSAFE_SvgShapes = require('./UNSAFE_SvgShapes.js');
var UNSAFE_Legend_themes_LegendStyles_css = require('./UNSAFE_Legend/themes/LegendStyles.css.js');
require('./UNSAFE_Text.js');
var classNames = require('./classNames-d619a292.js');
var Text = require('./Text-4f1f698a.js');
var compat = require('preact/compat');
var hooks_UNSAFE_useUser = require('./hooks/UNSAFE_useUser.js');
var utils_UNSAFE_mergeProps = require('./utils/UNSAFE_mergeProps.js');
var hooks_UNSAFE_useTooltip = require('./hooks/UNSAFE_useTooltip.js');
require('./UNSAFE_Flex.js');
var Flex = require('./Flex-2eb09dad.js');
require('./UNSAFE_SvgShapes/themes/SvgShapesStyles.css.js');


require('./utils/UNSAFE_mergeInterpolations.js');
require('./_curry1-6e9511bf.js');
require('./_curry3-ad2313fd.js');
require('./_curry2-53a902bf.js');
require('./_has-aa203696.js');
require('./UNSAFE_Text/themes/TextStyles.css.js');

require('./vanilla-extract-recipes-createRuntimeFn.esm-8a4b93e4.js');
require('./index-c3ee789d.js');
require('preact');
require('./Common.js');
require('./Common/themes.js');
require('./Common/themes/redwood/theme.js');
require('./Common/themes/themeContract.css.js');
require('./hooks/UNSAFE_useId.js');
require('./UNSAFE_Floating.js');
require('./Floating-3415cf36.js');
require('./index-0a166c9e.js');
require('./utils/PRIVATE_floatingUtils.js');
require('./utils/PRIVATE_refUtils.js');
require('./hooks/UNSAFE_useOutsideClick.js');
require('./utils/UNSAFE_arrayUtils.js');
require('./hooks/UNSAFE_useComponentTheme.js');
require('./utils/UNSAFE_logger.js');
require('./utils-b9f57550.js');
require('./UNSAFE_Floating/themes/redwood/FloatingTheme.js');
require('./UNSAFE_Floating/themes/FloatingStyles.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js');

require('./UNSAFE_Floating/themes/redwood/FloatingVariants.css.js');
require('./vanilla-extract-dynamic.esm-4bc33829.js');
require('./UNSAFE_Floating/themes/FloatingContract.css.js');
require('./UNSAFE_Layer.js');
require('./useThemeInterpolations-ee4e7934.js');
require('./hooks/UNSAFE_useColorScheme.js');
require('./hooks/UNSAFE_useScale.js');
require('./utils/UNSAFE_interpolations/theme.js');
require('./UNSAFE_Theme.js');
require('./hooks/UNSAFE_useHover.js');
require('./hooks/UNSAFE_useToggle.js');
require('./hooks/UNSAFE_useFocus.js');
require('./hooks/UNSAFE_useTouch.js');
require('./hooks/UNSAFE_useAnimation.js');
require('./useAnimation-802f3cdb.js');
require('./hooks/UNSAFE_useThemeInterpolations.js');
require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js');
require('./hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js');

require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js');

require('./hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js');

require('./utils/UNSAFE_interpolations/dimensions.js');
require('./utils/UNSAFE_size.js');

require('./utils/UNSAFE_interpolations/boxalignment.js');
require('./keys-65201aa4.js');
require('./utils/UNSAFE_interpolations/flexbox.js');
require('./flexbox-8cd3009d.js');
require('./utils/UNSAFE_interpolations/flexitem.js');
require('./flexitem-939ec1ef.js');

function ImageMarker(props) {
    const { imageMarkerStyle } = UNSAFE_Legend_themes_LegendStyles_css.styles;
    return jsxRuntime.jsx("img", { class: imageMarkerStyle, src: props.source });
}

const LegendSymbol = ({ 
// The default color is not in the redwood pallete.
// TODO: replace default legend color with UX approved pallete color when available.
markerColor = '#a6acb1', lineColor = '#a6acb1', markerShape = 'square', isHidden = false, lineStyle = 'none', ...props }) => {
    const { legendSymbolBaseStyle } = UNSAFE_Legend_themes_LegendStyles_css.styles;
    const dimensionsNotSet = props.width == null && props.height == null;
    const setAspectRatioNone = !dimensionsNotSet && (markerShape === 'rectangle' || markerShape === 'ellipse');
    const defaultLineWidth = lineStyle != 'none' && markerShape != 'none' ? 2 : 3;
    return (jsxRuntime.jsx("div", { className: legendSymbolBaseStyle, style: { width: props.width, height: props.height }, children: props.source ? (jsxRuntime.jsx(ImageMarker, { source: props.source })) : (jsxRuntime.jsx(UNSAFE_SvgShapes.SvgSymbol, { setAspectRatioNone: setAspectRatioNone, markerShape: isHidden ? 'square' : markerShape, lineStyle: isHidden ? 'none' : lineStyle, lineColor: lineColor, lineLength: props.lineLength, lineWidth: props.lineWidth != null ? props.lineWidth : defaultLineWidth, markerColor: isHidden ? 'transparent' : markerColor, borderColor: isHidden ? markerColor || lineColor : props.borderColor })) }));
};

/**
 * Returns the legend text component.
 */
const LegendText = ({ text, type = 'label', id, align = 'start', ...props }) => {
    const { legendTextBaseStyle, legendTextTitle, legendTitleStartAlign, legendTitleCenterAlign, legendTitleEndAlign } = UNSAFE_Legend_themes_LegendStyles_css.styles;
    const isTitle = type === 'title';
    return (jsxRuntime.jsx("div", { class: classNames.classNames([
            legendTextBaseStyle,
            isTitle ? legendTextTitle : '',
            isTitle && align === 'start' ? legendTitleStartAlign : '',
            isTitle && align === 'center' ? legendTitleCenterAlign : '',
            isTitle && align === 'end' ? legendTitleEndAlign : ''
        ]), style: {
            ...props
        }, children: jsxRuntime.jsx(Text.Text, { size: "inherit", variant: "inherit", weight: "inherit", truncation: 'ellipsis', id: id, children: text }) }));
};

const BaseLegendItem = compat.forwardRef(({ id, text, sectionIdx, itemIdx, isHighlighted, symbolHeight, symbolWidth, isFocused, isCurrent, isHidden, ...props }, ref) => {
    const textStyles = {
        fontFamily: props.textFontFamily,
        fontSize: props.textFontSize,
        color: props.textColor,
        fontStyle: props.textFontStyle,
        fontWeight: props.textFontWeight,
        textDecoration: props.textTextDecoration
    };
    const symbolProps = {
        lineStyle: props.lineStyle,
        lineWidth: props.lineWidth,
        markerShape: props.markerShape,
        markerColor: props.markerColor,
        source: props.source,
        borderColor: props.borderColor,
        lineColor: props.lineColor
    };
    const isNotDimmed = isHighlighted || isHighlighted == null;
    const { legendItemBaseStyle, legendItemIsCurrent, legendItemOpacity, legendItemFocusRing } = UNSAFE_Legend_themes_LegendStyles_css.styles;
    return (jsxRuntime.jsxs("div", { class: classNames.classNames([
            legendItemBaseStyle,
            isCurrent && isHighlighted == null ? legendItemIsCurrent : '',
            !isNotDimmed ? legendItemOpacity : '',
            isFocused ? legendItemFocusRing : '',
            props.class
        ]), style: {
            gridRow: props.gridRow,
            gridColumn: props.gridCol,
            minWidth: props.minWidth !== undefined ? `${props.minWidth}px` : undefined
        }, id: id, ref: ref, "data-oj-section": sectionIdx, "data-oj-item": itemIdx, "aria-labelledby": props.labelledBy, role: isHidden != null ? 'menuitemcheckbox' : 'img', "aria-checked": isHidden != null ? !isHidden : undefined, "aria-label": props['aria-label'] || text, children: [jsxRuntime.jsx(LegendSymbol, { ...symbolProps, isHidden: isHidden, lineLength: symbolWidth, width: symbolWidth != null ? `${symbolWidth}px` : undefined, height: symbolHeight != null ? `${symbolHeight}px` : undefined }), jsxRuntime.jsx(LegendText, { ...textStyles, text: text, type: "label" })] }));
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the value of the data-oj-item-index attribute for a given element.
 * @param element The HTML element.
 * @returns
 */
const getItemInfo = (element) => {
    const item = element.dataset['ojItem'];
    const section = element.dataset['ojSection'];
    if (item == null || section == null) {
        return;
    }
    return {
        itemIdx: Number(item),
        sectionIdx: Number(section)
    };
};
/**
 * Checks if the item is highlighted.
 * @param id Id of the item
 * @param highlighted The set of highlighted item
 */
function isItemHighlighted(id, highlighted) {
    if (!highlighted) {
        return;
    }
    if (highlighted.length === 0) {
        return true;
    }
    return new Set(highlighted).has(id);
}
/**
 * Checks if the item is hidden.
 * @param id Id of the item.
 * @param hiddenIds The set of hidden items.
 * @returns
 */
function isItemHidden(id, hiddenIds) {
    if (!hiddenIds) {
        return;
    }
    return new Set(hiddenIds).has(id);
}
/**
 * Checks if the item is the currentItem and if the focus ring
 * is visible.
 * @param itemInfo ItemInfo
 * @param itemIdx Item index
 * @param sectionIdx Section index
 */
const hasFocusRing = (itemInfo, itemIdx, sectionIdx) => {
    if (!itemInfo.isFocusVisible)
        return false;
    const { itemIdx: item, sectionIdx: section } = itemInfo;
    if (sectionIdx == null) {
        return item === itemIdx;
    }
    return item === itemIdx && section === sectionIdx;
};
/**
 * Returns the text for the legend datatip.
 * @param items The legend items data.
 * @param itemInfoRef The item currently hovered.
 * @param currentItem The item that is currently keyboard focused.
 */
function getDatatipText(items, getItem, focusedItem, hoveredItem) {
    const isPointerActive = hoveredItem?.isCurrent;
    if (isPointerActive && hoveredItem.itemIdx != null) {
        return getItem(hoveredItem, items)?.datatip;
    }
    if (focusedItem && focusedItem.isCurrent) {
        return getItem(focusedItem, items)?.datatip;
    }
    return;
}
/**
 * Returns the aria properties for the legend.
 * @param isReadOnly { boolean } If the legend is readonly.
 * @param ariaLabel { string } The aria-label set by the app.
 * @returns The aria props.
 */
function getAriaProps(isReadOnly, ariaLabel, hiddenIds) {
    const hideAndShow = hiddenIds && !isReadOnly;
    return {
        'aria-label': ariaLabel,
        'aria-disabled': isReadOnly,
        role: hideAndShow ? 'menu' : 'application'
    };
}
/**
 * Gererates randomId used for aria-activedescendant.
 * @returns
 */
function getRandomId() {
    return `_${Math.random().toString(36).slice(2)}`; //@RandomNumberOK
}
/**
 * Returns the item props for BaseLegendItem.
 * @param item The legend item.
 * @param itemIdx The item index of the item.
 * @param sectionIdx The section index of section of the item.
 * @param focusedItem The info of currently focused item.
 * @param isReadOnly Whether the legend is readonly.
 * @param hoveredItem The info of the currently hovered item.
 * @param hiddenIds The hidden ids.
 * @param highlightedIds The highlighted ids.
 */
function getItemProps(item, itemIdx, sectionIdx, focusedItem, isReadOnly, hoveredItem, hiddenIds, highlightedIds) {
    let isCurrent = false;
    if (!isReadOnly) {
        const isFocusedItem = itemIdx === focusedItem.itemIdx && sectionIdx === focusedItem.sectionIdx;
        const isHoveredItem = itemIdx === hoveredItem?.itemIdx && sectionIdx === hoveredItem?.sectionIdx;
        isCurrent = !!((isFocusedItem && focusedItem.isCurrent) ||
            (isHoveredItem && hoveredItem?.isCurrent));
    }
    return {
        isCurrent,
        isHighlighted: isItemHighlighted(item.id, highlightedIds),
        isHidden: isItemHidden(item.id, hiddenIds),
        isFocused: hasFocusRing(focusedItem, itemIdx, sectionIdx),
        key: item.id,
        ...item
    };
}
/**
 * Compares if two ItemInfo are equal
 * @param item1
 * @param item2
 * @returns
 */
const isEqualItem = (item1, item2) => {
    return item1?.itemIdx === item2?.itemIdx && item1?.sectionIdx === item2?.sectionIdx;
};
/**
 * Returns the num of cols and rows for the legend.
 */
const getGridNums = (numItems, layoutInfo) => {
    let itemsPerRow;
    let itemsPerCol;
    if (layoutInfo?.isWrapped) {
        itemsPerRow = layoutInfo.itemsPerRow;
        itemsPerCol = Math.ceil(numItems / itemsPerRow);
        itemsPerRow = Math.ceil(numItems / itemsPerCol);
    }
    return { itemsPerRow, itemsPerCol };
};
/**
 * Returns the grid row and column for given item.
 * @param noOfItems The number of items in the section.
 * @param index The index of the item.
 * @param itemsPerRow The num of items per row in the grid.
 * @param itemsPerCol The num of items per col in the grid.
 * @returns
 */
function getGridCellIndices(noOfItems, index, itemsPerRow, itemsPerCol) {
    let gridRow;
    let gridCol;
    if (itemsPerRow && itemsPerCol && noOfItems > itemsPerRow) {
        gridRow = (index % itemsPerCol) + 1;
        gridCol = Math.floor(index / itemsPerCol) + 1;
    }
    return { gridRow, gridCol };
}

/**
 * The controlled legend reponsible only for rendering the legend items.
 */
const BaseLegend = ({ orientation = 'horizontal', highlightedIds, hiddenIds, focusedItemInfo, hoveredItemInfo, sectionIdx, activeId, isReadOnly, items, symbolHeight, symbolWidth, ...props }) => {
    const isHoriz = orientation === 'horizontal';
    const isColumnDefined = props.isColumnWidthValidRef.current;
    const columTemplates = isColumnDefined && isHoriz ? `repeat(${props.itemsPerRow}, ${props.itemWidth})` : undefined;
    props.isColumnWidthValidRef.current = false;
    const { baseLegendStyles, baseLegendHorizontal, baseLegendVertical, baseLegendVerticalItem, baseLegendPaddingBottom, baseLegendPaddingTop, baseLegendPaddingEnd } = UNSAFE_Legend_themes_LegendStyles_css.styles;
    return (jsxRuntime.jsx("div", { className: classNames.classNames([
            baseLegendStyles,
            isHoriz ? baseLegendHorizontal : baseLegendVertical
        ]), style: {
            gridTemplateColumns: columTemplates,
            // set maxWidth to 100% on second render for text truncation to work.
            maxWidth: isColumnDefined ? '100%' : ''
        }, children: items.map((item, index) => {
            const itemProps = getItemProps(item, index, sectionIdx, focusedItemInfo, isReadOnly, hoveredItemInfo, hiddenIds, highlightedIds);
            const isFocusedItem = focusedItemInfo.sectionIdx === sectionIdx && focusedItemInfo.itemIdx === index;
            const { gridRow, gridCol } = getGridCellIndices(items.length, index, props.itemsPerRow, props.itemsPerCol);
            const needsBottomSpace = gridRow != null && gridRow != props.itemsPerCol;
            const needsTopSpace = gridRow != null && gridRow != 1;
            return (jsxRuntime.jsx(BaseLegendItem, { ref: isFocusedItem ? props.focusedItemRef : undefined, itemIdx: index, sectionIdx: sectionIdx, symbolHeight: symbolHeight, symbolWidth: symbolWidth, ...props, ...itemProps, gridRow: gridRow, gridCol: gridCol, minWidth: props.itemWidth, id: itemProps.isCurrent ? activeId : '', class: classNames.classNames([
                    isHoriz ? '' : baseLegendVerticalItem,
                    needsTopSpace ? baseLegendPaddingTop : '',
                    needsBottomSpace ? baseLegendPaddingBottom : '',
                    baseLegendPaddingEnd
                ]) }));
        }) }));
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function useEvents(isInteractive, isHideShow, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onInput) {
    const [focusedItemInfo, setfocusedItemInfo] = hooks.useState({
        itemIdx: 0,
        sectionIdx: 0
    });
    const [hoveredItemInfo, sethoveredItemInfo] = hooks.useState();
    const activeId = hooks.useRef();
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const isRtl = direction === 'rtl';
    const cancelEvent = (event) => {
        event.preventDefault();
        event.stopPropagation();
    };
    const hoverHandler = (event) => {
        const itemInfo = getItemInfo(event.target);
        if (!isEqualItem(itemInfo, hoveredItemInfo)) {
            sethoveredItemInfo(itemInfo && { ...itemInfo, isCurrent: true });
            activeId.current = getRandomId();
            if (isInteractive) {
                focusedItemInfo ? setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false }) : '';
                onInput?.(getDetailFromInfo(itemInfo));
            }
        }
    };
    const pointerLeaveHandler = () => {
        sethoveredItemInfo(undefined);
        activeId.current = undefined;
        if (isInteractive) {
            onInput?.(getDetailFromInfo());
        }
    };
    if (!isInteractive) {
        return {
            focusedItemInfo,
            hoveredItemInfo,
            // include pointer leave and pointer move for datatip
            onPointerLeave: pointerLeaveHandler,
            onPointerMove: hoverHandler
        };
    }
    const updatefocusedItemInfo = (itemInfo) => {
        onInput?.(getDetailFromInfo(itemInfo));
        activeId.current = getRandomId();
        setfocusedItemInfo(itemInfo);
    };
    const handleKeyboardInput = (item) => {
        if (!isEqualItem(item, focusedItemInfo)) {
            item.isCurrent = true;
            item.isFocusVisible = true;
            if (hoveredItemInfo) {
                sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });
            }
            updatefocusedItemInfo(item);
        }
    };
    const triggerOnAction = () => {
        const { sectionId, itemId } = getDetailFromInfo(focusedItemInfo);
        if (itemId != null) {
            onItemAction?.({ sectionId, itemId });
            activeId.current = getRandomId();
        }
    };
    const pointerUpHandler = (event) => {
        const itemInfo = getItemInfo(event.target);
        if (itemInfo != null) {
            setfocusedItemInfo(itemInfo);
            const { sectionId, itemId } = getDetailFromInfo(itemInfo);
            if (itemId != null) {
                onItemAction?.({ sectionId, itemId });
                activeId.current = getRandomId();
            }
        }
    };
    const keyDownHandler = (event) => {
        const key = event.key;
        switch (key) {
            case 'Tab':
                return;
            case 'ArrowDown': {
                const nextItemInfo = getNextItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                break;
            }
            case 'ArrowUp': {
                const nextItemInfo = getPrevItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                break;
            }
            case 'ArrowRight': {
                const nextItemInfo = isRtl
                    ? getPrevItemInfo(focusedItemInfo)
                    : getNextItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                break;
            }
            case 'ArrowLeft': {
                const nextItemInfo = isRtl
                    ? getNextItemInfo(focusedItemInfo)
                    : getPrevItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                break;
            }
        }
        cancelEvent(event);
    };
    const keyUpHandler = (event) => {
        const key = event.code;
        switch (key) {
            case 'Space': {
                if (isHideShow) {
                    triggerOnAction();
                }
                break;
            }
            case 'Enter': {
                triggerOnAction();
                break;
            }
            case 'Home': {
                updatefocusedItemInfo({
                    itemIdx: 0,
                    sectionIdx: 0,
                    isFocusVisible: true,
                    isCurrent: true
                });
                break;
            }
            case 'End': {
                updatefocusedItemInfo({
                    itemIdx: -1,
                    sectionIdx: -1,
                    isCurrent: true,
                    isFocusVisible: true
                });
                break;
            }
            case 'Tab': {
                updatefocusedItemInfo({
                    ...focusedItemInfo,
                    isCurrent: true,
                    isFocusVisible: true
                });
                break;
            }
        }
    };
    const blurHandler = () => {
        const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };
        if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {
            onInput?.(getDetailFromInfo(undefined));
        }
        setfocusedItemInfo(itemInfo);
    };
    return {
        focusedItemInfo,
        hoveredItemInfo,
        'aria-activedescendant': activeId.current,
        onPointerUp: pointerUpHandler,
        onPointerMove: hoverHandler,
        onKeyUp: keyUpHandler,
        onKeyDown: keyDownHandler,
        onPointerLeave: pointerLeaveHandler,
        onBlur: blurHandler
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getItem$1(itemInfo, items) {
    const { itemIdx } = itemInfo;
    if (itemIdx == -1) {
        return items[items.length - 1];
    }
    return items[itemIdx];
}
function getNextItemInfo$1(itemInfo, items) {
    let itemIdx = itemInfo.itemIdx;
    if (itemInfo.itemIdx == -1) {
        itemIdx = items.length - 1;
    }
    itemIdx = Math.min(items.length - 1, itemIdx + 1);
    return { sectionIdx: 0, itemIdx };
}
function getPrevItemInfo$1(itemInfo, items) {
    let itemIdx = itemInfo.itemIdx;
    if (itemInfo.itemIdx == -1) {
        itemIdx = items.length - 1;
    }
    itemIdx = Math.max(0, itemIdx - 1);
    return { sectionIdx: 0, itemIdx };
}
/**
 * Returns utils functions for navigation in simple legend.
 * @param items
 * @returns
 */
function getLegendNavUtils(items) {
    return {
        getItem: (itemInfo) => {
            return getItem$1(itemInfo, items);
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo) {
                return { itemId: undefined };
            }
            const item = getItem$1(itemInfo, items);
            return { itemId: item.id };
        },
        getPrevItemInfo: (itemInfo) => {
            return getPrevItemInfo$1(itemInfo, items);
        },
        getNextItemInfo: (itemInfo) => {
            return getNextItemInfo$1(itemInfo, items);
        }
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const DEFAULT_OFFSET = 8;
/**
 * Calculate the datatip offset for datatip when keyboard focus is active.
 * @param focusedItemRef The ref for currentItem node.
 * @param rootRef The ref for root of the legend.
 * @param currentItem The ItemInfo of the current keyboard focused item.
 * @returns
 */
const calculateOffset = (focusedItemRef, rootDimsRef, currentItem, isRtl) => {
    let crossAxis = 0;
    let mainAxisOffset = DEFAULT_OFFSET;
    if (focusedItemRef.current && currentItem.isCurrent && rootDimsRef.current) {
        const rootDim = rootDimsRef.current;
        const itemDim = focusedItemRef.current.getBoundingClientRect();
        crossAxis = itemDim.x + itemDim.width / 2 - (rootDim.x + rootDim.width / 2);
        crossAxis = isRtl ? -1 * crossAxis : crossAxis;
        mainAxisOffset += rootDim.y - itemDim.y;
        mainAxisOffset = Math.min(DEFAULT_OFFSET, Math.max(mainAxisOffset, itemDim.height - rootDim.height + DEFAULT_OFFSET));
    }
    return { crossAxis, mainAxis: mainAxisOffset };
};
const useLegendTooltip = ({ text, rootDimsRef, focusedItemRef, focusedItemInfo }) => {
    const { direction } = hooks_UNSAFE_useUser.useUser();
    const isRtl = direction === 'rtl';
    const [offset, setOffset] = hooks.useState(calculateOffset(focusedItemRef, rootDimsRef, focusedItemInfo, isRtl));
    const [isOpen, setIsOpen] = hooks.useState(false);
    hooks.useLayoutEffect(() => {
        setOffset(calculateOffset(focusedItemRef, rootDimsRef, focusedItemInfo, isRtl));
    }, [focusedItemInfo]);
    const anchor = focusedItemInfo?.isCurrent ? 'element' : 'pointer';
    const { tooltipContent, tooltipProps } = hooks_UNSAFE_useTooltip.useTooltipControlled({
        text: text,
        position: 'top',
        isDisabled: false,
        variant: 'datatip',
        anchor: { x: anchor, y: anchor },
        offset: offset,
        isOpen,
        onToggle: ({ value }) => setIsOpen(value)
    });
    return { tooltipContent, tooltipProps };
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook to track focus item ref and ensure focus item is always
 * in view.
 */
function useItemFocus(focusedItem) {
    const focusedItemRef = hooks.useRef(null);
    hooks.useEffect(() => {
        if (focusedItem.isFocusVisible) {
            focusedItemRef.current?.scrollIntoView({
                behavior: 'smooth',
                block: 'nearest',
                inline: 'nearest'
            });
        }
    }, [focusedItem]);
    return { focusedItemRef };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Checks if two layout infos are equal.
 */
const areEqualLayoutInfo = function (info1, info2) {
    return (info1.length === info2.length &&
        info1.every((value, index) => value.isWrapped === info2[index].isWrapped &&
            value.maxItemWidth === info2[index].maxItemWidth &&
            info1[index].itemsPerRow === info2[index].itemsPerRow));
};
/**
 * Returns maximum of the width among the items section of legend.
 * @param legend BaseLegend element
 * @returns
 */
const getMaxWidth = (baseLegend) => {
    let maxItemWidth = 0;
    [...baseLegend.children].forEach((e) => {
        const item = e;
        maxItemWidth = Math.max(maxItemWidth, Math.ceil(item.getBoundingClientRect().width));
    });
    return maxItemWidth;
};
function useLegendLayout({ items, rootRef, rootDimsRef, isSectional = false, orientation }) {
    const [layoutInfo, setLayoutInfo] = hooks.useState([]);
    const isColumnWidthValidRef = hooks.useRef(false);
    const previousOrientationRef = hooks.useRef(orientation);
    hooks.useLayoutEffect(() => {
        if (!rootRef.current) {
            return;
        }
        // recalculate rootDims everytime items change.
        rootDimsRef.current = rootRef.current.getBoundingClientRect();
        previousOrientationRef.current = orientation;
        const legendLayoutInfo = [];
        const rootElement = isSectional ? rootRef.current.children[0] : rootRef.current;
        [...rootElement.children].forEach((section) => {
            const sectionWidth = section.getBoundingClientRect().width;
            const baseLegend = isSectional ? section.children[section.childElementCount - 1] : section;
            let isWrapped = sectionWidth > rootDimsRef.current?.width;
            if (baseLegend.childElementCount > 0 && sectionWidth === rootDimsRef.current?.width) {
                // If text is trucated, sectionwidth and rootWidth are equal but legend section could still be wrapped.
                // compare offsetTop with last item to determine wrapping. For sectional legend, check the section div (title + baselegend)
                // offsetTop with the offsetTop of the last element to determine if they are not in the same level (i.e wrapped)
                isWrapped =
                    (!isSectional &&
                        baseLegend.children[baseLegend.childElementCount - 1].offsetTop >
                            baseLegend.children[0].offsetTop) ||
                        (isSectional &&
                            baseLegend.children[baseLegend.childElementCount - 1].offsetTop >
                                section.offsetTop);
            }
            const maxItemWidth = getMaxWidth(baseLegend);
            legendLayoutInfo.push({
                maxItemWidth: Math.min(maxItemWidth, rootDimsRef.current?.width),
                itemsPerRow: Math.max(1, Math.floor(rootDimsRef.current?.width / maxItemWidth)),
                isWrapped
            });
        });
        if (!areEqualLayoutInfo(layoutInfo, legendLayoutInfo)) {
            isColumnWidthValidRef.current = true;
            setLayoutInfo(legendLayoutInfo);
        }
    }, [items, orientation]);
    return {
        layoutInfo: previousOrientationRef.current != orientation ? [] : layoutInfo,
        isColumnWidthValidRef
    };
}

/**
 * A legend displays an interactive description of symbols, colors, etc., used in graphical information representations.
 */
function Legend({ orientation = 'horizontal', items, isReadOnly = true, onItemAction, onInput, ...props }) {
    const rootRef = hooks.useRef(null);
    const rootDimsRef = hooks.useRef();
    const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getLegendNavUtils(items);
    const { layoutInfo, isColumnWidthValidRef } = useLegendLayout({
        rootRef,
        rootDimsRef,
        items,
        orientation
    });
    const { hoveredItemInfo, focusedItemInfo, ...eventsProps } = useEvents(!isReadOnly, props.hiddenIds != null, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onInput);
    const { focusedItemRef } = useItemFocus(focusedItemInfo);
    const datatipText = getDatatipText(items, getItem, focusedItemInfo, hoveredItemInfo);
    const { tooltipContent, tooltipProps } = useLegendTooltip({
        text: datatipText,
        rootDimsRef,
        focusedItemInfo,
        focusedItemRef
    });
    const ariaProps = getAriaProps(isReadOnly, props['aria-label'], props.hiddenIds);
    const mergedProps = utils_UNSAFE_mergeProps.mergeProps(eventsProps, tooltipProps);
    const { itemsPerCol, itemsPerRow } = getGridNums(items.length, layoutInfo[0]);
    const { legendStyle } = UNSAFE_Legend_themes_LegendStyles_css.styles;
    return (jsxRuntime.jsxs("div", { ref: rootRef, tabIndex: isReadOnly ? undefined : 0, class: legendStyle, ...ariaProps, ...mergedProps, children: [jsxRuntime.jsx(BaseLegend, { ...props, focusedItemRef: focusedItemRef, items: items, isReadOnly: isReadOnly, orientation: orientation, sectionIdx: 0, itemsPerRow: itemsPerRow, isColumnWidthValidRef: isColumnWidthValidRef, itemsPerCol: itemsPerCol, itemWidth: layoutInfo[0]?.isWrapped ? layoutInfo[0]?.maxItemWidth : undefined, focusedItemInfo: focusedItemInfo, hoveredItemInfo: hoveredItemInfo, activeId: eventsProps['aria-activedescendant'] }), tooltipContent] }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function getItem(itemInfo, sections) {
    const { sectionIdx, itemIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        const itemsLength = sections[sections.length - 1].items.length;
        return sections[sections.length - 1].items[itemsLength - 1];
    }
    return sections[sectionIdx].items[itemIdx];
}
function getNextItemInfo(itemInfo, sections) {
    let { itemIdx, sectionIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        return {
            itemIdx: sections[sections.length - 1].items.length - 1,
            sectionIdx: sections.length - 1
        };
    }
    itemIdx += 1;
    const itemsLength = sections[sectionIdx].items.length;
    if (itemIdx >= itemsLength) {
        if (sectionIdx === sections.length - 1) {
            itemIdx = itemInfo.itemIdx;
        }
        else {
            sectionIdx += 1;
            itemIdx = 0;
        }
    }
    return { itemIdx, sectionIdx };
}
function getPrevItemInfo(itemInfo, sections) {
    let { itemIdx, sectionIdx } = itemInfo;
    if (sectionIdx == -1 && itemIdx == -1) {
        (itemIdx = sections[sections.length - 1].items.length - 1), (sectionIdx = sections.length - 1);
    }
    itemIdx -= 1;
    if (itemIdx < 0) {
        if (sectionIdx === 0) {
            itemIdx = 0;
        }
        else {
            itemIdx = sections[sectionIdx - 1].items.length - 1;
            sectionIdx -= 1;
        }
    }
    return { itemIdx, sectionIdx };
}
/**
 * Returns utils functions for navigation in simple sectional legend.
 * @param items
 * @returns
 */
function getSectionalNavUtils(sections) {
    return {
        getItem: (itemInfo) => {
            return getItem(itemInfo, sections);
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo) {
                return { itemId: undefined, sectionId: undefined };
            }
            const item = getItem(itemInfo, sections);
            const sectionId = sections[itemInfo.sectionIdx].id;
            return { itemId: item.id, sectionId: sectionId };
        },
        getPrevItemInfo: (itemInfo) => {
            return getPrevItemInfo(itemInfo, sections);
        },
        getNextItemInfo: (itemInfo) => {
            return getNextItemInfo(itemInfo, sections);
        }
    };
}

/**
 * A Sectional Legend allows grouping of legend items in sections with a specific title.
 */
function SectionalLegend({ orientation = 'horizontal', sectionTitleHAlign = 'start', sections, isReadOnly = true, onItemAction, onInput, ...props }) {
    const rootRef = hooks.useRef(null);
    const rootDimsRef = hooks.useRef();
    const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getSectionalNavUtils(sections);
    const { layoutInfo, isColumnWidthValidRef } = useLegendLayout({
        rootRef,
        rootDimsRef,
        items: sections,
        isSectional: true,
        orientation
    });
    const { focusedItemInfo, hoveredItemInfo, ...eventsProps } = useEvents(!isReadOnly, props.hiddenIds != null, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onInput);
    const { focusedItemRef } = useItemFocus(focusedItemInfo);
    const text = getDatatipText(sections, getItem, focusedItemInfo, hoveredItemInfo);
    const { tooltipContent, tooltipProps } = useLegendTooltip({
        text,
        rootDimsRef,
        focusedItemInfo,
        focusedItemRef
    });
    const ariaProps = getAriaProps(isReadOnly, props['aria-label'], props.hiddenIds);
    const mergedProps = utils_UNSAFE_mergeProps.mergeProps(eventsProps, tooltipProps);
    const titleStyle = {
        fontFamily: props.sectionTitleFontFamily,
        fontSize: props.sectionTitleFontSize,
        color: props.sectionTitleColor,
        fontStyle: props.sectionTitleFontStyle,
        fontWeight: props.sectionTitleFontWeight,
        textDecoration: props.sectionTitleTextDecoration
    };
    const { sectionalLegendBaseStyles } = UNSAFE_Legend_themes_LegendStyles_css.styles;
    const isHoriz = orientation === 'horizontal';
    return (jsxRuntime.jsxs("div", { ref: rootRef, tabIndex: isReadOnly ? undefined : 0, class: sectionalLegendBaseStyles, ...ariaProps, ...mergedProps, children: [jsxRuntime.jsx(Flex.Flex, { direction: isHoriz ? 'row' : 'column', wrap: 'wrap', gap: '2.3x', children: sections.map((section, index) => {
                    const labelledById = !isReadOnly ? getRandomId() : '';
                    const isWrappedSection = layoutInfo[index]?.isWrapped;
                    const flexDirection = !isHoriz || isWrappedSection ? 'column' : 'row';
                    const alignItems = !isHoriz || isWrappedSection ? 'start' : 'center';
                    const { itemsPerCol, itemsPerRow } = getGridNums(section.items.length, layoutInfo[index]);
                    return (jsxRuntime.jsxs(Flex.Flex, { align: alignItems, direction: flexDirection, maxWidth: '100%', justify: 'start', wrap: "wrap", children: [jsxRuntime.jsx(LegendText, { text: section.title, ...titleStyle, type: "title", id: labelledById, align: sectionTitleHAlign }), jsxRuntime.jsx(BaseLegend, { ...props, isColumnWidthValidRef: isColumnWidthValidRef, focusedItemRef: focusedItemRef, labelledBy: labelledById, sectionIdx: index, items: section.items, orientation: orientation, itemsPerRow: itemsPerRow, itemsPerCol: itemsPerCol, itemWidth: layoutInfo[index]?.isWrapped ? layoutInfo[index]?.maxItemWidth : undefined, isReadOnly: isReadOnly, focusedItemInfo: focusedItemInfo, hoveredItemInfo: hoveredItemInfo, activeId: eventsProps['aria-activedescendant'] })] }));
                }) }), tooltipContent] }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

exports.Legend = Legend;
exports.SectionalLegend = SectionalLegend;
//# sourceMappingURL=UNSAFE_Legend.js.map
