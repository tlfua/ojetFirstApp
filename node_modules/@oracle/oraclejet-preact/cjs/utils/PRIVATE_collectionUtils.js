/* @oracle/oraclejet-preact: 15.1.2 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var utils_UNSAFE_keys = require('./UNSAFE_keys.js');
require('./PRIVATE_clientHints.js');
var clientHints = require('../clientHints-b9e7be1e.js');

/**
 * Returns the key from the item element
 */
const getKey = (item) => {
    return item.dataset['ojKeyType'] === 'number'
        ? Number(item.dataset['ojKey'])
        : item.dataset['ojKey'];
};
/**
 * A helper function that return the key of the first available item.
 */
const getFirstVisibleKey = (root, itemSelector) => {
    if (root) {
        const firstItem = root.querySelector(itemSelector);
        if (firstItem) {
            const key = getKey(firstItem);
            return key;
        }
    }
    return null;
};
/**
 * A helper function to find the element with the specified key.
 * Returns null if the element with key is not found.
 */
const findElementByKey = (root, key, itemSelector) => {
    if (root) {
        const items = root.querySelectorAll(itemSelector);
        for (let i = 0; i < items.length; i++) {
            const thisKey = getKey(items[i]);
            if (key == thisKey) {
                return items[i];
            }
        }
    }
    return null;
};
/**
 * A helper function that returns the key of the previous or the next item
 * given the specified current key
 */
const getPrevNextKey = (root, currentKey, isPrev, itemSelector) => {
    return () => {
        if (utils_UNSAFE_keys.isKeyDefined(currentKey) && root) {
            const currItem = findElementByKey(root, currentKey, itemSelector);
            if (currItem) {
                const nextItem = isPrev ? currItem.previousElementSibling : currItem.nextElementSibling;
                if (nextItem) {
                    const key = getKey(nextItem);
                    if (key != null) {
                        return key;
                    }
                }
                // no next item or next item is not a valid item
                return null;
            }
            return getFirstVisibleKey(root, itemSelector);
        }
        return null;
    };
};
/**
 * A helper function that returns the key of the previous or the next item by count,
 * given the specified current key
 */
const getPrevNextKeyByCount = (data, getRowKey, currentKey, count = 0) => {
    if (data && currentKey != undefined) {
        const currIndex = data.findIndex((d) => {
            return getRowKey(d) === currentKey;
        });
        const nextIndex = currIndex + count;
        if (0 <= nextIndex && nextIndex < data.length) {
            return getRowKey(data[nextIndex]);
        }
        return null;
    }
    return null;
};
/**
 * A helper function to get the key from an element
 */
const keyExtractor = (element, itemSelector) => {
    const item = element.closest(itemSelector);
    if (item) {
        const key = getKey(item);
        return key === undefined ? null : key;
    }
    return null;
};
/**
 * A helper function to that return viewPortConfig to collection components
 */
const getViewportConfig = (rootRef, config) => {
    return (config ?? {
        scroller: () => {
            return rootRef.current;
        }
    });
};
/**
 * A helper function to handle range selection
 */
const handleSelectionRange = (detail, data, getRowKey) => {
    const keys = data.map((value) => {
        return getRowKey(value);
    });
    const startIndex = keys.indexOf(detail.value.start);
    const endIndex = keys.indexOf(detail.value.end);
    const minIndex = Math.min(startIndex, endIndex);
    const maxIndex = Math.max(startIndex, endIndex);
    if (minIndex === -1) {
        // return a range to fetch so we can find all the keys, maxIndex should not be -1
        return { offset: 0, count: -1 };
    }
    else {
        // range of keys are in the current viewport, return them
        return keys.slice(minIndex, maxIndex + 1);
    }
};
/**
 * Helper function to determine whether the current device is a mobile device
 * @returns true if running on a mobile device, false otherwise
 */
function isMobile() {
    const deviceType = clientHints.getClientHints().deviceType;
    return deviceType === 'phone' || deviceType === 'tablet';
}

exports.findElementByKey = findElementByKey;
exports.getFirstVisibleKey = getFirstVisibleKey;
exports.getPrevNextKey = getPrevNextKey;
exports.getPrevNextKeyByCount = getPrevNextKeyByCount;
exports.getViewportConfig = getViewportConfig;
exports.handleSelectionRange = handleSelectionRange;
exports.isMobile = isMobile;
exports.keyExtractor = keyExtractor;
//# sourceMappingURL=PRIVATE_collectionUtils.js.map
