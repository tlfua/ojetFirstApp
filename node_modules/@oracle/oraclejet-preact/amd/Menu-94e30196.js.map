{"version":3,"file":"Menu-94e30196.js","sources":["../../src/UNSAFE_Menu/MenuContainer.tsx","../../src/UNSAFE_Menu/useMenuCurrentKey.ts","../../src/UNSAFE_Menu/DropdownMenu.tsx","../../src/UNSAFE_Menu/SheetMenu.tsx","../../src/UNSAFE_Menu/useMenuSwipe.ts","../../src/UNSAFE_Menu/Menu.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useCallback, useEffect, useRef, useState } from 'preact/hooks';\n\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { useUser } from '../hooks/UNSAFE_useUser';\n\nimport { BaseMenuProps } from './Menu';\nimport { useMenuCurrentKey } from './useMenuCurrentKey';\nimport {\n  getPrevNext,\n  keyElemExtractor,\n  getLastVisible,\n  getKeyboardCloseProps,\n  getCloseSubmenuEvent,\n  MenuCollectionItem,\n  getNVisible,\n  getMenuContainerFocusMethods,\n  getMenuContainerMouseLeave,\n  getMenuPointerDown\n} from './menuUtils';\nimport { useMenuContext } from './useMenuContext';\nimport { MenuContainerContext } from './MenuContainerContext';\nimport { menuStyles } from './themes/MenuStyles.css';\n\ntype MenuContainerProps = Omit<\n  BaseMenuProps,\n  'isOpen' | 'anchorRef' | 'defaultPlacement' | 'offsetValue'\n> & {\n  display: 'sheet' | 'dropdown';\n};\n\n/*Component where general behavior is handled. Here we controled focus behavior, focus styling, submenu\nopening behavior and current active item behavior. */\nexport const MenuContainer = ({\n  children,\n  'aria-label': ariaLabel,\n  currentFocus = 'menu',\n  display,\n  closeSubmenu,\n  menuId,\n  menuLevel\n}: MenuContainerProps) => {\n  const { onClose } = useMenuContext();\n\n  //Important to know direction so closeSubmenu is handled properly if needed.\n  const { direction } = useUser();\n\n  const menuContainerRef = useRef<HTMLDivElement | null>(null);\n\n  /*We share same behavior as legacy menu on mouseLeave that is:\n  1. If we mouse leave a menuItem but we still on menuContainer and we are not hovering any other menuItem, we keep \n  the focus on the menuItem and hovering style.\n  2. If we mouseLeave but next target is a submenu we open a submenu. \n  3. If we mouseLeave the container and next target is not a submenu, we reset current key and set the focus on the\n  menuContainer.If we mouseLeaved a submenuItem, submenu is closed.\n  General information used by menuItems:\n  -wasMouseMoved: Used to don't allow mouseEnter callbacks being triggered if mouse was not moved already.\n  -lastMouseLeaveValidatedRelatedTarget: We use bubbling nature of events to first check/validate the related target in onMouseLeave events of \n    menuItems. For menuItems we check if the related target is the menuContainer itself or a submenu. We validate there\n    since at this level we don't have access to any submenu. Everytime mouseEnter triggers at menuContainer we have to compare if both\n    relatedTargets are the same(menuContainer and last menuItem one), if not, this means mouse is now outside of the container.\n  */\n  const menuContainerGeneralInformation = useRef<{\n    wasMouseMoved: boolean;\n    lastMouseLeaveMenuItemdRelatedTarget: HTMLElement | null;\n  }>({\n    wasMouseMoved: false,\n    lastMouseLeaveMenuItemdRelatedTarget: null\n  });\n  //Used so focus is handled just one time using currentFocus. Used combined with menuLevel due to main menu can't\n  // change its focus via currentFocus prop.\n  const initialFocusDone = useRef<boolean>(false);\n\n  //Key of the active element on this menu container\n  const [currentKey, setCurrentKey] = useState<string | undefined>();\n\n  //State that represents if focused outline styles needs\n  const [showFocusRing, setShowFocusRing] = useState(false);\n\n  //Based on this we would include or not hovering styling. Same as legacy\n  const [isContainerFocused, setIsContainerFocused] = useState(false);\n\n  //Funtion triggered on blur. This is called since if focus is not anymore on the container we would need to do\n  //some validation\n  const blurFunction = () => {\n    if (!menuContainerRef.current?.contains(document.activeElement)) {\n      setShowFocusRing(false);\n      setIsContainerFocused(false);\n    }\n  };\n\n  const focusFunction = () => {\n    setIsContainerFocused(true);\n  };\n\n  const mouseLeaveFunction = (e: MouseEvent) => {\n    //We have to validate if new hover target was already validated correctly, if not this means mouse is now outside container\n    if (\n      !(e.relatedTarget as HTMLElement).isEqualNode(\n        menuContainerGeneralInformation.current.lastMouseLeaveMenuItemdRelatedTarget\n      )\n    ) {\n      //We reset current key when mouse is outside the container or any submenu. This is how legacy menu works\n      changeKey({\n        key: undefined,\n        reason: 'mouseEnter'\n      });\n      //We focus menuContainer so keyboard navigation can be still used\n      menuContainerRef.current?.focus();\n    }\n  };\n\n  //Function used to change the currentKey\n  const changeKey = useCallback((detail: MenuCollectionItem) => {\n    setCurrentKey(detail.key);\n    if (detail.reason === 'keyboard') {\n      setShowFocusRing(true);\n    } else {\n      setShowFocusRing(false);\n    }\n  }, []);\n\n  //This is used since if mouse overlaps space when menu is rendered, menuItem could trigger menuEnter,\n  // which is not desirable.Once mouse was moved inside container, we could trigger mouseEnter events normally.\n  const selfDestructiveMouseMoveEvent = useCallback(() => {\n    const handler = (e: MouseEvent) => {\n      const keyElem = keyElemExtractor(e.target as HTMLElement);\n      const key = keyElem?.key;\n      const elem = keyElem?.elem;\n      //We will trigger this event until a menuItem is found. Usually this don't take to much to happen\n      if (key && elem) {\n        menuContainerGeneralInformation.current.wasMouseMoved = true;\n        const evt = new MouseEvent('mouseenter');\n        elem.dispatchEvent(evt);\n        menuContainerRef.current?.removeEventListener('mousemove', handler);\n      }\n    };\n    menuContainerRef.current?.addEventListener('mousemove', handler);\n  }, []);\n\n  const { currentKeyProps } = useMenuCurrentKey(\n    getPrevNext(menuContainerRef.current, true, currentKey),\n    getPrevNext(menuContainerRef.current, false, currentKey),\n    () => getNVisible(menuContainerRef.current, 0),\n    () => getLastVisible(menuContainerRef.current),\n    changeKey\n  );\n\n  useEffect(() => {\n    if (menuLevel === 'main' && initialFocusDone.current) return;\n    initialFocusDone.current = true;\n    const menuContainer = menuContainerRef.current;\n    let timer: NodeJS.Timeout | undefined;\n    /*TODO: There are some cases where is not safe to focus since \n    visibility initially is hidden at the Floating component at the initial render. Need a way to solve this in a \n    less dirty way (we are now using timeouts). More details on the descripton of JET-57353 */\n    if (currentFocus !== 'none' && menuContainer) {\n      if (currentFocus === 'menu') {\n        changeKey({ key: undefined, reason: 'click' });\n        const focusMenuContainer = () => {\n          menuContainer.focus();\n        };\n        if (display === 'sheet') {\n          focusMenuContainer();\n        } else {\n          // At this point floating has visibility set as hidden, so also menuContainer. Settimeout added so menuContainer\n          // is visible at that point and can be focused.\n          timer = setTimeout(() => {\n            focusMenuContainer();\n          }, FOCUS_SHIFT_TIMEOUT);\n        }\n      } else if (currentFocus === 'firstItem') {\n        const firstItem = getNVisible(menuContainerRef.current, 0);\n        if (firstItem) {\n          changeKey({ key: firstItem, reason: 'keyboard' });\n        }\n      } else if (currentFocus === 'secondItem') {\n        //This is just used in sheet menu, so no need to set a timeout\n        const item = getNVisible(menuContainerRef.current, 1);\n        if (item) {\n          changeKey({ key: item, reason: 'keyboard' });\n        }\n      }\n    }\n    return () => {\n      //We have to clean timers, because comp can be unmounted after finishing timeouts\n      clearTimeout(timer);\n    };\n  }, [changeKey, currentFocus, menuLevel, display]);\n\n  useEffect(() => {\n    selfDestructiveMouseMoveEvent();\n  }, [selfDestructiveMouseMoveEvent]);\n\n  return (\n    <div\n      {...(menuId && { id: menuId })}\n      ref={menuContainerRef}\n      tabIndex={!currentKey && (menuLevel === 'main' || display === 'sheet') ? 0 : -1}\n      role=\"menu\"\n      aria-label={ariaLabel}\n      class={classNames([\n        menuStyles.menuContainerStyle,\n        menuStyles[`${display}MenuContainerStyle`]\n      ])}\n      {...mergeProps(\n        currentKeyProps,\n        getKeyboardCloseProps(onClose, menuLevel),\n        getCloseSubmenuEvent(direction, closeSubmenu),\n        getMenuContainerFocusMethods(blurFunction, focusFunction),\n        getMenuContainerMouseLeave(mouseLeaveFunction),\n        getMenuPointerDown()\n      )}>\n      <MenuContainerContext.Provider\n        value={{\n          /*We use this ref on dropdownSubmenu since unhover only close the menu if menuContainer ref does not include\n          the new element that receives the hovering */\n          menuContainerRef,\n          currentKey,\n          showFocusRing,\n          changeKey,\n          menuContainerGeneralInformation,\n          isContainerFocused\n        }}>\n        {children}\n      </MenuContainerContext.Provider>\n    </div>\n  );\n};\n\n//Temporal constant, will probably be removed with JET-57353\nconst FOCUS_SHIFT_TIMEOUT = 0;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { useCallback, useMemo } from 'preact/hooks';\n\nimport { MenuCollectionItem } from './menuUtils';\n\n/**\n * Hook for handling current key update due to user interaction including keyboard navigation.\n *\n * @param getPrev function to get the previous key based on the current key\n * @param getNext function to get the next key based on the current key\n * @param getFirstVisible function to get the key of the first available item\n * @param getLastVisible function to get the key of the last available item\n * @param onChange function to invoke if the current key has changed\n * @returns\n */\nexport function useMenuCurrentKey(\n  getPrev: () => string | null,\n  getNext: () => string | null,\n  getFirstVisible: () => string | null,\n  getLastVisible: () => string | null,\n  onChange?: (detail: MenuCollectionItem) => void\n) {\n  const keyDownKeyFunctions = useMemo(() => {\n    return {\n      ArrowDown: getNext,\n      ArrowUp: getPrev,\n      Home: getFirstVisible,\n      End: getLastVisible\n    } as Record<string, (() => string | null) | undefined>;\n  }, [getNext, getPrev, getFirstVisible, getLastVisible]);\n\n  const onKeyDown = useCallback(\n    (event: KeyboardEvent) => {\n      if (onChange) {\n        // TODO: support horizontal layout on icon menu (left/right arrow key)\n        const keyFunction = keyDownKeyFunctions[event.key];\n        if (keyFunction && !event.shiftKey) {\n          const key = keyFunction();\n          if (key) {\n            onChange({ key, reason: 'keyboard' });\n          }\n          event.preventDefault();\n        }\n      }\n    },\n    [onChange, keyDownKeyFunctions]\n  );\n\n  const currentKeyProps = onChange == null ? {} : { onKeyDown };\n  return { currentKeyProps };\n}\n","import { ComponentProps } from 'preact';\nimport { ForwardedRef, forwardRef, useCallback } from 'preact/compat';\n\nimport { Floating } from '../UNSAFE_Floating';\nimport { Layer } from '../UNSAFE_Layer';\n\nimport { MenuContainer } from './MenuContainer';\nimport { BaseMenuProps } from './Menu';\nimport { keyElemExtractor } from './menuUtils';\nimport { useMenuContext } from './useMenuContext';\nimport { dropdownMenuStyles } from './themes/DropdownMenuStyles.css';\n\ntype DropdownMenuProps = BaseMenuProps & DropdownMenuFloatingProps;\n\ntype FloatingProps = ComponentProps<typeof Floating>;\ntype DropdownMenuFloatingProps = {\n  defaultPlacement: FloatingProps['placement'];\n  offsetValue: FloatingProps['offsetValue'];\n  flipOptions: FloatingProps['flipOptions'];\n};\n\n/*Component used to render a dropdown menu. For now this is just rendered when device is not a phone. */\nexport const DropdownMenu = forwardRef(\n  (\n    {\n      anchorRef,\n      defaultPlacement,\n      offsetValue,\n      closeSubmenu,\n      children,\n      'aria-label': ariaLabel,\n      currentFocus,\n      menuId,\n      menuLevel,\n      flipOptions\n    }: DropdownMenuProps,\n    ref?: ForwardedRef<HTMLDivElement>\n  ) => {\n    const { onClose } = useMenuContext();\n\n    const useOutsideClickHandler = useCallback(\n      (e: MouseEvent) => {\n        if (menuLevel === 'sub') return;\n        // Outside click is not considered when menuItem was clicked\n        const menuItemKey = keyElemExtractor(e.target as HTMLElement)?.key;\n        if (!menuItemKey) {\n          onClose?.({ reason: 'outsideClick', target: e.target as Element });\n        }\n      },\n      [onClose, menuLevel]\n    );\n\n    // TODO - Reuse a dropdown component instead of creating floating by ourselves.\n    return (\n      <Layer logicalParentRef={anchorRef}>\n        <Floating\n          class={dropdownMenuStyles.base}\n          onClickOutside={useOutsideClickHandler}\n          anchorRef={anchorRef}\n          flipOptions={flipOptions}\n          shiftOptions={{\n            mainAxis: false,\n            crossAxis: false\n          }}\n          sizeOptions={{ isMaxHeightAdjusted: true, isMaxWidthAdjusted: true }}\n          //TODO: JET-57950. Need to see how we set 24px boundary.\n          //TODO: Boundaries need to match with the dropdowns used in other comps.  Also figure out how to make it themable.\n          boundaryOptions={{ padding: 0 }}\n          placement={defaultPlacement}\n          offsetValue={offsetValue}>\n          <div\n            style={{\n              minWidth: `${\n                anchorRef.current && anchorRef.current.offsetWidth > MENU_MIN_WIDTH\n                  ? anchorRef.current.offsetWidth\n                  : MENU_MIN_WIDTH\n              }px`\n            }}\n            ref={ref}>\n            <MenuContainer\n              menuLevel={menuLevel}\n              closeSubmenu={closeSubmenu}\n              aria-label={ariaLabel}\n              currentFocus={currentFocus}\n              menuId={menuId}\n              display=\"dropdown\">\n              {children}\n            </MenuContainer>\n          </div>\n        </Floating>\n      </Layer>\n    );\n  }\n);\n\nconst MENU_MIN_WIDTH = 200;\n","import { forwardRef } from 'preact/compat';\nimport { useCallback, useEffect } from 'preact/hooks';\n\nimport { useMenuSwipe } from './useMenuSwipe';\nimport useModal from '../UNSAFE_Modal/hooks/useModal';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { Layer } from '../UNSAFE_Layer';\nimport { classNames } from '../utils/UNSAFE_classNames';\n\nimport { BaseMenuProps } from './Menu';\nimport { useMenuContext } from './useMenuContext';\nimport { MenuContainer } from './MenuContainer';\nimport { sheetMenuStyles } from './themes/SheetMenuStyles.css';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'children'>;\n\nexport type SheetMenuProps = BaseMenuProps;\n\nconst ModalWrapper = ({ children }: IntrinsicProps) => (\n  <div class={sheetMenuStyles.modalWrapper}>{children}</div>\n);\nconst ModalContainer = forwardRef<HTMLDivElement, IntrinsicProps>(({ children }, ref) => (\n  <div class={sheetMenuStyles.modalContainer} ref={ref}>\n    {children}\n  </div>\n));\n//ModalBackdrop on modal folder not setting the style on oj-c enviroment\n//Creating it here so we don't see that issue\nconst ModalBackdrop = ({ backdropVisible = false }) => (\n  <div\n    class={classNames([\n      sheetMenuStyles.modalBackdrop,\n      backdropVisible && sheetMenuStyles.modalBackdropVisible\n    ])}\n  />\n);\n\nexport const SheetMenu = ({\n  children,\n  'aria-label': ariaLabel,\n  currentFocus,\n  anchorRef,\n  closeSubmenu,\n  menuLevel\n}: SheetMenuProps) => {\n  const { onClose } = useMenuContext();\n  useEffect(() => {\n    // We set the overflow body as hidden when mounted and revert to original overflow value when is\n    // unmounted. This is done to don't allow backgound being scrolled\n    // This will be handled by modal/popup when ready\n    const initialOverflow = document.body.style.overflow;\n    document.body.style.overflow = 'hidden';\n    return () => {\n      document.body.style.overflow = initialOverflow;\n    };\n  }, []);\n\n  const dismissHandler = useCallback(() => {\n    onClose?.({ reason: 'dismissed' });\n  }, [onClose]);\n\n  const { backdropRef } = useModal({ isOpen: true, onBackdropClick: dismissHandler });\n  //TODO: Use useSwipe when it works on components that could scroll.\n  const { swipeProps } = useMenuSwipe(dismissHandler);\n\n  // TODO: For now we are mimicking current modal but using a \"different position setting\" (using absolute positioning instead of flex).\n  // Have to use modal/popup component directly instead doing this composition when that component could satisfy our requirments.\n  return (\n    <Layer logicalParentRef={anchorRef}>\n      <ModalWrapper>\n        <ModalBackdrop backdropVisible={menuLevel === 'main'}></ModalBackdrop>\n        <ModalContainer ref={backdropRef}>\n          <div class={sheetMenuStyles.sheetMenuContainerWrapper} {...swipeProps}>\n            <MenuContainer\n              {...{ ariaLabel, currentFocus, display: 'sheet', closeSubmenu, menuLevel }}>\n              {children}\n            </MenuContainer>\n          </div>\n        </ModalContainer>\n      </ModalWrapper>\n    </Layer>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useRef, useCallback } from 'preact/hooks';\n\n/*\n  threshold: Minimal threshold required before recognizing\n  tolerance: A tolerance value which allows the user to move their finger about a length measured in pixels.\n  This allows the swipe gesture to be triggered more easily since a User might not move their finger\n  in a straight line.\n*/\ntype SwipeOptions = {\n  threshold?: number;\n  maximumTime?: number;\n  tolerance?: number;\n  isDisabled?: boolean;\n};\n\ntype SwipeInfo = {\n  direction: 'down';\n};\n\ntype SwipeState = {\n  pointerDownId: number | null;\n  startTime: number | null;\n  prevpageX: number;\n  prevpageY: number;\n  elementScrollTop: number;\n};\n/*This \"private\" hook will live until we end up stating a final decision on useSwipe hook.\nFor that hook to work, element that use it has to set touch-action:none;, since pointer events\nare canceled once a touch action is going to be handled by the browser. This works for most\nof the components that don't scroll. But if the component scroll, there is a need for the browser to \nhandle scroll which is imposible with a hook just using pointer events.\n*/\nexport function useMenuSwipe(\n  onSwipe: (e: SwipeInfo) => void,\n  { threshold = 10, maximumTime = 300, tolerance = 50, isDisabled = false }: SwipeOptions = {\n    threshold: 10,\n    maximumTime: 300,\n    tolerance: 50,\n    isDisabled: false\n  }\n): { swipeProps: Record<string, any> } {\n  const ref = useRef<SwipeState>({\n    pointerDownId: 0,\n    startTime: null,\n    prevpageX: 0,\n    prevpageY: 0,\n    elementScrollTop: 0\n  });\n\n  const clearSwipe = useCallback(() => {\n    ref.current = {\n      pointerDownId: null,\n      startTime: 0,\n      prevpageX: 0,\n      prevpageY: 0,\n      elementScrollTop: 0\n    };\n  }, []);\n\n  const onTouchStart = useCallback(\n    (e: TouchEvent) => {\n      const touchobj = e.changedTouches[0];\n      if (!ref.current.pointerDownId) {\n        ref.current = {\n          pointerDownId: touchobj.identifier,\n          startTime: e.timeStamp,\n          prevpageX: touchobj.pageX,\n          prevpageY: touchobj.pageY,\n          elementScrollTop: (e.currentTarget as HTMLElement).scrollTop\n        };\n      } else {\n        clearSwipe();\n      }\n    },\n    [clearSwipe]\n  );\n\n  const onTouchEnd = useCallback(\n    (ev: TouchEvent) => {\n      const touchobj = ev.changedTouches[0];\n      if (touchobj.identifier === ref.current.pointerDownId) {\n        if (ref.current.startTime && ev.timeStamp - ref.current.startTime < maximumTime) {\n          if (\n            touchobj.pageY - ref.current.prevpageY > threshold &&\n            Math.abs(touchobj.pageX - ref.current.prevpageX) <= tolerance &&\n            ref.current.elementScrollTop === 0\n          ) {\n            onSwipe?.({ direction: 'down' });\n          }\n        }\n      }\n      // state would be reset to its original state whether swipe is completed or cancelled\n      clearSwipe();\n    },\n    [threshold, onSwipe, clearSwipe, maximumTime, tolerance]\n  );\n\n  const swipeProps = isDisabled\n    ? {}\n    : {\n        /** event handlers to spread on the target element. */\n        onTouchStart,\n        onTouchEnd,\n        ontouchcancel: clearSwipe\n      };\n\n  return {\n    swipeProps\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * Licensed under The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { RefObject, ComponentChildren } from 'preact';\n\nimport { DropdownMenu } from './DropdownMenu';\nimport { SheetMenu } from './SheetMenu';\nimport { MenuContext } from './MenuContext';\nimport { getIsMobile } from './menuUtils';\n\ntype MenuProps = {\n  /**\n   * Trigger element reference\n   */\n  anchorRef: RefObject<HTMLElement>;\n  /**\n   * Set of menu groups or menu items that menu will hold.Even though you could pass other type of children,\n   * is strongly recommended to use MenuItem, menu groups or components that return this type of components\n   * since passing other type of components children produces not desirable behaviors.\n   */\n  children: ComponentChildren;\n  /**\n   * Specifies if menu is opened.\n   */\n  isOpen?: boolean;\n  /**\n   * Property that triggers a callback when menu is supposed to be closed.\n   */\n  onClose?: (detail: CloseDetail) => void;\n  /**\n   * Specifies some screen reader text. Set it to create an accesible menu.\n   */\n  'aria-label'?: string;\n  /**\n   *  Determines focus behavior when the menu is opened.\n   */\n  initialFocus?: 'menu' | 'firstItem';\n};\n\ntype CloseDetail =\n  | {\n      //dismissed represents dismissing the menu using esc,tap and on mobile swiping and taping backdrop\n      reason: 'dismissed' | 'itemAction';\n    }\n  | {\n      reason: 'outsideClick';\n      target: Element;\n    };\n\n// Type only used internally by Sheet and Dropdown menu. If we want to expose both at some point we would need to\n// adjust this type.\nexport type BaseMenuProps = (MainMenu | SubMenu) &\n  Omit<MenuProps, 'onClose' | 'initialFocus' | 'isOpen'> & {\n    /*None is a valid option here since there are some use cases where a menu is opened and we don't want to focus anything\n    eg. When menu is opened due to a hover on submenuitem\n    When pasing a number, that is index of the element is going to be focused\n    eg. 1 focus the second menuitem*/\n    currentFocus?: 'menu' | 'firstItem' | 'secondItem' | 'none';\n  };\n\ntype MainMenu = {\n  menuLevel: 'main';\n  menuId?: never;\n  closeSubmenu?: never;\n};\n\ntype SubMenu = {\n  menuLevel: 'sub';\n  menuId?: string;\n  closeSubmenu?: () => void;\n};\nconst isMobile = getIsMobile();\n\n/* Component that is exposed to final user to create a menu. Important to notice that this component is just used by\nthe final user to express a main menu. It's not reused by us for submenus (we use SheetMenu and DropdownMenu directly there) */\n\nexport const Menu = ({ onClose, isOpen, initialFocus, ...menuProps }: MenuProps) => {\n  //On close is consumed by the whole menu structure including the main menu and submenu ones.\n  return (\n    <MenuContext.Provider value={{ onClose, isMobile }}>\n      {!isOpen ? null : (\n        <>\n          {isMobile ? (\n            <SheetMenu\n              {...{\n                ...menuProps,\n                currentFocus: initialFocus,\n                menuLevel: 'main'\n              }}></SheetMenu>\n          ) : (\n            <DropdownMenu\n              {...{\n                ...menuProps,\n                currentFocus: initialFocus,\n                menuLevel: 'main',\n                defaultPlacement: 'bottom-start',\n                offsetValue: {\n                  mainAxis: 4, //TODO: stable does not have a 4px gap, so we'll need to figure out how to make this themable.\n                  crossAxis: 0\n                },\n                flipOptions: {\n                  crossAxis: true,\n                  mainAxis: true,\n                  fallbackPlacements: [\n                    'bottom-end',\n                    'top-start',\n                    'top-end',\n                    'end-top',\n                    'start-top',\n                    'end-bottom',\n                    'start-bottom'\n                  ]\n                }\n              }}></DropdownMenu>\n          )}\n        </>\n      )}\n    </MenuContext.Provider>\n  );\n};\n"],"names":["MenuContainer","children","ariaLabel","currentFocus","display","closeSubmenu","menuId","menuLevel","onClose","useMenuContext","direction","useUser","menuContainerRef","useRef","menuContainerGeneralInformation","wasMouseMoved","lastMouseLeaveMenuItemdRelatedTarget","initialFocusDone","currentKey","setCurrentKey","useState","showFocusRing","setShowFocusRing","isContainerFocused","setIsContainerFocused","changeKey","useCallback","detail","key","reason","selfDestructiveMouseMoveEvent","handler","e","keyElem","keyElemExtractor","target","elem","current","evt","MouseEvent","dispatchEvent","removeEventListener","addEventListener","currentKeyProps","getPrev","getNext","getFirstVisible","getLastVisible","onChange","keyDownKeyFunctions","useMemo","ArrowDown","ArrowUp","Home","End","onKeyDown","event","keyFunction","shiftKey","preventDefault","useMenuCurrentKey","getPrevNext","getNVisible","useEffect","menuContainer","timer","undefined","focusMenuContainer","focus","setTimeout","FOCUS_SHIFT_TIMEOUT","firstItem","item","clearTimeout","_jsx","id","ref","tabIndex","role","class","classNames","menuStyles","menuContainerStyle","mergeProps","getKeyboardCloseProps","getCloseSubmenuEvent","getMenuContainerFocusMethods","contains","document","activeElement","getMenuContainerMouseLeave","relatedTarget","isEqualNode","getMenuPointerDown","MenuContainerContext","Provider","value","DropdownMenu","forwardRef","anchorRef","defaultPlacement","offsetValue","flipOptions","useOutsideClickHandler","menuItemKey","jsx","Layer","logicalParentRef","Floating","dropdownMenuStyles","base","onClickOutside","shiftOptions","mainAxis","crossAxis","sizeOptions","isMaxHeightAdjusted","isMaxWidthAdjusted","boundaryOptions","padding","placement","style","minWidth","offsetWidth","MENU_MIN_WIDTH","ModalWrapper","sheetMenuStyles","modalWrapper","ModalContainer","modalContainer","ModalBackdrop","backdropVisible","modalBackdrop","modalBackdropVisible","SheetMenu","initialOverflow","body","overflow","dismissHandler","backdropRef","useModal","isOpen","onBackdropClick","swipeProps","onSwipe","threshold","maximumTime","tolerance","isDisabled","pointerDownId","startTime","prevpageX","prevpageY","elementScrollTop","clearSwipe","onTouchStart","touchobj","changedTouches","identifier","timeStamp","pageX","pageY","currentTarget","scrollTop","onTouchEnd","ev","Math","abs","ontouchcancel","useMenuSwipe","_jsxs","sheetMenuContainerWrapper","isMobile","getIsMobile","initialFocus","menuProps","MenuContext","_Fragment","fallbackPlacements"],"mappings":"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"}