{"version":3,"file":"CardGrid-9b307c00.js","sources":["../../src/UNSAFE_CardGrid/CardGridItem.tsx","../../src/UNSAFE_CardGrid/CardGrid.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { memo } from 'preact/compat';\nimport { useRef, useLayoutEffect, useMemo, StateUpdater } from 'preact/hooks';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { useAnimation, UseAnimationConfig } from '../hooks/UNSAFE_useAnimation';\nimport { TabbableModeContext } from '../hooks/UNSAFE_useTabbableMode';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { SelectionMode } from '../UNSAFE_Collection';\nimport { multiVariantStyles, styles } from './themes/CardGridStyles.css';\n\nexport const ITEM_STYLE_CLASS = 'oj-cardgrid-item';\nexport const ITEM_SELECTOR = '.' + ITEM_STYLE_CLASS;\n\n/**\n * Props for the CardGridItem Component\n */\nexport type Props<K, D> = {\n  children: ComponentChildren;\n  itemKey: K;\n  itemIndex: number;\n  itemData: D;\n  isTabbable: boolean;\n  isFocused: boolean;\n  isFocusRingVisible: boolean;\n  isSelected: boolean;\n  selectionMode: SelectionMode;\n  initialAnimation?: 'slideUp' | 'slideDown';\n  setCardDimension?: StateUpdater<{ width: number; height: number }>;\n};\n\n/**\n * The internal component used to render a single item in CardGrid.\n */\nexport function CardGridItem<K extends string | number, D>({\n  children,\n  itemKey,\n  itemIndex,\n  isTabbable,\n  isFocused,\n  isFocusRingVisible,\n  isSelected,\n  selectionMode,\n  initialAnimation,\n  setCardDimension\n}: Props<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n\n  const variantClasses = multiVariantStyles({\n    itemFocused: isFocused && isFocusRingVisible ? 'isItemFocused' : 'isNotItemFocused',\n    itemInitialOpacity: initialAnimation ? 'isTransparent' : 'isNotTransparent'\n  });\n  const classes = classNames([ITEM_STYLE_CLASS, styles.itemStyle, variantClasses]);\n\n  // don't bubble Arrow Up/Down/Left/Right events to parent when in isTabbable mode\n  // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.\n  const handleKeyDown = (event: KeyboardEvent) => {\n    if (\n      isTabbable &&\n      (event.key === 'ArrowDown' ||\n        event.key === 'ArrowUp' ||\n        event.key === 'ArrowLeft' ||\n        event.key === 'ArrowRight')\n    ) {\n      event.stopPropagation();\n    }\n  };\n\n  useLayoutEffect(() => {\n    const firstCard = rootRef.current?.firstElementChild as HTMLElement;\n    if (setCardDimension && firstCard) {\n      setCardDimension({ width: firstCard.offsetWidth, height: firstCard.offsetHeight });\n    }\n  }, []);\n\n  // todo: issue track in JET-57681, we currently have two useAnimation() because the opacity and\n  // slide up/down have different durations, and the current API couldn't handle this case, we will\n  // update this once the API is updated\n\n  // animation for slide up/down\n  const { nodeRef: nodeRefSlide } = useAnimation<'slideUp' | 'slideDown' | 'none', HTMLDivElement>(\n    initialAnimation || 'none',\n    animationConfigSlide(itemIndex)\n  );\n  // animation for opacity change\n  const { nodeRef: nodeRefOpacity } = useAnimation<'opacity' | 'none', HTMLDivElement>(\n    (initialAnimation && 'opacity') || 'none',\n    animationConfigOpacity(itemIndex)\n  );\n\n  const itemRefs = useMemo(\n    () => mergeRefs(rootRef, nodeRefSlide, nodeRefOpacity),\n    // spot an issue when we click the cards during animation is processing, the cards would not finish\n    // the current animations and stay as what it is, e.g. leave itself as half transparent.\n    // add initialAnimation to the dependency to prevent this issue.\n    [rootRef, nodeRefSlide, nodeRefOpacity, initialAnimation]\n  );\n\n  return (\n    <div\n      id={useId()}\n      ref={itemRefs}\n      class={classes}\n      role=\"gridcell\"\n      data-oj-key={itemKey}\n      onKeyDown={handleKeyDown}\n      aria-selected={selectionMode === 'none' ? undefined : isSelected}\n      {...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' })}>\n      <TabbableModeContext.Provider value={{ isTabbable }}>\n        <FocusTrap isDisabled={!isTabbable} restoreFocusRef={false}>\n          {children}\n        </FocusTrap>\n      </TabbableModeContext.Provider>\n    </div>\n  );\n}\n\nconst animationConfigSlide = (\n  index: number\n): UseAnimationConfig<'slideUp' | 'slideDown' | 'none', HTMLDivElement> => {\n  return {\n    animationStates: {\n      slideUp: {\n        from: {\n          translateY: '50px'\n        },\n        to: {\n          translateY: '0px'\n        },\n        options: {\n          duration: 300,\n          delay: index * 50,\n          easing: [0, 0, 0.2, 1]\n        }\n      },\n      slideDown: {\n        from: {\n          translateY: '-50px'\n        },\n        to: {\n          translateY: '0'\n        },\n        options: {\n          duration: 300,\n          delay: index * 50,\n          easing: [0, 0, 0.2, 1]\n        }\n      }\n    },\n    isAnimatedOnMount: true\n  };\n};\n\nconst animationConfigOpacity = (\n  index: number\n): UseAnimationConfig<'opacity' | 'none', HTMLDivElement> => {\n  return {\n    animationStates: {\n      opacity: {\n        from: {\n          opacity: 0\n        },\n        to: {\n          opacity: 1\n        },\n        options: {\n          duration: 150,\n          delay: index * 50,\n          easing: 'linear'\n        }\n      }\n    },\n    isAnimatedOnMount: true\n  };\n};\n\nexport const MemoizeCardGridItem = memo(\n  CardGridItem,\n  <K, D>(prev: Props<K, D>, next: Props<K, D>) => {\n    if (prev && next) {\n      return (\n        prev.itemKey === next.itemKey &&\n        prev.itemIndex === next.itemIndex &&\n        prev.itemData === next.itemData &&\n        prev.isTabbable === next.isTabbable &&\n        prev.isFocused === next.isFocused &&\n        prev.isFocusRingVisible === next.isFocusRingVisible &&\n        prev.isSelected === next.isSelected &&\n        prev.initialAnimation === next.initialAnimation\n      );\n    }\n    return false;\n  }\n);\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren } from 'preact';\nimport { useRef, useCallback, useEffect, useState } from 'preact/hooks';\nimport { mergeProps } from '../utils/UNSAFE_mergeProps';\nimport { containsKey, Keys, isKeyDefined } from '../utils/UNSAFE_keys';\nimport { Size } from '../utils/UNSAFE_size';\nimport {\n  getPrevNextKeyByCount,\n  getFirstVisibleKey,\n  getViewportConfig,\n  findElementByKey,\n  keyExtractor,\n  handleSelectionRange\n} from '../utils/PRIVATE_collectionUtils';\nimport { useId } from '../hooks/UNSAFE_useId';\nimport { useCurrentKey } from '../hooks/PRIVATE_useCurrentKey';\nimport { useCollectionFocusRing } from '../hooks/PRIVATE_useCollectionFocusRing';\nimport { useTabbableModeSet } from '../hooks/PRIVATE_useTabbableModeSet';\nimport { useSelection, SelectionRangeDetail } from '../hooks/PRIVATE_useSelection';\nimport { ViewportConfig } from '../hooks/UNSAFE_useViewportIntersect';\nimport {\n  ItemContext,\n  ListItemContext,\n  CurrentKeyDetail,\n  SelectionDetail,\n  SelectionMode\n} from '../UNSAFE_Collection';\nimport { Grid } from '../UNSAFE_Grid';\nimport { Selector } from '../UNSAFE_Selector';\nimport { Skeleton } from '../UNSAFE_Skeleton';\nimport { SkeletonContainer } from '../PRIVATE_List/SkeletonContainer';\nimport { LoadMoreCollection, LOADMORE_STYLE_CLASS } from '../PRIVATE_LoadMoreCollection';\nimport { MemoizeCardGridItem, ITEM_SELECTOR } from './CardGridItem';\nimport { styles } from './themes/CardGridStyles.css';\n\n/**\n * Props for the GradGrid Component, which consist of some props from ListView\n */\ntype CardGridProps<K, D> = {\n  /**\n   * An array of shaped data that provide information to this CardGrid.\n   * If the value is null, then CardGrid will show loading indicator until the value is set.\n   */\n  data: D[] | null;\n  /**\n   * Callback function to handle when viewport has changed, including the case\n   * where user scrolls to the end of the component and there are more items to load.\n   */\n  onLoadMore?: () => void;\n  /**\n   * A boolean that indicates whether there are still more data to load.\n   */\n  hasMore?: boolean;\n  /**\n   * A callback function to get the key for a given row\n   */\n  getRowKey: (data: D) => K;\n  /**\n   * A function to render each item\n   */\n  children: (context: ListItemContext<K, D>) => ComponentChildren;\n  /**\n   * The key of the item that currently have keyboard focus. Ignored if the current item is not\n   * currently in the viewport.\n   */\n  currentKey?: K;\n  /**\n   * Callback function to handle when current focused item has changed.  The function should\n   * update the currentKey prop with a new current key.\n   */\n  onCurrentKeyChange?: (detail: CurrentKeyDetail<K>) => void;\n  /**\n   * The type of selection behavior that is enabled on the CardGrid. This property controls the number\n   * of selections that can be made via selection gestures at any given time.\n   */\n  selectionMode?: SelectionMode;\n  /**\n   * The keys of the current selected items in the CardGrid.\n   */\n  selectedKeys?: Keys<K>;\n  /**\n   * Callback function to handle when selection has changed.  The function should update\n   * the selectedKeys prop with a new set of selected keys.\n   */\n  onSelectionChange?: (detail: SelectionDetail<K>) => void;\n  /**\n   * The ViewportConfig currently contains only one property which allows application to specify what the scroller element should be.\n   * If not specified, then the root element of CardGrid itself will be the scroller element.\n   */\n  viewportConfig?: ViewportConfig;\n  /**\n   * An aria-label which defines a string value that labels this CardGrid.\n   * Either aria-label or aria-labelledby should be specified in order to make CardGrid accessible.\n   */\n  'aria-label'?: string;\n  /**\n   * An aria-labelledby which identifies the element(s) that labels this CardGrid.\n   * Either aria-label or aria-labelledby should be specified in order to make CardGrid accessible.\n   */\n  'aria-labelledby'?: string;\n  /**\n   * Specify animation when cards are initially rendered.\n   */\n  initialAnimation?: 'slideUp' | 'slideDown';\n  /**\n   * Size of the gutter between columns.\n   */\n  gutterSize?: 'xs' | 'sm' | 'md' | 'lg' | 'xl';\n};\n\nexport function CardGrid<K extends string | number, D>({\n  children,\n  data,\n  onLoadMore = () => {},\n  hasMore = false,\n  getRowKey,\n  currentKey,\n  onCurrentKeyChange,\n  selectionMode = 'none',\n  selectedKeys = emptyKeys as Keys<K>,\n  onSelectionChange,\n  viewportConfig,\n  'aria-label': ariaLabel,\n  'aria-labelledby': ariaLabelledBy,\n  initialAnimation = 'slideUp',\n  gutterSize = 'sm'\n}: CardGridProps<K, D>) {\n  const rootRef = useRef<HTMLDivElement>(null);\n\n  // tracking the anchor key which is used for shift+click selection\n  const anchorKey = useRef<K | undefined>();\n  // tracking pending current key in pointer down event\n  const pendingCurrentKey = useRef<K>();\n\n  const isInitialAnimation = useRef(true);\n  const [colCount, setColCount] = useState(0);\n  const [cardDimension, setCardDimension] = useState({ width: 0, height: 0 });\n\n  const gutterSizePX = gutterSizeMappings[gutterSize];\n  const gap = `${gutterSizePX / 4}x` as Size;\n  const gridTemplateColumns = cardDimension.width\n    ? `repeat(auto-fit, ${cardDimension.width}px)`\n    : undefined;\n  const gridProps = { gap, gridTemplateColumns };\n\n  const ariaMultiSelectable = selectionMode === 'none' ? undefined : selectionMode === 'multiple';\n  const ariaRowcount = hasMore || !data || colCount === 0 ? -1 : Math.ceil(data?.length / colCount);\n\n  /*****************************************************************************************/\n  /********************************* cardWidth and colCount ********************************/\n  /*****************************************************************************************/\n\n  // cards are fully rendered for the first time, only when cardWidth and colCount have defined and non-zero values\n  // for the first time, so the initial animation should not happen until this render.\n  useEffect(() => {\n    if (cardDimension.width && colCount) {\n      isInitialAnimation.current = false;\n    }\n  }, [cardDimension.width && colCount]);\n\n  const handleColCount = useCallback(\n    (rootWidth: number) => {\n      const newColCount = getColCount(\n        gutterSizePX,\n        cardDimension.width || DEFAULT_SKELETON_WIDTH,\n        rootWidth\n      );\n      if (newColCount > 0) {\n        setColCount(newColCount);\n      }\n    },\n    [gutterSizePX, cardDimension.width]\n  );\n\n  useEffect(() => {\n    const root = rootRef?.current;\n    if (root) {\n      handleColCount(root.offsetWidth);\n    }\n  }, [handleColCount]);\n\n  const handleResize = useCallback(\n    (entries: ResizeObserverEntry[]) => {\n      for (const entry of entries) {\n        // update colCount during resize\n        handleColCount(entry.contentRect.width);\n      }\n    },\n    [handleColCount]\n  );\n\n  /**\n   * Set up resize observer and update the colCount, to ensure keyboard navigation is correct\n   * after the resize\n   */\n  useEffect(() => {\n    const root = rootRef.current;\n    if (root) {\n      const resizeObserver = new ResizeObserver((entries: ResizeObserverEntry[]) => {\n        handleResize(entries);\n      });\n      resizeObserver.observe(root);\n      return () => {\n        resizeObserver.unobserve(root);\n      };\n    }\n    return undefined;\n  }, [handleResize]);\n\n  /*****************************************************************************************/\n  /************************************* Tabbable Mode *************************************/\n  /*****************************************************************************************/\n\n  const cardGridContains = (elem: Element | null) => {\n    return !!rootRef.current?.contains(elem);\n  };\n\n  let pendingFocusRingChange = false;\n  const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(\n    cardGridContains,\n    (element) => {\n      return keyExtractor(element, ITEM_SELECTOR) as K;\n    },\n    currentKey,\n    // handle clean-up on disabling of the mode\n    (target: EventTarget | null, isKeyboardEvent) => {\n      if (cardGridContains(target as Element)) {\n        // delay focus reset for keyboard disable so focus is reset to CardGrid after the FocusTrap blur lifecycle completes.\n        // pointer initiated changes will fire the onBlur organically and delaying the focus, just generates an unwanted second blur\n        if (isKeyboardEvent) {\n          // do not show a focus ring during this timeOut\n          pendingFocusRingChange = true;\n          setTimeout(() => {\n            rootRef.current?.focus();\n          }, 0);\n        } else {\n          rootRef.current?.focus();\n        }\n      }\n      // otherwise target is not in list (including body, which target should be null in that case)\n    },\n    // set currentKey when mode is enabled\n    (key: K) => {\n      onCurrentKeyChange && onCurrentKeyChange({ value: key });\n    }\n  );\n\n  /*****************************************************************************************/\n  /********************************* Current Key and Focus *********************************/\n  /*****************************************************************************************/\n\n  const { currentKeyProps } = useCurrentKey(\n    (element) => keyExtractor(element, ITEM_SELECTOR),\n    selectionMode !== 'multiple',\n    // init a function every time to make sure we pass in the latest colCount.current,\n    // otherwise the new key might be wrong after resize\n    () => getPrevNextKeyByCount(data, getRowKey, currentKey, -colCount),\n    () => getPrevNextKeyByCount(data, getRowKey, currentKey, colCount),\n    () => getPrevNextKeyByCount(data, getRowKey, currentKey, -1),\n    () => getPrevNextKeyByCount(data, getRowKey, currentKey, 1),\n    currentKey,\n    onCurrentKeyChange\n  );\n\n  const [showFocusRing, focusRingProps] = useCollectionFocusRing(cardGridContains, [\n    'ArrowUp',\n    'ArrowDown',\n    'ArrowLeft',\n    'ArrowRight'\n  ]);\n\n  const handleInitialFocus = () => {\n    if (\n      !isKeyDefined(currentKey) &&\n      onCurrentKeyChange &&\n      isCurrentTabbableKey(undefined) &&\n      rootRef.current\n    ) {\n      const firstKey =\n        pendingCurrentKey.current || (getFirstVisibleKey(rootRef.current, ITEM_SELECTOR) as K);\n      if (isKeyDefined(firstKey)) {\n        onCurrentKeyChange({ value: firstKey });\n      }\n    }\n  };\n\n  /**\n   * Need to track pointer down element to set currentItem when initial focus happens\n   */\n  const handlePointerDown = (event: PointerEvent) => {\n    const key = keyExtractor(event.target as HTMLElement, ITEM_SELECTOR);\n    if (isKeyDefined(key)) {\n      pendingCurrentKey.current = key as K;\n    }\n  };\n\n  useEffect(() => {\n    if (currentKey != null && rootRef.current) {\n      const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);\n      if (elem) {\n        // make sure item is visible\n        elem.scrollIntoView({ block: 'nearest' });\n        const cell = elem.closest(`[role=gridcell]`);\n        if (cell) {\n          // update aria-activedescendant for screen reader\n          rootRef.current.setAttribute('aria-activedescendant', cell.id);\n        }\n      }\n    }\n    // listen to data because the current item would re-render when data is updated, i.e. the id\n    // of current item would be updated, so the currentKey itself couldn't guarantee the root has\n    // the latest aria-activedescendant\n  }, [currentKey, data]);\n\n  /*****************************************************************************************/\n  /*************************************** Selection ***************************************/\n  /*****************************************************************************************/\n\n  const handleSelectionChange = useCallback(\n    (detail: SelectionDetail<K>) => {\n      if (onSelectionChange) {\n        if (detail.value.all === false && detail.value.keys.size > 0) {\n          // the last key selected by a user gesture is the anchor key\n          anchorKey.current = Array.from(detail.value.keys.values()).pop();\n        }\n        onSelectionChange(detail);\n      }\n    },\n    [anchorKey, onSelectionChange]\n  );\n\n  const handleSelectionRangeChange = useCallback(\n    (detail: SelectionRangeDetail<K>) => {\n      if (data && onSelectionChange) {\n        const value = handleSelectionRange(detail, data, getRowKey);\n        // for non-virtualized CardGrid, value should always be an array\n        if (Array.isArray(value)) {\n          onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });\n        }\n      }\n    },\n    [data, onSelectionChange, onLoadMore]\n  );\n\n  const { selectionProps } = useSelection(\n    (element: HTMLElement) => {\n      if (element === rootRef.current) {\n        return currentKey === undefined ? null : currentKey;\n      }\n      return keyExtractor(element, ITEM_SELECTOR) as K;\n    },\n    selectedKeys,\n    selectionMode,\n    false,\n    'replace',\n    false,\n    handleSelectionChange,\n    anchorKey.current,\n    currentKey,\n    (currentKey: K | undefined, isPrev: boolean) => () =>\n      getPrevNextKeyByCount(data, getRowKey, currentKey, isPrev ? -colCount : colCount),\n    (currentKey: K | undefined, isPrev: boolean) => () =>\n      getPrevNextKeyByCount(data, getRowKey, currentKey, isPrev ? -1 : 1),\n    (key: K) => {\n      if (rootRef.current) {\n        const elem = findElementByKey(rootRef.current, key, ITEM_SELECTOR);\n        if (elem) {\n          elem.scrollIntoView({ block: 'nearest' });\n        }\n      }\n    },\n    handleSelectionRangeChange\n  );\n\n  /*****************************************************************************************/\n  /************************************ Child Component ************************************/\n  /*****************************************************************************************/\n\n  const getItemContext = useCallback(\n    (context: ItemContext<D>) => {\n      const key = getRowKey(context.data);\n      const selectorRenderer =\n        selectionMode === 'multiple'\n          ? () => (\n              <Selector\n                onChange={onSelectionChange}\n                rowKey={key}\n                selectedKeys={selectedKeys}></Selector>\n            )\n          : undefined;\n\n      return {\n        index: context.index,\n        data: context.data,\n        metadata: { key: key },\n        selector: selectorRenderer,\n        isSelected: containsKey(selectedKeys, key)\n      };\n    },\n    [selectionMode, selectedKeys, onSelectionChange]\n  );\n\n  const childrenComponent = (context: ItemContext<D>) => {\n    const cardItemContext = getItemContext(context);\n    const isTabbable = isCurrentTabbableKey(cardItemContext.metadata.key);\n    const isFocused = currentKey === cardItemContext.metadata.key && !isTabbable;\n    const isFocusRingVisible = isFocused && showFocusRing && !pendingFocusRingChange;\n    const isSelected = cardItemContext.isSelected;\n    const cardGridFunc = (context: ListItemContext<K, D>) => (\n      <MemoizeCardGridItem\n        key={cardItemContext.metadata.key}\n        itemKey={cardItemContext.metadata.key}\n        itemIndex={cardItemContext.index}\n        itemData={cardItemContext.data}\n        isTabbable={isTabbable}\n        isFocused={isFocused}\n        isFocusRingVisible={isFocusRingVisible}\n        isSelected={isSelected}\n        selectionMode={selectionMode}\n        {...(isInitialAnimation.current && { initialAnimation })}\n        {...(context.index === 0 && { setCardDimension })}>\n        {children(context)}\n      </MemoizeCardGridItem>\n    );\n    return cardGridFunc(cardItemContext);\n  };\n\n  // todo: issue track in JET-57952, need a way to show the skeletons in keyboard navigation\n  const skeletons = findDefaultLoadMoreIndicator(\n    gridProps,\n    data?.length || 0,\n    colCount,\n    cardDimension.height\n  );\n\n  viewportConfig = getViewportConfig(rootRef, viewportConfig);\n  const collectionComponent = (\n    <div role=\"row\">\n      <Grid {...gridProps}>\n        <LoadMoreCollection\n          data={data}\n          hasMore={hasMore}\n          onLoadMore={onLoadMore}\n          loadMoreIndicator={skeletons}\n          loadMoreThreshold={gutterSizePX + 4} // gap size + padding\n          viewportConfig={viewportConfig}>\n          {childrenComponent}\n        </LoadMoreCollection>\n      </Grid>\n    </div>\n  );\n\n  return (\n    <div\n      {...mergeProps(tabbableModeProps, currentKeyProps, focusRingProps, selectionProps, {\n        onFocus: handleInitialFocus,\n        onPointerDown: handlePointerDown\n      })}\n      ref={rootRef}\n      role=\"grid\"\n      class={styles.baseStyle}\n      tabIndex={0}\n      aria-label={ariaLabel}\n      aria-labelledby={ariaLabelledBy}\n      aria-multiselectable={ariaMultiSelectable}\n      aria-rowcount={ariaRowcount}\n      aria-colcount={colCount}>\n      {data == null ? defaultLoadingIndicator(gridProps) : collectionComponent}\n    </div>\n  );\n}\n\nconst emptyKeys = { all: false, keys: new Set() };\n\n/**\n * A mapping of gutterSize to concrete size that can be passed into Grid component\n * (specifically, in the format of `${number}x`)\n */\nconst gutterSizeMappings: Record<string, number> = {\n  xs: 12,\n  sm: 16,\n  md: 24,\n  lg: 48,\n  xl: 64\n};\n\n// these are arbitrary values by now, might update them with definite values in the future\nconst DEFAULT_SKELETON_NUMBER = 25;\nconst DEFAULT_SKELETON_WIDTH = 260;\nconst DEFAULT_SKELETON_HEIGHT = 300;\n\n/**\n * A function that returns an array of skeletons based on count\n * @param count the number of skeletons\n */\nconst getSkeletonsByCount = (count: number, isUnique?: boolean, height?: number) =>\n  [...Array(count)].map(() => (\n    // this map function keeps generating the same copy of skeletons with same keys even with useId() hook,\n    // so combine id with time to make the key unique. create unique skeletons if needed, otherwise the\n    // animations won't start at the same time\n    <SkeletonContainer key={isUnique && useId() + new Date().getTime()} minimumCount={1}>\n      {() => {\n        return <Skeleton height={`calc(${height || DEFAULT_SKELETON_HEIGHT}px)` as Size} />;\n      }}\n    </SkeletonContainer>\n  ));\n\n/**\n * The default loading indicator will display 25 card skeletons\n * @param gridProps the Grid props\n */\nconst defaultLoadingIndicator = (gridProps: any) => (\n  <Grid {...gridProps}>{getSkeletonsByCount(DEFAULT_SKELETON_NUMBER)}</Grid>\n);\n\n/**\n * A function that will return the load more skeletons based on the number of columns and items, and return\n * the corresponding number of columns that is used to layout the skeletons.\n * @param gridProps the Grid props\n * @param totalCount the number of all items\n * @param colCount the number of columns in a row\n */\nconst findDefaultLoadMoreIndicator = (\n  gridProps: any,\n  totalCount: number,\n  colCount: number,\n  skeletonHeight: number\n): ComponentChildren => {\n  // if the number of columns is unknown, return nothing\n  if (!colCount) {\n    return undefined;\n  }\n\n  const skeletonGridProps = { ...gridProps };\n  if (colCount && !totalCount) {\n    skeletonGridProps.gridTemplateColumns = `repeat(auto-fit, ${DEFAULT_SKELETON_WIDTH}px)`;\n  }\n\n  const skeletons = [];\n  const gridColumns: number[] = [];\n\n  const firstCount = colCount - (totalCount % colCount);\n  if (firstCount > 0) {\n    const firstSkeletons = getSkeletonsByCount(firstCount, true, skeletonHeight);\n    skeletons.push(firstSkeletons);\n    gridColumns.push(firstCount);\n  }\n  const secondCount = colCount;\n  if (firstCount < secondCount) {\n    const secondSkeletons = getSkeletonsByCount(secondCount, true, skeletonHeight);\n    skeletons.push(secondSkeletons);\n    gridColumns.push(secondCount);\n  }\n\n  // only apply LOADMORE_STYLE_CLASS on the first row, to avoid onLoadMore\n  // get called multiple times\n  const skeletonRows = skeletons.map((s, i) => (\n    <div\n      {...(i == 0 && { class: LOADMORE_STYLE_CLASS })}\n      style={{ gridColumn: `span ${gridColumns[i]}` }}>\n      <Grid {...skeletonGridProps}>{s}</Grid>\n    </div>\n  ));\n  return skeletonRows;\n};\n\nconst getColCount = (gapWidth: number, cardWidth?: number, rootWidth?: number) => {\n  if (!cardWidth || !rootWidth) return 0;\n\n  // if we have n cards, we have n-1 gaps\n  const colCount = Math.floor((rootWidth + gapWidth) / (gapWidth + cardWidth));\n  return colCount;\n};\n"],"names":["ITEM_STYLE_CLASS","ITEM_SELECTOR","animationConfigSlide","index","animationStates","slideUp","from","translateY","to","options","duration","delay","easing","slideDown","isAnimatedOnMount","animationConfigOpacity","opacity","MemoizeCardGridItem","memo","children","itemKey","itemIndex","isTabbable","isFocused","isFocusRingVisible","isSelected","selectionMode","initialAnimation","setCardDimension","rootRef","useRef","variantClasses","multiVariantStyles","itemFocused","itemInitialOpacity","classes","classNames","styles","itemStyle","useLayoutEffect","firstCard","current","firstElementChild","width","offsetWidth","height","offsetHeight","nodeRef","nodeRefSlide","useAnimation","nodeRefOpacity","itemRefs","useMemo","mergeRefs","_jsx","id","useId","ref","class","role","onKeyDown","event","key","stopPropagation","undefined","TabbableModeContext","Provider","value","FocusTrap","isDisabled","restoreFocusRef","prev","next","itemData","emptyKeys","all","keys","Set","gutterSizeMappings","xs","sm","md","lg","xl","DEFAULT_SKELETON_WIDTH","getSkeletonsByCount","count","isUnique","Array","map","jsxRuntime","jsx","SkeletonContainer","minimumCount","Skeleton","Date","getTime","defaultLoadingIndicator","gridProps","Grid","findDefaultLoadMoreIndicator","totalCount","colCount","skeletonHeight","skeletonGridProps","gridTemplateColumns","skeletons","gridColumns","firstCount","firstSkeletons","push","secondCount","secondSkeletons","s","i","LOADMORE_STYLE_CLASS","style","gridColumn","getColCount","gapWidth","cardWidth","rootWidth","Math","floor","data","onLoadMore","hasMore","getRowKey","currentKey","onCurrentKeyChange","selectedKeys","onSelectionChange","viewportConfig","ariaLabel","ariaLabelledBy","gutterSize","anchorKey","pendingCurrentKey","isInitialAnimation","setColCount","useState","cardDimension","gutterSizePX","gap","ariaMultiSelectable","ariaRowcount","ceil","length","useEffect","handleColCount","useCallback","newColCount","root","handleResize","entries","entry","contentRect","resizeObserver","ResizeObserver","observe","unobserve","cardGridContains","elem","contains","pendingFocusRingChange","isCurrentTabbableKey","tabbableModeProps","useTabbableModeSet","element","keyExtractor","target","isKeyboardEvent","setTimeout","focus","currentKeyProps","useCurrentKey","getPrevNextKeyByCount","showFocusRing","focusRingProps","useCollectionFocusRing","findElementByKey","scrollIntoView","block","cell","closest","setAttribute","handleSelectionChange","detail","size","values","pop","handleSelectionRangeChange","handleSelectionRange","isArray","selectionProps","useSelection","isPrev","getItemContext","context","selectorRenderer","Selector","onChange","rowKey","metadata","selector","containsKey","getViewportConfig","collectionComponent","LoadMoreCollection","loadMoreIndicator","loadMoreThreshold","cardItemContext","cardGridFunc","mergeProps","onFocus","isKeyDefined","firstKey","getFirstVisibleKey","onPointerDown","baseStyle","tabIndex"],"mappings":"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"}