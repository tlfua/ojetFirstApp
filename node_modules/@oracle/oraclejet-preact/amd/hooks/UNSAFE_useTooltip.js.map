{"version":3,"file":"UNSAFE_useTooltip.js","sources":["../../../src/hooks/UNSAFE_useTooltip/TooltipContent.tsx","../../../src/hooks/UNSAFE_useTooltip/useTooltipControlled.tsx","../../../src/hooks/UNSAFE_useTooltip/useTooltip.tsx"],"sourcesContent":["import { useAnimation } from '../UNSAFE_useAnimation';\nimport { useComponentTheme } from '../UNSAFE_useComponentTheme';\nimport { useEffect, useRef } from 'preact/hooks';\nimport { HTMLAttributesSignalExcluded } from '../../utils/UNSAFE_attributeUtils';\nimport {\n  TooltipContentVariantOptions,\n  TooltipContentStyles\n} from './themes/TooltipContentStyles.css';\n\nimport { useThemeInterpolations } from '../UNSAFE_useThemeInterpolations';\nimport { classNames } from '../../utils/UNSAFE_classNames';\nimport { TooltipContentRedwoodTheme } from './themes/redwood/TooltipContentTheme';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'children'>;\n\ntype Status = 'mounted' | 'unmounted';\n\ntype ContentProps = IntrinsicProps & {\n  id: string;\n  isOpen: boolean;\n  isDatatip: boolean;\n  onTransitionEnd: () => void;\n};\n\nexport const TooltipContent = ({\n  children,\n  id,\n  isOpen,\n  isDatatip,\n  onTransitionEnd,\n  ...props\n}: ContentProps) => {\n  const wrapperRef = useRef<HTMLDivElement>(null);\n  const popoverRef = useRef<HTMLDivElement>(null);\n\n  const { classes, styles } = useComponentTheme<TooltipContentVariantOptions, TooltipContentStyles>(\n    TooltipContentRedwoodTheme,\n    {\n      variant: isDatatip ? 'datatip' : 'tooltip'\n    }\n  );\n\n  const schemeClass = useThemeInterpolations();\n\n  const { nodeRef } = useAnimation<Status, HTMLDivElement>(isOpen ? 'mounted' : 'unmounted', {\n    animationStates: {\n      mounted: (_node) => {\n        const childNode = _node.firstChild as HTMLDivElement;\n        return {\n          from: {\n            maxHeight: '0',\n            opacity: '0%'\n          },\n          to: {\n            maxHeight: `${childNode?.offsetHeight}px`,\n            opacity: isDatatip ? '100%' : '95%'\n          },\n          options: {\n            duration: isDatatip ? 1 : 100,\n            easing: [0.0, 0.0, 0.2, 1]\n          }\n        };\n      },\n      unmounted: (_node) => {\n        return {\n          from: {\n            opacity: isDatatip ? '100%' : '95%'\n          },\n          to: {\n            maxHeight: '0',\n            opacity: '0%'\n          },\n          options: {\n            duration: isDatatip ? 1 : 100,\n            easing: [0.0, 0.0, 0.2, 1]\n          }\n        };\n      }\n    },\n    isAnimatedOnMount: true,\n    onAnimationEnd: () => onTransitionEnd?.()\n  });\n\n  // Set up initial wrapper height so Tooltip can animate from the bottom to the top\n  useEffect(() => {\n    if (wrapperRef.current && popoverRef.current?.offsetHeight) {\n      wrapperRef.current.style.height = `${popoverRef.current?.offsetHeight}px`;\n    }\n  }, []);\n\n  return (\n    <div ref={wrapperRef} id={id} role=\"tooltip\" class={classNames([styles.wrapper, schemeClass])}>\n      <div ref={nodeRef} class={styles.inner} {...props}>\n        <div ref={popoverRef} class={classNames([classes, styles.content])}>\n          {children}\n        </div>\n      </div>\n    </div>\n  );\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { ComponentChild } from 'preact';\nimport { useState, useRef, useEffect, useLayoutEffect, useCallback } from 'preact/hooks';\nimport { useId } from '../UNSAFE_useId';\nimport { Floating, Placement, Coords } from '../../UNSAFE_Floating';\nimport { Layer } from '../../UNSAFE_Layer';\nimport { useHover } from '../UNSAFE_useHover';\nimport { useFocus } from '../UNSAFE_useFocus';\nimport { useTouch } from '../UNSAFE_useTouch';\nimport { mergeProps } from '../../utils/UNSAFE_mergeProps';\nimport { stringLiteralArray } from '../../utils/UNSAFE_arrayUtils';\nimport { TooltipContent } from './TooltipContent';\nimport { EnvironmentProvider } from '../../UNSAFE_Environment';\nimport { useColorScheme } from '../UNSAFE_useColorScheme';\n\nexport const positions = stringLiteralArray([\n  'start',\n  'top-start',\n  'top',\n  'top-end',\n  'end',\n  'bottom-end',\n  'bottom',\n  'bottom-start'\n]);\ntype Position = typeof positions[number];\n\nconst positionToPlacement = (position: Position) => {\n  let placement: Placement = 'bottom';\n\n  switch (position) {\n    case 'top':\n    case 'end':\n    case 'bottom':\n    case 'start':\n      placement = position as Placement;\n      break;\n\n    case 'top-end':\n      placement = 'top-end-corner';\n      break;\n\n    case 'bottom-end':\n      placement = 'bottom-end-corner';\n      break;\n\n    case 'bottom-start':\n      placement = 'bottom-start-corner';\n      break;\n\n    case 'top-start':\n      placement = 'top-start-corner';\n      break;\n  }\n\n  return placement;\n};\n\nexport const anchorTos = stringLiteralArray(['element', 'pointer']);\ntype AnchorTo = typeof anchorTos[number];\n\ntype AnchorModel = { x: AnchorTo; y: AnchorTo };\n\ntype Props = {\n  text?: string;\n  variant?: 'tooltip' | 'datatip';\n  isOpen: boolean;\n  position?: Position;\n  isDisabled?: boolean;\n  anchor?: AnchorModel;\n  offset?: { mainAxis?: number; crossAxis?: number };\n  onToggle?: (details: { value: boolean }) => void;\n};\n\n/**\n * The 'mounting' and 'unmounting' states are related to the animation. The 'unmounted' state\n * is used for conditional rendering. In this state, the Tooltip content is completely removed\n * from the DOM. The 'mountPending' and 'unmountPending' are used when timeout is active.\n * The 'reposition' state is used to trigger a transition with new coordinates within\n * the same element.\n */\ntype Status =\n  | 'unmounted'\n  | 'mountPending'\n  | 'mounting'\n  | 'mounted'\n  | 'unmountPending'\n  | 'unmounting';\n\nexport const useTooltipControlled = ({\n  text,\n  isOpen = false,\n  variant = 'tooltip',\n  position = 'bottom',\n  isDisabled = false,\n  anchor = { x: 'element', y: 'element' },\n  offset = { mainAxis: 0, crossAxis: 0 },\n  onToggle\n}: Props): {\n  tooltipContent: ComponentChild;\n  tooltipProps: Record<string, any>;\n} => {\n  const disabled = isDisabled || !text;\n  const isInitialRenderState = useRef<boolean>(true);\n  const hiddenWithEsc = useRef<boolean>(false);\n\n  const [state, setState] = useState<Status>(!disabled && isOpen ? 'mounting' : 'unmounted');\n  const [needsUpdate, setNeedsUpdate] = useState<boolean>(false);\n  setNeedsUpdate(false);\n\n  const isDatatip = variant === 'datatip';\n\n  const isInitialRenderTrigger = useRef<boolean>(true);\n  const { hoverProps, isHover } = useHover({});\n  const { touchProps, isTouch } = useTouch({ isDisabled }); // TODO replace by useLongPress actionhook\n  // we only care about keyboard focus, don't enable useFocus hook if isHover or isTouch are active\n  const { focusProps, isFocus } = useFocus({ isDisabled: isHover || isTouch });\n  const { hoverProps: popoverHoverProps, isHover: popoverIsHover } = useHover({ isDisabled });\n\n  const isPointer = anchor.x === 'pointer' || anchor.y === 'pointer';\n\n  const uniqueIdRef = useRef<string>(useId());\n  const targetRef = useRef<HTMLElement | null>(null);\n  const coordsRef = useRef<Coords>({ x: -9999, y: -9999 });\n  // if anchor is set to pointer and target does not have keyboard focus, use coords\n  const usedRef = isPointer && !isFocus ? coordsRef : targetRef;\n  const delay = isDatatip ? 0 : 250;\n  const toggleTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const updateTimeoutRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  const toggleTimeoutClear = () => {\n    if (toggleTimeoutRef.current) {\n      clearTimeout(toggleTimeoutRef.current);\n    }\n  };\n\n  const updateTimeoutClear = () => {\n    if (updateTimeoutRef.current) {\n      clearTimeout(updateTimeoutRef.current);\n    }\n  };\n\n  const updateState = useCallback(\n    (open: boolean) => {\n      if (open) {\n        // At least one toggle event is set to true\n        switch (state) {\n          case 'unmounting':\n          case 'unmounted':\n            setState('mountPending'); // Set mount pending state if tooltip is unmounted or in unmounting transition\n            break;\n          case 'unmountPending':\n            toggleTimeoutClear();\n            setState('mounted'); // Clear timers immediately and keep the tooltip mounted\n            break;\n        }\n      } else {\n        // No toggle events are set to true\n        switch (state) {\n          case 'mounting':\n          case 'mounted':\n            setState('unmountPending'); // Set unmount pending state if tooltip is mounted or in mounting transition\n            break;\n          case 'mountPending':\n            toggleTimeoutClear();\n            __resetCoords();\n            setState('unmounted'); // Unmount tooltip immediately if mounting is pending\n            break;\n        }\n      }\n    },\n    [state]\n  );\n\n  useEffect(() => {\n    if (isInitialRenderState.current) {\n      // On onitial render do not trigger rerender\n      isInitialRenderState.current = false;\n      return;\n    }\n    setState(isOpen ? 'mounting' : 'unmounting');\n  }, [isOpen]);\n\n  useEffect(() => {\n    if (isInitialRenderTrigger.current) {\n      // On onitial render do not trigger rerender\n      isInitialRenderTrigger.current = false;\n      return;\n    }\n    // When pointer is used, handleMouseMove method is responsible for state updates\n    // until the tooltip is mounted\n    if (isPointer && isHover && state === 'unmounted') {\n      return;\n    }\n    updateTimeoutClear();\n    // isHover and popoverIsHover may change rapidly as the pointer moves between the target\n    // and tooltip. Need to wait for changes to settle to avoid flashing.\n    updateTimeoutRef.current = setTimeout(() => {\n      updateState(isHover || (isFocus && !hiddenWithEsc.current) || popoverIsHover || isTouch);\n    }, 20);\n  }, [\n    isHover,\n    isFocus,\n    popoverIsHover,\n    isTouch,\n    isPointer,\n    state,\n    updateState,\n    hiddenWithEsc.current\n  ]);\n\n  /*\n   In some cases, several state transitions can occur at once. Due to the asynchronous nature\n   of hooks, this can create a race condition. For example, when the cursor leaves the target\n   element and immediately moves to the tooltip itself, the following sequence occurs:\n   1. isHover is set to false and a new render is triggered\n   2. The state is set to 'unmountPending' and a new render is triggered\n   3. Pending timeout is set\n   4. isHover is set to true and a new render is triggered\n   5. Pending timeout is cleared\n   However, sometimes the timeout is cleared before it is set. The useLayoutEffect prevents this\n   race condition by always scheduling the timeout synchronously.\n  */\n  useLayoutEffect(() => {\n    if (state === 'mountPending' || state === 'unmountPending') {\n      toggleTimeoutRef.current = setTimeout(\n        () => onToggle?.({ value: state === 'mountPending' }),\n        delay\n      );\n    }\n  }, [state, delay, onToggle]);\n\n  const handleMouseMove = (event: MouseEvent) => {\n    // we only want track mouse move while the state is 'unmounted' or when moving a 'mounted' datatip\n    if (state !== 'unmounted' && !(variant === 'datatip' && state === 'mounted')) {\n      return;\n    }\n    const targetRect = targetRef?.current?.getBoundingClientRect();\n\n    // Tooltip maintains static offset from left side of window\n    const distanceX = document.body.scrollLeft + (targetRect?.left || 0) + (targetRect?.width || 0);\n\n    // Tooltip maintains static offset from top side of the window\n    const distanceY = document.body.scrollTop + (targetRect?.top || 0) + (targetRect?.height || 0);\n\n    // Display tooltip at the mouse position if both anchors are set to pointer\n    const x = anchor.x === 'pointer' ? event.clientX : distanceX;\n    const y = anchor.y === 'pointer' ? event.clientY : distanceY;\n\n    if (state === 'mounted') {\n      coordsRef.current = { x, y };\n      if (needsUpdate !== true) setNeedsUpdate(true);\n    } else if (state === 'unmounted') {\n      toggleTimeoutClear();\n      toggleTimeoutRef.current = setTimeout(() => {\n        if (state === 'unmounted') {\n          coordsRef.current = { x, y };\n          onToggle?.({ value: true });\n        }\n      }, delay);\n    }\n  };\n\n  const focusInitProps = {\n    onFocus: useCallback(\n      (event: FocusEvent) => {\n        if (\n          event.eventPhase === Event.AT_TARGET ||\n          (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)\n        ) {\n          targetRef.current = event.target as HTMLElement;\n        }\n      },\n      [isDatatip]\n    ),\n\n    onBlur: useCallback((event: FocusEvent) => {\n      if (event.eventPhase === Event.AT_TARGET) {\n        hiddenWithEsc.current = false;\n      }\n    }, [])\n  };\n\n  const hoverInitProps = {\n    onMouseEnter: useCallback(\n      (event: MouseEvent) => {\n        if (\n          event.eventPhase === Event.AT_TARGET ||\n          (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)\n        ) {\n          targetRef.current = event.target as HTMLElement;\n        }\n      },\n      [isDatatip]\n    )\n  };\n\n  const keyInitProps = {\n    onKeyUp: useCallback(\n      (event: KeyboardEvent) => {\n        if (event.code === 'Escape') {\n          event.preventDefault();\n          hiddenWithEsc.current = true;\n          onToggle?.({ value: false });\n        }\n      },\n      [onToggle]\n    )\n  };\n\n  let actionableProps;\n\n  const __resetCoords = () => {\n    coordsRef.current = { x: -9999, y: -9999 };\n  };\n\n  if (disabled) {\n    actionableProps = mergeProps(hoverProps, focusProps, hoverInitProps, focusInitProps);\n  } else {\n    const anchorInitProps = {\n      'aria-describedby': uniqueIdRef.current,\n\n      ...(isPointer && {\n        onMouseLeave: () => {\n          if (state === 'mounting') {\n            return;\n          }\n          toggleTimeoutClear();\n        },\n        onMouseMove: (event: MouseEvent) => {\n          if (\n            event.eventPhase === Event.AT_TARGET ||\n            (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)\n          ) {\n            handleMouseMove(event);\n          }\n        }\n      })\n    };\n    actionableProps = mergeProps(\n      hoverProps,\n      focusProps,\n      touchProps,\n      hoverInitProps,\n      focusInitProps,\n      anchorInitProps,\n      keyInitProps\n    );\n  }\n\n  // No need to process tooltip if disabled or no text is provided\n  // Include actionableProps to detect mouseenter in components\n  // hovered state won't update unless actionableProps are already present in the component when mouse enters\n  if (disabled) {\n    toggleTimeoutClear();\n    __resetCoords();\n    return {\n      tooltipContent: null,\n      tooltipProps: actionableProps\n    };\n  }\n\n  const placement = positionToPlacement(position);\n\n  const handleTransitionEnd = () => {\n    if (state === 'mounting') {\n      setState('mounted');\n    }\n    if (state === 'unmounting') {\n      __resetCoords();\n      setState('unmounted');\n    }\n  };\n\n  const currentColorScheme = useColorScheme();\n  const newColorScheme = !currentColorScheme || currentColorScheme === 'light' ? 'dark' : 'light';\n\n  const renderRawContent = (\n    <TooltipContent\n      id={uniqueIdRef.current}\n      isOpen={['mounting', 'mounted', 'unmountPending'].includes(state)}\n      {...popoverHoverProps}\n      isDatatip={isDatatip}\n      onTransitionEnd={handleTransitionEnd}>\n      {text}\n    </TooltipContent>\n  );\n\n  const renderTooltipOrDatatip = () => {\n    if (variant === 'tooltip') {\n      return (\n        <EnvironmentProvider environment={{ colorScheme: newColorScheme }}>\n          {renderRawContent}\n        </EnvironmentProvider>\n      );\n    } else {\n      return <>{renderRawContent}</>;\n    }\n  };\n\n  const renderContent = (\n    <Layer logicalParentRef={targetRef}>\n      <Floating anchorRef={usedRef} placement={placement} offsetValue={offset}>\n        {renderTooltipOrDatatip()}\n      </Floating>\n    </Layer>\n  );\n\n  return {\n    tooltipContent: !['unmounted', 'mountPending'].includes(state) && renderContent,\n    tooltipProps: actionableProps\n  };\n};\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useState } from 'preact/hooks';\nimport { useTooltipControlled } from './useTooltipControlled';\n\nconst defaultOffset = 8; // Redwood tooltip has a default offset of 8 pixels\n\ntype tooltipParameters = Parameters<typeof useTooltipControlled>[0];\n\ntype Props = {\n  text?: string;\n  position?: tooltipParameters['position'];\n  isDisabled?: boolean;\n  anchor?: tooltipParameters['anchor'];\n  offset?: { mainAxis?: number; crossAxis?: number };\n  variant?: tooltipParameters['variant'];\n};\n\n/**\n * A hook with tooltip implementation.\n * Returns event handlers that can enhance the target element with a tooltip displayed\n * on hover and focus.\n *\n * @param text tooltip text\n * @param position tooltip placement relative to the target element\n * @param isDisabled determines if the tooltip is disabled\n * @param anchor determines if the target is an element or the pointer\n * @param offset offset from the placement\n * @param variant specifies if the rendered popup should have 'tooltip' or 'datatip' look and behavior\n * @returns an object with the 'tooltipContent' and 'tooltipProps' properties.\n */\nexport const useTooltip = ({\n  text,\n  position = 'bottom',\n  isDisabled = false,\n  anchor = { x: 'element', y: 'element' },\n  offset,\n  variant = 'tooltip'\n}: Props): ReturnType<typeof useTooltipControlled> => {\n  const [isOpen, setIsOpen] = useState<boolean>(false);\n  const disabled = isDisabled || !text;\n  const newOffset = offset ? offset : { mainAxis: defaultOffset, crossAxis: 0 };\n  const { tooltipContent, tooltipProps } = useTooltipControlled({\n    text,\n    isOpen,\n    position,\n    isDisabled: disabled,\n    offset: newOffset,\n    anchor,\n    variant,\n    onToggle: ({ value }) => setIsOpen(value)\n  });\n\n  return {\n    tooltipContent,\n    tooltipProps\n  };\n};\n"],"names":["TooltipContent","children","id","isOpen","isDatatip","onTransitionEnd","props","wrapperRef","useRef","popoverRef","classes","styles","useComponentTheme","TooltipContentRedwoodTheme","variant","schemeClass","useThemeInterpolations","nodeRef","useAnimation","animationStates","mounted","_node","childNode","firstChild","from","maxHeight","opacity","to","offsetHeight","options","duration","easing","unmounted","isAnimatedOnMount","onAnimationEnd","useEffect","current","style","height","_jsx","jsx","ref","role","class","classNames","wrapper","inner","content","useTooltipControlled","stringLiteralArray","text","position","isDisabled","anchor","x","y","offset","mainAxis","crossAxis","onToggle","disabled","isInitialRenderState","hiddenWithEsc","state","setState","useState","needsUpdate","setNeedsUpdate","isInitialRenderTrigger","hoverProps","isHover","useHover","touchProps","isTouch","useTouch","focusProps","isFocus","useFocus","popoverHoverProps","popoverIsHover","isPointer","uniqueIdRef","useId","targetRef","coordsRef","usedRef","delay","toggleTimeoutRef","updateTimeoutRef","toggleTimeoutClear","clearTimeout","updateState","useCallback","open","__resetCoords","setTimeout","useLayoutEffect","value","focusInitProps","onFocus","event","eventPhase","Event","AT_TARGET","BUBBLING_PHASE","target","onBlur","hoverInitProps","onMouseEnter","keyInitProps","onKeyUp","code","preventDefault","actionableProps","mergeProps","anchorInitProps","onMouseLeave","onMouseMove","targetRect","getBoundingClientRect","distanceX","document","body","scrollLeft","left","width","distanceY","scrollTop","top","clientX","clientY","handleMouseMove","tooltipContent","tooltipProps","placement","positionToPlacement","currentColorScheme","useColorScheme","newColorScheme","renderRawContent","includes","renderContent","Layer","logicalParentRef","Floating","anchorRef","offsetValue","EnvironmentProvider","environment","colorScheme","_Fragment","Fragment","setIsOpen","newOffset"],"mappings":"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"}