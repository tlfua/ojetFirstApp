{"version":3,"file":"Floating-86f9017c.js","sources":["../../src/UNSAFE_Floating/FloatingTail.tsx","../../src/UNSAFE_Floating/Floating.tsx"],"sourcesContent":["import { forwardRef, ForwardedRef } from 'preact/compat';\nimport { useMemo, useLayoutEffect, useRef, useState } from 'preact/hooks';\nimport { RefObject } from 'preact';\nimport { PositionData, Coords } from './Floating.types';\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { FloatingStyles } from './themes/FloatingStyles.css';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport type { ColorProps } from '../utils/UNSAFE_interpolations/colors';\nimport { Property } from 'csstype';\nimport { rgba } from '../UNSAFE_Theme/utils';\nimport { colorSchemeVars } from '../Common/themes/themeContract.css';\nimport { FloatingRedwoodTheme } from './themes/redwood/FloatingTheme';\n\ntype Props = Pick<ColorProps, 'backgroundColor'> & {\n  data?: PositionData;\n  anchorRef: RefObject<Element | Coords>;\n  tail: 'none' | 'simple';\n  isRtl: boolean;\n};\n\nconst ARROW_SIZE = 7;\nconst ARROW_SIZE_CORNER = 6;\nconst ARROW_INNER_SIZE = 5;\nconst ARROW_INNER_SIZE_CORNER = 5;\n\nconst FloatingTail = forwardRef(\n  (\n    { data, anchorRef, tail, isRtl, backgroundColor }: Props,\n    ref: ForwardedRef<HTMLDivElement | null>\n  ) => {\n    const { styles, baseTheme } = useComponentTheme<never, FloatingStyles>(FloatingRedwoodTheme);\n    const { baseStyle } = styles;\n    const arrowRef = useRef<HTMLDivElement | null>(null);\n    const [arrowStyles, setArrowStyles] = useState({\n      arrowStyle: { visibility: 'hidden' },\n      arrowInnerStyle: { visibility: 'hidden' }\n    });\n\n    useLayoutEffect(() => {\n      if (arrowRef.current == null) return;\n      const { isCornerVerticalPlacement, isCornerHorizontalPlacement } = isCorner(\n        anchorRef,\n        tail,\n        data\n      );\n      setArrowStyles(\n        setStyles(\n          tail,\n          isRtl,\n          isCornerVerticalPlacement,\n          isCornerHorizontalPlacement,\n          data,\n          backgroundColor\n        )\n      );\n    }, [data?.placement, data?.x, data?.y, data?.offset, data?.arrow, tail, isRtl, anchorRef]);\n\n    const stableRef = useMemo(() => mergeRefs(ref, arrowRef), [ref, arrowRef]);\n    return (\n      tail === 'simple' && (\n        <div\n          ref={stableRef}\n          class={classNames([baseTheme, baseStyle])}\n          style={arrowStyles.arrowStyle}>\n          {' '}\n          {/*Outer arrow - shadow*/}\n          <div class={classNames([baseStyle])} style={arrowStyles.arrowInnerStyle}></div>{' '}\n          {/*Inner arrow - body*/}\n        </div>\n      )\n    );\n  }\n);\n\nfunction isCorner(\n  anchorRef: RefObject<Element | Coords>,\n  tail: 'none' | 'simple',\n  data?: PositionData\n) {\n  if (tail === 'simple' && data && data.arrow) {\n    const { centerOffset } = data.arrow;\n    const arrowSize = ARROW_SIZE;\n    let anchorRefHeight = 0;\n    let anchorRefWidth = 0;\n    const current = anchorRef.current;\n    // @ts-ignore. Type 'Element | Coords' issues\n    // Property 'x' does not exist on type 'Element'.\n    // Property 'y' does not exist on type 'Element'.\n    const isAnchorRefElement = current?.x === undefined && current?.y === undefined;\n    if (isAnchorRefElement) {\n      // @ts-ignore. Property 'getBoundingClientRect' does not exist on type 'Coords'.\n      anchorRefHeight = Math.round(current.getBoundingClientRect().height);\n      // @ts-ignore. Property 'getBoundingClientRect' does not exist on type 'Coords'.\n      anchorRefWidth = Math.round(anchorRef.current?.getBoundingClientRect().width);\n    }\n    const isCornerVerticalPlacement = isAnchorRefElement\n      ? Math.abs(centerOffset) >= anchorRefHeight / 2 - arrowSize / 2\n      : ['start-top-corner', 'start-bottom-corner', 'end-top-corner', 'end-bottom-corner'].includes(\n          data.origPlacement\n        );\n    const isCornerHorizontalPlacement = isAnchorRefElement\n      ? Math.abs(centerOffset) >= anchorRefWidth / 2 - arrowSize / 2\n      : ['top-start-corner', 'top-end-corner', 'bottom-start-corner', 'bottom-end-corner'].includes(\n          data.origPlacement\n        );\n\n    return { isCornerVerticalPlacement, isCornerHorizontalPlacement };\n  } else return { isCornerVerticalPlacement: false, isCornerHorizontalPlacement: false };\n}\n\nfunction setStyles(\n  //arrowEl: HTMLDivElement,\n  tail: 'none' | 'simple',\n  isRtl: boolean,\n  isCornerVerticalPlacement: boolean,\n  isCornerHorizontalPlacement: boolean,\n  data?: PositionData,\n  backgroundColor?: Property.BackgroundColor\n) {\n  const result = { visibility: 'visible' };\n  const innerResult = { visibility: 'visible' };\n  if (tail === 'simple' && data && data.arrow) {\n    const { x, y, centerOffset } = data.arrow;\n    const arrowSize = ARROW_SIZE;\n    const arrowSizeCorner = ARROW_SIZE_CORNER;\n    //const arrowInnerEl = arrowEl.querySelector('div') as Element;\n    const arrowInnerSize = ARROW_INNER_SIZE;\n    const arrowInnerSizeCorner = ARROW_INNER_SIZE_CORNER;\n\n    const isCenter = centerOffset === 0;\n    const isCenterOffsetPositive = centerOffset > 0;\n\n    // Set sizes of the arrow\n    setArrowSizes(isCornerVerticalPlacement || isCornerHorizontalPlacement);\n\n    // Corner vs. normal arrow\n    function setArrowSizes(isCornerPlacement?: boolean) {\n      // Outer arrow (shadow)\n      const arrowFinalSize = isCornerPlacement ? arrowSizeCorner : arrowSize;\n      setArrowStyle(\n        {\n          // Tracked: \n          borderTop: `${getSize(arrowFinalSize)} solid ${rgba(\n            colorSchemeVars.palette.neutral[90],\n            0.1\n          )}`,\n          borderRight: getTransparentBorder(arrowFinalSize),\n          borderLeft: getTransparentBorder(arrowFinalSize)\n        },\n        result\n      );\n      // Inner arrow\n      const arrowInnerFinalSize = isCornerPlacement ? arrowInnerSizeCorner : arrowInnerSize;\n      setArrowInnerStyle(\n        {\n          // Tracked: \n          borderTop: `${getSize(arrowInnerFinalSize)} solid ${backgroundColor}`,\n          borderRight: `${getTransparentBorder(arrowInnerFinalSize)}`,\n          borderLeft: `${getTransparentBorder(arrowInnerFinalSize)}`\n        },\n        innerResult\n      );\n    }\n\n    function setArrowStyle(style: object, result: object) {\n      Object.assign(result, style);\n    }\n\n    function setArrowInnerStyle(style: object, result: object) {\n      Object.assign(result, style);\n    }\n\n    function getTurn(eighth: number) {\n      return `rotate(${eighth * 45}deg)`;\n    }\n\n    function getSize(size: number) {\n      return `${size}px`;\n    }\n\n    function getTransparentBorder(size: number) {\n      return `${getSize(size)} solid transparent`;\n    }\n\n    const placementArr = data.placement.split('-');\n    const side = placementArr[0];\n\n    switch (side) {\n      case 'top':\n        setArrowTop();\n        break;\n      case 'end':\n        isRtl ? setArrowStart() : setArrowEnd();\n        break;\n      case 'bottom':\n        setArrowBottom();\n        break;\n      case 'start':\n        isRtl ? setArrowEnd() : setArrowStart();\n        break;\n    }\n\n    function setArrowTop() {\n      if (x != undefined) {\n        if (isCornerHorizontalPlacement) {\n          // Top corners\n          setArrowStyle(\n            {\n              top: '', // flip 'reset'\n              bottom: getSize(-arrowSize + 2),\n              left: getSize(x + (isCenterOffsetPositive ? 5 : -5)),\n              transform: getTurn(isCenterOffsetPositive ? 5 : 3)\n            },\n            result\n          );\n          setCornerArrowInner();\n        } else {\n          setArrowStyle(\n            {\n              top: '', // flip 'reset'\n              bottom: getSize(-arrowSize),\n              left: isCenter ? getSize(x) : getSize(x + (isCenterOffsetPositive ? 1 : -1)),\n              transform: getTurn(0)\n            },\n            result\n          );\n          setNonCornerArrowInner();\n        }\n      }\n    }\n\n    function setArrowEnd() {\n      if (y != undefined) {\n        if (isCornerVerticalPlacement) {\n          // End corners\n          setArrowStyle(\n            {\n              top: getSize(y + (isCenterOffsetPositive ? 2 : -2)),\n              right: '', // flip 'reset'\n              left: getSize(-arrowSize - 1),\n              transform: getTurn(isCenterOffsetPositive ? 7 : 5)\n            },\n            result\n          );\n          setCornerArrowInner();\n        } else {\n          // End\n          setArrowStyle(\n            {\n              top: isCenter ? getSize(y) : getSize(y + (isCenterOffsetPositive ? -2 : +2)),\n              right: '', // flip 'reset'\n              left: getSize(-arrowSize * 1.5),\n              transform: getTurn(2)\n            },\n            result\n          );\n          setNonCornerArrowInner();\n        }\n      }\n    }\n\n    function setArrowBottom() {\n      if (x != undefined) {\n        if (isCornerHorizontalPlacement) {\n          // Bottom corners\n          setArrowStyle(\n            {\n              top: getSize(-arrowSize + 3),\n              bottom: '', // flip 'reset'\n              left: getSize(x + (isCenterOffsetPositive ? 4 : -4)),\n              transform: getTurn(isCenterOffsetPositive ? 2 : 6)\n            },\n            result\n          );\n          setArrowInnerStyle(\n            {\n              top: getSize(-arrowInnerSize),\n              left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? 1 : -1))\n            },\n            innerResult\n          );\n        } else {\n          setArrowStyle(\n            {\n              top: getSize(-arrowSize),\n              bottom: '', // flip 'reset'\n              left: isCenter ? getSize(x) : getSize(x + (isCenterOffsetPositive ? 1 : -1)),\n              transform: getTurn(4)\n            },\n            result\n          );\n          setNonCornerArrowInner();\n        }\n      }\n    }\n\n    function setArrowStart() {\n      if (y != undefined) {\n        if (isCornerVerticalPlacement) {\n          // Start corners\n          setArrowStyle(\n            {\n              top: getSize(y + (isCenterOffsetPositive ? 2 : -2)),\n              right: getSize(-arrowSize - 1),\n              left: '', // flip 'reset'\n              transform: getTurn(isCenterOffsetPositive ? 1 : 3)\n            },\n            result\n          );\n          setArrowInnerStyle(\n            {\n              top: getSize(-arrowInnerSize),\n              left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? -2 : 2))\n            },\n            innerResult\n          );\n        } else {\n          // Start\n          setArrowStyle(\n            {\n              top: isCenter ? getSize(y) : getSize(y + (isCenterOffsetPositive ? -2 : +2)),\n              right: getSize(-arrowSize * 1.5),\n              left: '', // flip 'reset'\n              transform: getTurn(6)\n            },\n            result\n          );\n          setNonCornerArrowInner();\n        }\n      }\n    }\n\n    function setCornerArrowInner() {\n      setArrowInnerStyle(\n        {\n          top: getSize(-arrowInnerSize),\n          left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? 2 : -2))\n        },\n        innerResult\n      );\n    }\n\n    function setNonCornerArrowInner() {\n      setArrowInnerStyle(\n        {\n          top: getSize(-arrowInnerSize - 2),\n          left: getSize(-arrowInnerSize)\n        },\n        innerResult\n      );\n    }\n  }\n  return { arrowStyle: result, arrowInnerStyle: innerResult };\n}\n\nexport { FloatingTail };\n","import { RefObject } from 'preact';\nimport { useLayoutEffect, useEffect, useMemo, useState, useRef, useCallback } from 'preact/hooks';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { autoUpdate, arrow } from '@floating-ui/dom';\nimport {\n  useFloating,\n  shift,\n  flip,\n  size,\n  offset,\n  limitShift,\n  VirtualElement,\n  logicalSide\n} from '../hooks/PRIVATE_useFloating';\nimport { Offset, Placement, Coords, PositionData } from './Floating.types';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { useOutsideClick } from '../hooks/UNSAFE_useOutsideClick';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { FloatingTail } from './FloatingTail';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { floatingStyle, floatingVisibilityStyles } from './themes/FloatingStyles.css';\nimport { assignInlineVars } from '@vanilla-extract/dynamic';\nimport { floatingVars } from './themes/FloatingContract.css';\nimport type { ColorProps } from '../utils/UNSAFE_interpolations/colors';\n\ntype IntrinsicProps = Pick<HTMLAttributesSignalExcluded<HTMLDivElement>, 'children' | 'class'>;\n/**\n * Specifies the flipping behavior along the respective axis.\n */\nexport type FlipOptions = {\n  /**\n   * If set to true, enables collision detection on the main axis,\n   * which runs along the floating placement side.\n   */\n  mainAxis?: boolean;\n  /**\n   * If set to true, enables collision detection on the cross axis,\n   * which runs along the floating placement side.\n   */\n  crossAxis?: boolean;\n  /**\n   * Specifies an array of placements to try\n   * if the preferred initial placement doesn’t fit on the axes\n   * in which collision is detected.\n   */\n  fallbackPlacements?: Array<Placement>;\n};\n\n/**\n * Specifies the shift behavior along the respective axis.\n * When true, the floating element will shift to prevent overflow.\n */\nexport type ShiftOptions = {\n  /**\n   * main axis in which shifting is applied. Default <code>true</code>.\n   */\n  mainAxis?: boolean;\n  /**\n   * cross axis in which shifting is applied. Default <code>false</code>.\n   */\n  crossAxis?: boolean;\n};\n\n/**\n * This describes the virtual padding around the collision boundary (currently the view port).\n * This could be extended in the future,\n * i.e. property to define what is a boundary ( a view port, a document, some other html element)\n */\nexport type BoundaryOptions = {\n  padding?:\n    | number\n    | {\n        top: number;\n        right: number;\n        bottom: number;\n        left: number;\n      };\n};\n/**\n * Specifies the resizing behaviour for max-height and max-width of the floating component.\n * The floating element will change the size depending on the available space.\n * isMaxHeightAdjusted/isMaxWidthAdjusted - sets the max-height/max-width of the floating to the available space till the collision.\n * maxHeightCeiling/maxWidthCeiling - this is the limit for max-height/max-width that should not be exceeded, even if there is more available space till the collision.\n */\nexport type SizeOptions = {\n  isMaxWidthAdjusted?: boolean;\n  isMaxHeightAdjusted?: boolean;\n  maxHeightCeiling?: number;\n  maxWidthCeiling?: number;\n};\n\ntype Props = IntrinsicProps &\n  Pick<ColorProps, 'backgroundColor'> & {\n    /**\n     * <p>Placement of the floating element relative to its reference element.</p>\n     * <p>Placement consists of two parts, the first part is the side, the second is the alignment.</p>\n     * <p>Possible values are:</p>\n     * <p> <code>'top' </code> <code>'top-start' </code> <code> 'top-end' </code> <code> 'top-start-corner' </code> <code> 'top-end-corner' </code>\n     * <code> 'end' </code> <code> 'end-top'  </code> <code> 'end-bottom' </code> <code> 'end-top-corner' </code> <code> 'end-bottom-corner' </code>\n     * <code> 'bottom'  </code> <code> 'bottom-start'  </code> <code> 'bottom-end' </code> <code> 'bottom-start-corner' </code> <code> 'bottom-end-corner' </code>\n     * <code> 'start' </code> <code> 'start-top'  </code> <code> 'start-bottom' </code> <code> 'start-top-corner' </code> <code> 'start-bottom-corner' </code>\n     * </p>\n     */\n    placement?: Placement;\n\n    /**\n     * Trigger element reference.\n     */\n    anchorRef: RefObject<Element | Coords>;\n\n    /**\n     * Placement offset.\n     * Offset displaces the floating element from its core placement along the specified axes.\n     * Offset could be a number or an object\n     * A number represents the distance (gutter or margin) between the floating element and the reference element.\n     * This is shorthand for mainAxis.\n     * <pre>\n     *   {\n     *     mainAxis?: number;\n     *     crossAxis?: number;\n     *   }\n     * </pre>\n     * <p><code>mainAxis</code> - represents the distance (gutter or margin) between the floating element and the reference element.</p>\n     * <p><code>crossAxis</code> - represents the shifting between the floating element and the reference element.<p>\n     */\n    offsetValue?: Offset;\n\n    /**\n     * Click outside callback.\n     */\n    onClickOutside?: (event: MouseEvent) => void;\n\n    /**\n     * FlipOptions object\n     * <pre>\n     * type FlipOptions = {\n     *     mainAxis?: boolean;\n     *     crossAxis?: boolean;\n     *     fallbackPlacements?: Array<Placement>;\n     *   }\n     * </pre>\n     * <p>Specifies the flipping behavior along the respective axis.<p>\n     * <p><code>mainAxis</code> - If set to true, enables collision detection on the main axis, which runs along the floating placement side.\n     * Default is <code>true</code>.\n     * </p>\n     * <p><code>crossAxis</code> - If set to true, enables collision detection on the cross axis, which runs along the floating placement alignment.\n     * Default is <code>false</code>.\n     * </p>\n     * <p><code>fallbackPlacements</code> - specifies an array of placements to try if the preferred initial placement doesn’t fit on the axes in which collision is detected.\n     * The fallback placements will be tried in the order they are specified in the array.\n     * The following placements are allowed as values of the array:\n     * <code>'top'</code>, <code>'top-start'</code>, <code>'top-end'</code>, <code>'start'</code>, <code>'start-top'</code>, <code>'start-bottom'</code>, <code>'bottom'</code>,\n     * <code>'bottom-start'</code>, <code>'bottom-end'</code>, <code>'end'</code>, <code>'end-top'</code>, <code>'end-bottom'</code>.\n     * <p>\n     * If not specified, the default behaviour is to flip to the side <code>opposite</code> to the one in which collision is detected\n     * </p>\n     * </p>\n     */\n    flipOptions?: FlipOptions;\n\n    /**\n     * Specifies the shift behavior along the respective axis. When true, the floating element will shift to prevent overflow.\n     * <pre>\n     * type ShiftOptions = {\n     *  mainAxis?: boolean;\n     *  crossAxis?: boolean;\n     * };\n     * </pre>\n     * <p><code>mainAxis</code> - main axis in which shifting is applied. Default <code>true</code>.</p>\n     * <p><code>crossAxis</code> - cross axis in which shifting is applied. Default <code>false</code>.</p>\n     */\n    shiftOptions?: ShiftOptions;\n\n    /**\n     *  Triggered when placement or coordinates are changed after collision is detected\n     */\n    onPosition?: (data: PositionData) => void;\n\n    /**\n     * Tail\n     */\n    tail?: 'none' | 'simple';\n\n    /**\n     * Specifies the resizing behaviour for max-height and max-width of the floating component.\n     * <pre>\n     * type SizeOptions = {\n     *    isMaxWidthAdjusted?: boolean;\n     *    isMaxHeightAdjusted?: boolean;\n     *    maxHeightCeiling?: number;\n     *    maxWidthCeiling?: number;\n     *  }\n     * </pre>\n     * <p><code>isMaxHeightAdjusted</code> and <code>isMaxWidthAdjusted</code> - sets the max-height/max-width of the floating to the available space till the collision.\n     * When either of the options isMaxHeightAdjusted, isMaxWidthAdjusted is true, the floating element will change the size depending on the available space.\n     * Default values are <code>'false'</code>.</p>\n     * <p><code>maxHeightCeiling</code> and <code>maxWidthCeiling</code> - are maximal values that could not be exceeded.\n     * Defaults are undefined and it means to use full available width/height.</p>\n     */\n    sizeOptions?: SizeOptions;\n\n    /**\n     * <p>This describes the virtual padding around the collision boundary (currently the view port).</p>\n     * <p>This could be extended in the future,\n     * i.e. property to define what is a boundary\n     * ( a view port, a document, some other html element)</p>\n     * <pre>\n     * type BoundaryOptions = {\n     *  padding?: number | {\n     *    top: number;\n     *    right: number;\n     *    bottom: number;\n     *    left: number;\n     *  };\n     * }\n     * </pre>\n     * Default value for padding is 0.\n     */\n    boundaryOptions?: BoundaryOptions;\n  };\n\nfunction isElement(value: any): value is Element {\n  return value instanceof Element;\n}\n\n/**\n * A floating component allows the user to create a floating element that is displayed relative to an anchor element or pointer coordinates\n * and at the same time on the \"top layer\" of all other elements.\n * The Floating component is a base component and is often used by such components as Popup, Tooltip, SelectMultiple, Menu and other components.\n */\nexport const Floating = forwardRef(\n  (\n    {\n      children,\n      backgroundColor,\n      onClickOutside,\n      placement = 'bottom',\n      anchorRef,\n      offsetValue,\n      class: className,\n      tail = 'none',\n      flipOptions = { mainAxis: true, crossAxis: false },\n      shiftOptions = { mainAxis: true, crossAxis: false },\n      sizeOptions = { isMaxHeightAdjusted: false, isMaxWidthAdjusted: false },\n      boundaryOptions = { padding: 0 },\n      onPosition\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    const arrowRef = useRef<HTMLDivElement>(null);\n    const [positionData, setPositionData] = useState<PositionData>();\n\n    const [previousAnchor, setPreviousAnchor] = useState<Element | Coords | null>(null);\n\n    // we need to be sure anchorRef.current exists in first call\n    // to be able to set the previousAnchor state\n    useLayoutEffect(() => {\n      setPreviousAnchor(anchorRef.current);\n    }, []);\n\n    // In case anchorRef.current changes and we need to update floating position\n    // when it changes, we need to have copy in the state.\n    // For example when anchorRef is Coords( virtual element)\n    if (anchorRef.current !== previousAnchor) {\n      setPreviousAnchor(anchorRef.current);\n    }\n\n    const { direction } = useUser();\n    const isRtl = direction === 'rtl';\n\n    const _onPosition = useCallback(\n      (data: PositionData) => {\n        setPositionData(data);\n        onPosition?.(data);\n      },\n      [placement, anchorRef, tail, onPosition]\n    );\n\n    const middleware = [\n      offset(offsetValue),\n      flip({\n        mainAxis: flipOptions.mainAxis,\n        crossAxis: flipOptions.crossAxis,\n        fallbackPlacements: flipOptions.fallbackPlacements?.map((placement) =>\n          logicalSide(placement, direction)\n        ),\n        padding: boundaryOptions.padding\n      }),\n      shift({\n        mainAxis: shiftOptions.mainAxis,\n        crossAxis: shiftOptions.crossAxis,\n        limiter: limitShift({\n          mainAxis: shiftOptions.mainAxis,\n          crossAxis: shiftOptions.crossAxis\n        })\n      }),\n      ...(arrowRef.current\n        ? [\n            arrow({\n              element: arrowRef.current\n            })\n          ]\n        : [])\n    ];\n    if (sizeOptions.isMaxHeightAdjusted || sizeOptions.isMaxWidthAdjusted) {\n      middleware.push(\n        size({\n          apply({ availableWidth, availableHeight, elements }) {\n            if (sizeOptions.isMaxHeightAdjusted) {\n              if (parseInt(elements.floating.style.maxHeight) !== availableHeight) {\n                Object.assign(elements.floating.style, {\n                  maxHeight: `${Math.min(\n                    availableHeight,\n                    sizeOptions.maxHeightCeiling || availableHeight\n                  )}px`\n                });\n              }\n            }\n\n            if (sizeOptions.isMaxWidthAdjusted) {\n              if (parseInt(elements.floating.style.maxWidth) !== availableWidth) {\n                Object.assign(elements.floating.style, {\n                  maxWidth: `${Math.min(\n                    availableWidth,\n                    sizeOptions.maxWidthCeiling || availableWidth\n                  )}px`\n                });\n              }\n            }\n          },\n\n          padding: boundaryOptions.padding\n        })\n      );\n    }\n\n    const { x, y, reference, floating, refs, update } = useFloating({\n      placement: placement,\n      middleware: middleware,\n      onPosition: _onPosition\n    });\n\n    // To solve \"loop limit exceeds\" problem from the ResizeObserver in autoUpdate\n    // we need to make sure that we utilize autoUpdate function\n    // after the Floating component is positioned and has x, y coordinates.\n    const [isPositioned, setIsPositioned] = useState(false);\n\n    // here autoUpdate should be called only once during the Component lifecycle,\n    // if the floating, reference, placement and middleware do not change\n    useEffect(() => {\n      if (!refs.reference.current || !refs.floating.current || isPositioned !== true) {\n        return;\n      }\n\n      return autoUpdate(refs.reference.current, refs.floating.current, update);\n    }, [refs.floating, refs.reference, update, isPositioned]);\n\n    // here we should know when the Floating is positioned\n    useEffect(() => {\n      if (x != null && y != null) {\n        setIsPositioned(true);\n      }\n    }, [x, y]);\n\n    useOutsideClick({ isDisabled: false, ref: refs.floating, handler: onClickOutside });\n\n    useLayoutEffect(() => {\n      if (isElement(previousAnchor)) {\n        const element = previousAnchor as Element;\n        reference(element);\n        return;\n      }\n      const coords = previousAnchor as Coords;\n      const virtualEl: VirtualElement = {\n        getBoundingClientRect() {\n          return {\n            width: 0,\n            height: 0,\n            x: coords!.x,\n            y: coords!.y,\n            top: coords!.y,\n            left: coords!.x,\n            right: coords!.x,\n            bottom: coords!.y\n          };\n        }\n      };\n      if (coords && coords.x != null) {\n        reference(virtualEl);\n      }\n    }, [previousAnchor, reference]);\n\n    const stableRef = useMemo(() => mergeRefs(ref, floating), [ref, floating]);\n    const positionStyle = { top: y, left: x };\n\n    let assignedVars = {}; // empty var override unless background is specified\n    if (backgroundColor) {\n      assignedVars = assignInlineVars({\n        [floatingVars.backgroundColor]: backgroundColor\n      });\n    }\n\n    const visibilityStyles =\n      x == null && y == null ? floatingVisibilityStyles.hidden : floatingVisibilityStyles.visible;\n    const floatingClasses = classNames([className, floatingStyle, visibilityStyles]);\n    const content = (\n      <div class={floatingClasses} ref={stableRef} style={{ ...positionStyle, ...assignedVars }}>\n        {children}\n        <FloatingTail\n          ref={arrowRef}\n          backgroundColor={backgroundColor}\n          data={positionData}\n          anchorRef={anchorRef}\n          tail={tail}\n          isRtl={isRtl}\n        />\n      </div>\n    );\n    return content;\n  }\n);\n"],"names":["FloatingTail","forwardRef","data","anchorRef","tail","isRtl","backgroundColor","ref","styles","baseTheme","useComponentTheme","FloatingRedwoodTheme","baseStyle","arrowRef","useRef","arrowStyles","setArrowStyles","useState","arrowStyle","visibility","arrowInnerStyle","useLayoutEffect","current","isCornerVerticalPlacement","isCornerHorizontalPlacement","arrow","centerOffset","arrowSize","anchorRefHeight","anchorRefWidth","isAnchorRefElement","undefined","x","y","Math","round","getBoundingClientRect","height","width","abs","includes","origPlacement","isCorner","result","innerResult","arrowSizeCorner","arrowInnerSize","arrowInnerSizeCorner","isCenter","isCenterOffsetPositive","setArrowSizes","isCornerPlacement","arrowFinalSize","setArrowStyle","borderTop","getSize","rgba","colorSchemeVars","palette","neutral","borderRight","getTransparentBorder","borderLeft","arrowInnerFinalSize","setArrowInnerStyle","style","Object","assign","getTurn","eighth","size","placement","split","setArrowTop","setArrowStart","setArrowEnd","setArrowBottom","top","bottom","left","transform","setCornerArrowInner","setNonCornerArrowInner","right","setStyles","offset","stableRef","useMemo","mergeRefs","_jsxs","class","classNames","children","_jsx","Floating","onClickOutside","offsetValue","className","flipOptions","mainAxis","crossAxis","shiftOptions","sizeOptions","isMaxHeightAdjusted","isMaxWidthAdjusted","boundaryOptions","padding","onPosition","positionData","setPositionData","previousAnchor","setPreviousAnchor","direction","useUser","_onPosition","useCallback","middleware","flip","fallbackPlacements","map","logicalSide","shift","limiter","limitShift","element","push","apply","availableWidth","availableHeight","elements","parseInt","floating","maxHeight","min","maxHeightCeiling","maxWidth","maxWidthCeiling","reference","refs","update","useFloating","isPositioned","setIsPositioned","useEffect","autoUpdate","N","useOutsideClick","isDisabled","handler","Element","coords","virtualEl","positionStyle","assignedVars","assignInlineVars","floatingVars","visibilityStyles","floatingVisibilityStyles","hidden","visible","floatingClasses","floatingStyle"],"mappings":"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"}