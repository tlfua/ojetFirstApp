/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx } from 'preact/jsx-runtime';
import { useContext, useRef, useLayoutEffect, useState, useCallback } from 'preact/hooks';
import { navigationListStyles } from './UNSAFE_NavigationList/themes/NavigationListStyles.css.js';
import { keyExtractor, getPrevNextKey } from './utils/PRIVATE_collectionUtils.js';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { useCollectionFocusRing } from './hooks/PRIVATE_useCollectionFocusRing.js';
import { useCurrentKey } from './hooks/PRIVATE_useCurrentKey.js';
import './UNSAFE_Text.js';
import { usePress } from './hooks/UNSAFE_usePress.js';
import './utils/UNSAFE_classNames.js';
import { useInteractionStyle } from './hooks/UNSAFE_useInteractionStyle.js';
import { useComponentTheme } from './hooks/UNSAFE_useComponentTheme.js';
import { createContext } from 'preact';
import { mergeInterpolations } from './utils/UNSAFE_mergeInterpolations.js';
import './utils/UNSAFE_interpolations/flexitem.js';
import { NavigationListItemRedwoodTheme } from './UNSAFE_NavigationList/themes/redwood/NavigationListItemTheme.js';
import { f as flexitemInterpolations } from './flexitem-89d8a00a.js';
import { c as classNames } from './classNames-f414daad.js';
import { T as Text } from './Text-0dad47bb.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Context used to pass navlist information without having to pass it to navlist children props.
 * We want to communicate information down to any interested navlist item children.
 */
const NavigationListContext = createContext(null);

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Utility hook for consuming the NavigationListContext
 *
 * @returns The value of NavigationListContext provider
 */
function useNavigationListContext() {
    return useContext(NavigationListContext);
}

//Little hook to run some function before first render
const useWillMount = (callback) => {
    const willMount = useRef(true);
    if (willMount.current) {
        willMount.current = false;
        callback();
    }
};
const flexItemStyleInterpolations = mergeInterpolations([
    ...Object.values(flexitemInterpolations)
]);
const { class: labelContainerFlexItemClasses, ...labelContainerFlexItemStyle } = flexItemStyleInterpolations({
    alignSelf: 'center'
});
// default style class for items in NavigationList
const ITEM_STYLE_CLASS = 'oj-c-navigationlist-item';
const ITEM_SELECTOR = '.' + ITEM_STYLE_CLASS;
function useNavigationListItem({ itemRef, itemKey }) {
    const { onSelectionChange, selection, currentKey, showFocusRing, containsActiveElement, firstItemRenderedKey, onCurrentKeyChange } = useNavigationListContext();
    //Selection and focus state
    const isCurrent = currentKey === itemKey;
    useWillMount(() => {
        if (currentKey === undefined &&
            firstItemRenderedKey &&
            firstItemRenderedKey.current === undefined) {
            firstItemRenderedKey.current = itemKey;
        }
    });
    const isSelected = selection === itemKey;
    //Styling
    const { interactionProps, applyPseudoHoverStyle, applyHoverStyle, applyActiveStyle } = useInteractionStyle();
    const { classes: listItemClasses, styles: { labelContainerClasses } } = useComponentTheme(NavigationListItemRedwoodTheme, {
        focusRing: showFocusRing ? 'isFocusRing' : 'notFocusRing',
        current: isCurrent ? 'isCurrent' : 'notCurrtent',
        selected: isSelected ? 'isSelected' : 'notSelected',
        hybridHover: applyHoverStyle ? 'isHybridHover' : 'notHybridHover',
        pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',
        active: applyActiveStyle ? 'isActive' : 'notActive'
    });
    useLayoutEffect(() => {
        //We just focus the item if the container is the active element
        if (containsActiveElement?.() && isCurrent) {
            itemRef?.current?.focus();
        }
    }, [isCurrent, containsActiveElement]);
    //Item handlers
    const handlePress = () => {
        onSelectionChange?.({ value: itemKey });
    };
    //Legacy navlist makes selection on keyDown, but since preact tabbar made selection after keyUp, will do the same
    //for preact navlist
    const { pressProps } = usePress(handlePress);
    // We have to update current key if there no initial selection
    const onFocus = () => {
        if (currentKey === undefined) {
            onCurrentKeyChange({ value: itemKey });
        }
    };
    const onFocusProps = { onFocus };
    return {
        itemHandlers: mergeProps(interactionProps, pressProps, onFocusProps),
        itemClasses: classNames([listItemClasses, ITEM_STYLE_CLASS]),
        isItemFocusable: isCurrent || (firstItemRenderedKey?.current === itemKey && currentKey === undefined)
            ? true
            : false,
        isSelected,
        labelContainerClasses: classNames([labelContainerClasses, labelContainerFlexItemClasses]),
        labelContainerStyle: labelContainerFlexItemStyle
    };
}

/*TODO: JET-58534. Create a hook to share some logic between navlist and tabbar. Hook will be used inside this one. */
function useNavigationList({ containerRef, selection }) {
    //Ref used to track if the first item was already rendered
    const firstItemRenderedKey = useRef();
    const [currentKey, setCurrentKey] = useState(selection);
    const onCurrentKeyChange = useCallback(({ value }) => {
        setCurrentKey(value);
    }, []);
    const { currentKeyProps } = useCurrentKey((element) => keyExtractor(element, ITEM_SELECTOR), false, getPrevNextKey(containerRef.current, currentKey, true, ITEM_SELECTOR), getPrevNextKey(containerRef.current, currentKey, false, ITEM_SELECTOR), undefined, undefined, currentKey, onCurrentKeyChange);
    const [showFocusRing, focusRingProps] = useCollectionFocusRing((elem) => {
        return !!containerRef.current?.contains(elem);
    }, ['ArrowUp', 'ArrowDown']);
    const containsActiveElement = useCallback(() => {
        return !!containerRef?.current?.contains(document.activeElement);
    }, []);
    return {
        firstItemRenderedKey,
        showFocusRing,
        currentKey,
        onCurrentKeyChange,
        containsActiveElement,
        containerHandlers: mergeProps(focusRingProps, currentKeyProps)
    };
}

function NavigationList({ children, selection, onSelectionChange, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelLedBy }) {
    const containerRef = useRef(null);
    const { firstItemRenderedKey, showFocusRing, currentKey, onCurrentKeyChange, containsActiveElement, containerHandlers } = useNavigationList({
        containerRef: containerRef,
        selection
    });
    return (jsx("ul", { "aria-label": ariaLabel, "aria-labelledby": ariaLabelLedBy, role: "listbox", ref: containerRef, tabIndex: children ? -1 : 0, ...containerHandlers, class: navigationListStyles.uListStyle, children: jsx(NavigationListContext.Provider, { value: {
                selection,
                onSelectionChange,
                onCurrentKeyChange,
                currentKey,
                showFocusRing,
                containsActiveElement,
                firstItemRenderedKey
            }, children: children }) }));
}

/*TODO: JET-58535. Add ripple effect when touching navigationListItem. */
function NavigationListItem({ itemKey, label }) {
    const itemRef = useRef(null);
    //Logic of the component handled here
    const { isItemFocusable, itemHandlers, itemClasses, isSelected, labelContainerClasses, labelContainerStyle } = useNavigationListItem({
        itemRef: itemRef,
        itemKey
    });
    return (jsx("li", { role: "option", ...itemHandlers, "data-oj-key": itemKey, class: itemClasses, tabIndex: isItemFocusable ? 0 : -1, "aria-selected": isSelected, ref: itemRef, children: label && (jsx("span", { class: labelContainerClasses, style: labelContainerStyle, children: jsx(Text, { size: "inherit", weight: "inherit", variant: "inherit", children: label }) })) }));
}

export { NavigationList as N, NavigationListItem as a };
//# sourceMappingURL=NavigationListItem-31410d7f.js.map
