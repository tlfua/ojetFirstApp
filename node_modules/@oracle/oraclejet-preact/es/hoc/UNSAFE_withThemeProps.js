/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx } from 'preact/jsx-runtime';
import { createRef } from 'preact';
import { forwardRef, useEffect } from 'preact/compat';
import { a as EnvironmentProvider } from '../index-f26154f2.js';
import { LIGHT_CLASS, DARK_CLASS, INVERT_CLASS, COLORSCHEME_DEPENDENT_CLASS, SCALE_SM_CLASS, SCALE_MD_CLASS, SCALE_LG_CLASS, SCALE_DEPENDENT_CLASS } from '../UNSAFE_Theme.js';
import '../Common.js';
import '../Common/themes.js';
import '../Common/themes/redwood/theme.js';
import '../Common/themes/themeContract.css.js';
import 'preact/hooks';
import '../utils-9a0cb8dc.js';

/**
 * Higher Order Component that allows you to wrap an existing component with an EnvironmentProvider
 * containing the desired colorScheme and scale context. The returned component contains all the props
 * of the wrapped component with the addition of the `colorScheme` and `scale` props.
 *
 * This should be used when nesting an alternate colorScheme (ie dark palette sub-form within a global light
 * palette). You can use this HOC instead of manually applying colorScheme classnames to DOM elements. This also
 * eliminates the need to add additional DOM wrapper elements.
 */
const withThemeProps = (WrappedComponent) => {
    const displayName = WrappedComponent.displayName || WrappedComponent.name || 'ComponentWithProvider';
    const ComponentWithProvider = forwardRef(({ colorScheme, scale, ...props }, ref) => {
        // if no ref is supplied, create one
        const wrapRef = (ref || createRef());
        useEffect(() => {
            if (wrapRef.current) {
                const { classList } = wrapRef.current;
                if (!classList)
                    return;
                // dynamically apply the appropriate colorscheme classname to ref element
                if (colorScheme) {
                    const schemes = [
                        LIGHT_CLASS,
                        DARK_CLASS,
                        INVERT_CLASS,
                        COLORSCHEME_DEPENDENT_CLASS
                    ];
                    schemes.map((current) => classList.remove(current));
                    if (colorScheme === 'dark') {
                        classList.add(DARK_CLASS);
                        classList.add(INVERT_CLASS);
                    }
                    else {
                        classList.add(LIGHT_CLASS);
                    }
                    classList.add(COLORSCHEME_DEPENDENT_CLASS);
                }
                // dynamically apply the appropriate scale classname to ref element
                if (scale) {
                    const scales = [SCALE_SM_CLASS, SCALE_MD_CLASS, SCALE_LG_CLASS, SCALE_DEPENDENT_CLASS];
                    scales.map((current) => classList.remove(current));
                    classList.add(`${scale === 'sm' ? SCALE_SM_CLASS : scale === 'md' ? SCALE_MD_CLASS : SCALE_LG_CLASS}`);
                    classList.add(SCALE_DEPENDENT_CLASS);
                }
            }
        }, [wrapRef, colorScheme]);
        // wrap component with new colorscheme context
        return (jsx(EnvironmentProvider, { environment: { colorScheme, scale }, children: jsx(WrappedComponent, { ...props, ref: wrapRef }) }));
    });
    ComponentWithProvider.displayName = `withThemeProps(${displayName})`;
    return ComponentWithProvider;
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { withThemeProps };
//# sourceMappingURL=UNSAFE_withThemeProps.js.map
