/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx } from 'preact/jsx-runtime';
import { useRef, useLayoutEffect, useMemo, useState, useEffect, useCallback } from 'preact/hooks';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { isKeyDefined, containsKey } from './utils/UNSAFE_keys.js';
import { keyExtractor, getPrevNextKeyByCount, getFirstVisibleKey, findElementByKey, handleSelectionRange, getViewportConfig } from './utils/PRIVATE_collectionUtils.js';
import { useId } from './hooks/UNSAFE_useId.js';
import { useCurrentKey } from './hooks/PRIVATE_useCurrentKey.js';
import { useCollectionFocusRing } from './hooks/PRIVATE_useCollectionFocusRing.js';
import { useTabbableModeSet } from './hooks/PRIVATE_useTabbableModeSet.js';
import { useSelection } from './hooks/PRIVATE_useSelection.js';
import { Grid } from './UNSAFE_Grid.js';
import { Selector } from './UNSAFE_Selector.js';
import './UNSAFE_Skeleton.js';
import { S as SkeletonContainer } from './SkeletonContainer-8f229433.js';
import './PRIVATE_LoadMoreCollection.js';
import { memo } from 'preact/compat';
import './utils/UNSAFE_classNames.js';
import { mergeRefs } from './utils/PRIVATE_refUtils.js';
import './hooks/UNSAFE_useAnimation.js';
import { TabbableModeContext } from './hooks/UNSAFE_useTabbableMode.js';
import './UNSAFE_FocusTrap.js';
import { multiVariantStyles, styles } from './UNSAFE_CardGrid/themes/CardGridStyles.css.js';
import { c as classNames } from './classNames-f414daad.js';
import { u as useAnimation } from './useAnimation-50c5f5fb.js';
import { F as FocusTrap } from './FocusTrap-9dc31155.js';
import { L as LoadMoreCollection, a as LOADMORE_STYLE_CLASS } from './LoadMoreCollection-213ad68a.js';
import { S as Skeleton } from './Skeleton-18c022d9.js';

const ITEM_STYLE_CLASS = 'oj-cardgrid-item';
const ITEM_SELECTOR = '.' + ITEM_STYLE_CLASS;
/**
 * The internal component used to render a single item in CardGrid.
 */
function CardGridItem({ children, itemKey, itemIndex, isTabbable, isFocused, isFocusRingVisible, isSelected, selectionMode, initialAnimation, setCardDimension }) {
    const rootRef = useRef(null);
    const variantClasses = multiVariantStyles({
        itemFocused: isFocused && isFocusRingVisible ? 'isItemFocused' : 'isNotItemFocused',
        itemInitialOpacity: initialAnimation ? 'isTransparent' : 'isNotTransparent'
    });
    const classes = classNames([ITEM_STYLE_CLASS, styles.itemStyle, variantClasses]);
    // don't bubble Arrow Up/Down/Left/Right events to parent when in isTabbable mode
    // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.
    const handleKeyDown = (event) => {
        if (isTabbable &&
            (event.key === 'ArrowDown' ||
                event.key === 'ArrowUp' ||
                event.key === 'ArrowLeft' ||
                event.key === 'ArrowRight')) {
            event.stopPropagation();
        }
    };
    useLayoutEffect(() => {
        const firstCard = rootRef.current?.firstElementChild;
        if (setCardDimension && firstCard) {
            setCardDimension({ width: firstCard.offsetWidth, height: firstCard.offsetHeight });
        }
    }, []);
    // todo: issue track in JET-57681, we currently have two useAnimation() because the opacity and
    // slide up/down have different durations, and the current API couldn't handle this case, we will
    // update this once the API is updated
    // animation for slide up/down
    const { nodeRef: nodeRefSlide } = useAnimation(initialAnimation || 'none', animationConfigSlide(itemIndex));
    // animation for opacity change
    const { nodeRef: nodeRefOpacity } = useAnimation((initialAnimation && 'opacity') || 'none', animationConfigOpacity(itemIndex));
    const itemRefs = useMemo(() => mergeRefs(rootRef, nodeRefSlide, nodeRefOpacity), 
    // spot an issue when we click the cards during animation is processing, the cards would not finish
    // the current animations and stay as what it is, e.g. leave itself as half transparent.
    // add initialAnimation to the dependency to prevent this issue.
    [rootRef, nodeRefSlide, nodeRefOpacity, initialAnimation]);
    return (jsx("div", { id: useId(), ref: itemRefs, class: classes, role: "gridcell", "data-oj-key": itemKey, onKeyDown: handleKeyDown, "aria-selected": selectionMode === 'none' ? undefined : isSelected, ...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' }), children: jsx(TabbableModeContext.Provider, { value: { isTabbable }, children: jsx(FocusTrap, { isDisabled: !isTabbable, restoreFocusRef: false, children: children }) }) }));
}
const animationConfigSlide = (index) => {
    return {
        animationStates: {
            slideUp: {
                from: {
                    translateY: '50px'
                },
                to: {
                    translateY: '0px'
                },
                options: {
                    duration: 300,
                    delay: index * 50,
                    easing: [0, 0, 0.2, 1]
                }
            },
            slideDown: {
                from: {
                    translateY: '-50px'
                },
                to: {
                    translateY: '0'
                },
                options: {
                    duration: 300,
                    delay: index * 50,
                    easing: [0, 0, 0.2, 1]
                }
            }
        },
        isAnimatedOnMount: true
    };
};
const animationConfigOpacity = (index) => {
    return {
        animationStates: {
            opacity: {
                from: {
                    opacity: 0
                },
                to: {
                    opacity: 1
                },
                options: {
                    duration: 150,
                    delay: index * 50,
                    easing: 'linear'
                }
            }
        },
        isAnimatedOnMount: true
    };
};
const MemoizeCardGridItem = memo(CardGridItem, (prev, next) => {
    if (prev && next) {
        return (prev.itemKey === next.itemKey &&
            prev.itemIndex === next.itemIndex &&
            prev.itemData === next.itemData &&
            prev.isTabbable === next.isTabbable &&
            prev.isFocused === next.isFocused &&
            prev.isFocusRingVisible === next.isFocusRingVisible &&
            prev.isSelected === next.isSelected &&
            prev.initialAnimation === next.initialAnimation);
    }
    return false;
});

function CardGrid({ children, data, onLoadMore = () => { }, hasMore = false, getRowKey, currentKey, onCurrentKeyChange, selectionMode = 'none', selectedKeys = emptyKeys, onSelectionChange, viewportConfig, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, initialAnimation = 'slideUp', gutterSize = 'sm' }) {
    const rootRef = useRef(null);
    // tracking the anchor key which is used for shift+click selection
    const anchorKey = useRef();
    // tracking pending current key in pointer down event
    const pendingCurrentKey = useRef();
    const isInitialAnimation = useRef(true);
    const [colCount, setColCount] = useState(0);
    const [cardDimension, setCardDimension] = useState({ width: 0, height: 0 });
    const gutterSizePX = gutterSizeMappings[gutterSize];
    const gap = `${gutterSizePX / 4}x`;
    const gridTemplateColumns = cardDimension.width
        ? `repeat(auto-fit, ${cardDimension.width}px)`
        : undefined;
    const gridProps = { gap, gridTemplateColumns };
    const ariaMultiSelectable = selectionMode === 'none' ? undefined : selectionMode === 'multiple';
    const ariaRowcount = hasMore || !data || colCount === 0 ? -1 : Math.ceil(data?.length / colCount);
    /*****************************************************************************************/
    /********************************* cardWidth and colCount ********************************/
    /*****************************************************************************************/
    // cards are fully rendered for the first time, only when cardWidth and colCount have defined and non-zero values
    // for the first time, so the initial animation should not happen until this render.
    useEffect(() => {
        if (cardDimension.width && colCount) {
            isInitialAnimation.current = false;
        }
    }, [cardDimension.width && colCount]);
    const handleColCount = useCallback((rootWidth) => {
        const newColCount = getColCount(gutterSizePX, cardDimension.width || DEFAULT_SKELETON_WIDTH, rootWidth);
        if (newColCount > 0) {
            setColCount(newColCount);
        }
    }, [gutterSizePX, cardDimension.width]);
    useEffect(() => {
        const root = rootRef?.current;
        if (root) {
            handleColCount(root.offsetWidth);
        }
    }, [handleColCount]);
    const handleResize = useCallback((entries) => {
        for (const entry of entries) {
            // update colCount during resize
            handleColCount(entry.contentRect.width);
        }
    }, [handleColCount]);
    /**
     * Set up resize observer and update the colCount, to ensure keyboard navigation is correct
     * after the resize
     */
    useEffect(() => {
        const root = rootRef.current;
        if (root) {
            const resizeObserver = new ResizeObserver((entries) => {
                handleResize(entries);
            });
            resizeObserver.observe(root);
            return () => {
                resizeObserver.unobserve(root);
            };
        }
        return undefined;
    }, [handleResize]);
    /*****************************************************************************************/
    /************************************* Tabbable Mode *************************************/
    /*****************************************************************************************/
    const cardGridContains = (elem) => {
        return !!rootRef.current?.contains(elem);
    };
    let pendingFocusRingChange = false;
    const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(cardGridContains, (element) => {
        return keyExtractor(element, ITEM_SELECTOR);
    }, currentKey, 
    // handle clean-up on disabling of the mode
    (target, isKeyboardEvent) => {
        if (cardGridContains(target)) {
            // delay focus reset for keyboard disable so focus is reset to CardGrid after the FocusTrap blur lifecycle completes.
            // pointer initiated changes will fire the onBlur organically and delaying the focus, just generates an unwanted second blur
            if (isKeyboardEvent) {
                // do not show a focus ring during this timeOut
                pendingFocusRingChange = true;
                setTimeout(() => {
                    rootRef.current?.focus();
                }, 0);
            }
            else {
                rootRef.current?.focus();
            }
        }
        // otherwise target is not in list (including body, which target should be null in that case)
    }, 
    // set currentKey when mode is enabled
    (key) => {
        onCurrentKeyChange && onCurrentKeyChange({ value: key });
    });
    /*****************************************************************************************/
    /********************************* Current Key and Focus *********************************/
    /*****************************************************************************************/
    const { currentKeyProps } = useCurrentKey((element) => keyExtractor(element, ITEM_SELECTOR), selectionMode !== 'multiple', 
    // init a function every time to make sure we pass in the latest colCount.current,
    // otherwise the new key might be wrong after resize
    () => getPrevNextKeyByCount(data, getRowKey, currentKey, -colCount), () => getPrevNextKeyByCount(data, getRowKey, currentKey, colCount), () => getPrevNextKeyByCount(data, getRowKey, currentKey, -1), () => getPrevNextKeyByCount(data, getRowKey, currentKey, 1), currentKey, onCurrentKeyChange);
    const [showFocusRing, focusRingProps] = useCollectionFocusRing(cardGridContains, [
        'ArrowUp',
        'ArrowDown',
        'ArrowLeft',
        'ArrowRight'
    ]);
    const handleInitialFocus = () => {
        if (!isKeyDefined(currentKey) &&
            onCurrentKeyChange &&
            isCurrentTabbableKey(undefined) &&
            rootRef.current) {
            const firstKey = pendingCurrentKey.current || getFirstVisibleKey(rootRef.current, ITEM_SELECTOR);
            if (isKeyDefined(firstKey)) {
                onCurrentKeyChange({ value: firstKey });
            }
        }
    };
    /**
     * Need to track pointer down element to set currentItem when initial focus happens
     */
    const handlePointerDown = (event) => {
        const key = keyExtractor(event.target, ITEM_SELECTOR);
        if (isKeyDefined(key)) {
            pendingCurrentKey.current = key;
        }
    };
    useEffect(() => {
        if (currentKey != null && rootRef.current) {
            const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);
            if (elem) {
                // make sure item is visible
                elem.scrollIntoView({ block: 'nearest' });
                const cell = elem.closest(`[role=gridcell]`);
                if (cell) {
                    // update aria-activedescendant for screen reader
                    rootRef.current.setAttribute('aria-activedescendant', cell.id);
                }
            }
        }
        // listen to data because the current item would re-render when data is updated, i.e. the id
        // of current item would be updated, so the currentKey itself couldn't guarantee the root has
        // the latest aria-activedescendant
    }, [currentKey, data]);
    /*****************************************************************************************/
    /*************************************** Selection ***************************************/
    /*****************************************************************************************/
    const handleSelectionChange = useCallback((detail) => {
        if (onSelectionChange) {
            if (detail.value.all === false && detail.value.keys.size > 0) {
                // the last key selected by a user gesture is the anchor key
                anchorKey.current = Array.from(detail.value.keys.values()).pop();
            }
            onSelectionChange(detail);
        }
    }, [anchorKey, onSelectionChange]);
    const handleSelectionRangeChange = useCallback((detail) => {
        if (data && onSelectionChange) {
            const value = handleSelectionRange(detail, data, getRowKey);
            // for non-virtualized CardGrid, value should always be an array
            if (Array.isArray(value)) {
                onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });
            }
        }
    }, [data, onSelectionChange, onLoadMore]);
    const { selectionProps } = useSelection((element) => {
        if (element === rootRef.current) {
            return currentKey === undefined ? null : currentKey;
        }
        return keyExtractor(element, ITEM_SELECTOR);
    }, selectedKeys, selectionMode, false, 'replace', false, handleSelectionChange, anchorKey.current, currentKey, (currentKey, isPrev) => () => getPrevNextKeyByCount(data, getRowKey, currentKey, isPrev ? -colCount : colCount), (currentKey, isPrev) => () => getPrevNextKeyByCount(data, getRowKey, currentKey, isPrev ? -1 : 1), (key) => {
        if (rootRef.current) {
            const elem = findElementByKey(rootRef.current, key, ITEM_SELECTOR);
            if (elem) {
                elem.scrollIntoView({ block: 'nearest' });
            }
        }
    }, handleSelectionRangeChange);
    /*****************************************************************************************/
    /************************************ Child Component ************************************/
    /*****************************************************************************************/
    const getItemContext = useCallback((context) => {
        const key = getRowKey(context.data);
        const selectorRenderer = selectionMode === 'multiple'
            ? () => (jsx(Selector, { onChange: onSelectionChange, rowKey: key, selectedKeys: selectedKeys }))
            : undefined;
        return {
            index: context.index,
            data: context.data,
            metadata: { key: key },
            selector: selectorRenderer,
            isSelected: containsKey(selectedKeys, key)
        };
    }, [selectionMode, selectedKeys, onSelectionChange]);
    const childrenComponent = (context) => {
        const cardItemContext = getItemContext(context);
        const isTabbable = isCurrentTabbableKey(cardItemContext.metadata.key);
        const isFocused = currentKey === cardItemContext.metadata.key && !isTabbable;
        const isFocusRingVisible = isFocused && showFocusRing && !pendingFocusRingChange;
        const isSelected = cardItemContext.isSelected;
        const cardGridFunc = (context) => (jsx(MemoizeCardGridItem, { itemKey: cardItemContext.metadata.key, itemIndex: cardItemContext.index, itemData: cardItemContext.data, isTabbable: isTabbable, isFocused: isFocused, isFocusRingVisible: isFocusRingVisible, isSelected: isSelected, selectionMode: selectionMode, ...(isInitialAnimation.current && { initialAnimation }), ...(context.index === 0 && { setCardDimension }), children: children(context) }, cardItemContext.metadata.key));
        return cardGridFunc(cardItemContext);
    };
    // todo: issue track in JET-57952, need a way to show the skeletons in keyboard navigation
    const skeletons = findDefaultLoadMoreIndicator(gridProps, data?.length || 0, colCount, cardDimension.height);
    viewportConfig = getViewportConfig(rootRef, viewportConfig);
    const collectionComponent = (jsx("div", { role: "row", children: jsx(Grid, { ...gridProps, children: jsx(LoadMoreCollection, { data: data, hasMore: hasMore, onLoadMore: onLoadMore, loadMoreIndicator: skeletons, loadMoreThreshold: gutterSizePX + 4, viewportConfig: viewportConfig, children: childrenComponent }) }) }));
    return (jsx("div", { ...mergeProps(tabbableModeProps, currentKeyProps, focusRingProps, selectionProps, {
            onFocus: handleInitialFocus,
            onPointerDown: handlePointerDown
        }), ref: rootRef, role: "grid", class: styles.baseStyle, tabIndex: 0, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-multiselectable": ariaMultiSelectable, "aria-rowcount": ariaRowcount, "aria-colcount": colCount, children: data == null ? defaultLoadingIndicator(gridProps) : collectionComponent }));
}
const emptyKeys = { all: false, keys: new Set() };
/**
 * A mapping of gutterSize to concrete size that can be passed into Grid component
 * (specifically, in the format of `${number}x`)
 */
const gutterSizeMappings = {
    xs: 12,
    sm: 16,
    md: 24,
    lg: 48,
    xl: 64
};
// these are arbitrary values by now, might update them with definite values in the future
const DEFAULT_SKELETON_NUMBER = 25;
const DEFAULT_SKELETON_WIDTH = 260;
const DEFAULT_SKELETON_HEIGHT = 300;
/**
 * A function that returns an array of skeletons based on count
 * @param count the number of skeletons
 */
const getSkeletonsByCount = (count, isUnique, height) => [...Array(count)].map(() => (
// this map function keeps generating the same copy of skeletons with same keys even with useId() hook,
// so combine id with time to make the key unique. create unique skeletons if needed, otherwise the
// animations won't start at the same time
jsx(SkeletonContainer, { minimumCount: 1, children: () => {
        return jsx(Skeleton, { height: `calc(${height || DEFAULT_SKELETON_HEIGHT}px)` });
    } }, isUnique && useId() + new Date().getTime())));
/**
 * The default loading indicator will display 25 card skeletons
 * @param gridProps the Grid props
 */
const defaultLoadingIndicator = (gridProps) => (jsx(Grid, { ...gridProps, children: getSkeletonsByCount(DEFAULT_SKELETON_NUMBER) }));
/**
 * A function that will return the load more skeletons based on the number of columns and items, and return
 * the corresponding number of columns that is used to layout the skeletons.
 * @param gridProps the Grid props
 * @param totalCount the number of all items
 * @param colCount the number of columns in a row
 */
const findDefaultLoadMoreIndicator = (gridProps, totalCount, colCount, skeletonHeight) => {
    // if the number of columns is unknown, return nothing
    if (!colCount) {
        return undefined;
    }
    const skeletonGridProps = { ...gridProps };
    if (colCount && !totalCount) {
        skeletonGridProps.gridTemplateColumns = `repeat(auto-fit, ${DEFAULT_SKELETON_WIDTH}px)`;
    }
    const skeletons = [];
    const gridColumns = [];
    const firstCount = colCount - (totalCount % colCount);
    if (firstCount > 0) {
        const firstSkeletons = getSkeletonsByCount(firstCount, true, skeletonHeight);
        skeletons.push(firstSkeletons);
        gridColumns.push(firstCount);
    }
    const secondCount = colCount;
    if (firstCount < secondCount) {
        const secondSkeletons = getSkeletonsByCount(secondCount, true, skeletonHeight);
        skeletons.push(secondSkeletons);
        gridColumns.push(secondCount);
    }
    // only apply LOADMORE_STYLE_CLASS on the first row, to avoid onLoadMore
    // get called multiple times
    const skeletonRows = skeletons.map((s, i) => (jsx("div", { ...(i == 0 && { class: LOADMORE_STYLE_CLASS }), style: { gridColumn: `span ${gridColumns[i]}` }, children: jsx(Grid, { ...skeletonGridProps, children: s }) })));
    return skeletonRows;
};
const getColCount = (gapWidth, cardWidth, rootWidth) => {
    if (!cardWidth || !rootWidth)
        return 0;
    // if we have n cards, we have n-1 gaps
    const colCount = Math.floor((rootWidth + gapWidth) / (gapWidth + cardWidth));
    return colCount;
};

export { CardGrid as C };
//# sourceMappingURL=CardGrid-48ba9654.js.map
