/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { useRef, useState, useCallback, useEffect, useContext, useLayoutEffect } from 'preact/hooks';
import { keyExtractor, getPrevNextKey } from './utils/PRIVATE_collectionUtils.js';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import './utils/UNSAFE_classNames.js';
import { useCollectionFocusRing } from './hooks/PRIVATE_useCollectionFocusRing.js';
import { useCurrentKey } from './hooks/PRIVATE_useCurrentKey.js';
import './UNSAFE_Flex.js';
import { useUser } from './hooks/UNSAFE_useUser.js';
import { styles } from './UNSAFE_TabBar/themes/TabBarStyles.css.js';
import { c as classNames } from './classNames-f414daad.js';
import { F as Flex } from './Flex-46adb0e4.js';
import { usePress } from './hooks/UNSAFE_usePress.js';
import './UNSAFE_Text.js';
import { createContext } from 'preact';
import { mergeInterpolations } from './utils/UNSAFE_mergeInterpolations.js';
import './utils/UNSAFE_interpolations/flexitem.js';
import { useComponentTheme } from './hooks/UNSAFE_useComponentTheme.js';
import { TabBarItemRedwoodTheme } from './UNSAFE_TabBar/themes/redwood/TabBarItemTheme.js';
import { f as flexitemInterpolations } from './flexitem-89d8a00a.js';
import { T as Text } from './Text-0dad47bb.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Context used to pass TabBar information without having to pass it to TabBar children props.
 * We want to communicate information down to any interested TabBar item children.
 */
const TabBarContext = createContext(null);

function TabBar({ children, layout = 'stretch', selection, onSelectionChange }) {
    const rootRef = useRef(null);
    const isFirstItemRendered = useRef(false);
    const [currentKey, setCurrentKey] = useState(selection);
    const [showFocusRing, focusRingProps] = useCollectionFocusRing((elem) => {
        return !!rootRef.current?.contains(elem);
    }, ['ArrowRight', 'ArrowLeft']);
    const ITEM_SELECTOR = '.' + 'oj-c-tabbar-item';
    const { currentKeyProps } = useCurrentKey((element) => keyExtractor(element, ITEM_SELECTOR), false, undefined, undefined, getPrevNextKey(rootRef.current, currentKey, true, ITEM_SELECTOR), getPrevNextKey(rootRef.current, currentKey, false, ITEM_SELECTOR), currentKey, (detail) => setCurrentKey(detail.value));
    //If selection is undefined the currentKey would be undefined in that case keyboard
    //navigation using useCurrentKey is not possible as it expects a valid currentKey
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const onKeyDown = useCallback((event) => {
        if (currentKey === undefined) {
            if (event.key === 'ArrowRight' || (!isRtl && event.key === 'ArrowLeft')) {
                const targetKey = event.target.getAttribute('data-oj-key');
                if (targetKey) {
                    const nextKey = getPrevNextKey(rootRef.current, targetKey, false, ITEM_SELECTOR)();
                    if (nextKey !== null) {
                        setCurrentKey(nextKey);
                    }
                }
            }
        }
    }, [currentKey]);
    const onKeyDownProps = { onKeyDown };
    useEffect(() => {
        isFirstItemRendered.current = false;
    });
    const isActiveElement = useCallback(() => {
        return !!rootRef?.current?.contains(document.activeElement);
    }, []);
    const tabBarClass = classNames([styles.tabBarBase]);
    return (jsx(TabBarContext.Provider, { value: {
            selection,
            onSelectionChange,
            currentKey,
            showFocusRing,
            layout,
            isActiveElement,
            isFirstItemRendered
        }, children: jsx("div", { class: tabBarClass, role: 'tablist', ref: rootRef, tabIndex: children ? -1 : 0, "aria-multiselectable": false, ...mergeProps(onKeyDownProps, currentKeyProps, focusRingProps), children: jsx(Flex, { direction: "row", gap: "8x", children: children }) }) }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * Licensed under The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Utility hook for consuming the TabBarContext
 *
 * @returns The value of TabBarContext provider
 */
function useTabBarContext() {
    return useContext(TabBarContext);
}

const ITEM_STYLE_CLASS = 'oj-c-tabbar-item';
function TabBarItem({ itemKey, label, startContent, endContent }) {
    const tabBarItemRef = useRef(null);
    const { onSelectionChange, selection, currentKey, showFocusRing, layout, isActiveElement, isFirstItemRendered } = useTabBarContext();
    const isCurrent = currentKey === itemKey;
    let tabIndex = isCurrent ? 0 : -1;
    //If currentKey is undefined, in order to tab to a TabBarItem, the first TabBarItem should set its tabindex to 0
    if (currentKey === undefined && isFirstItemRendered && !isFirstItemRendered.current) {
        tabIndex = 0;
        isFirstItemRendered.current = true;
    }
    //Selection
    const handlePress = () => {
        onSelectionChange?.({ value: itemKey });
    };
    const { pressProps } = usePress(handlePress);
    const isSelected = selection === itemKey;
    useLayoutEffect(() => {
        if (isActiveElement?.() && isCurrent) {
            tabBarItemRef?.current?.focus();
        }
    }, [isCurrent, isActiveElement]);
    const { classes, styles: { tabBarItemStartContent, tabBarItemEndContent } } = useComponentTheme(TabBarItemRedwoodTheme, {
        selection: isSelected ? 'isSelected' : 'notSelected',
        current: isCurrent ? 'isCurrent' : 'notCurrent',
        focusRing: showFocusRing ? 'showFocusRing' : 'noFocusRing'
    });
    const tabBarItem = classNames([classes, ITEM_STYLE_CLASS]);
    const tabBarItemStartContentClasses = classNames([tabBarItemStartContent]);
    const tabBarItemEndContentClasses = classNames([tabBarItemEndContent]);
    //instead of specifying flex: '1 0 auto' in cssProps var
    const styleInterpolations = mergeInterpolations([
        ...Object.values(flexitemInterpolations)
    ]);
    const flexDimensions = styleInterpolations({
        flex: layout === 'stretch' ? '1 0 auto' : '0 0 auto'
    });
    return (jsx("div", { "data-oj-key": itemKey, class: tabBarItem, role: "tab", ref: tabBarItemRef, ...pressProps, "aria-selected": isSelected, tabIndex: tabIndex, style: flexDimensions, children: jsxs(Flex, { height: "11x", minWidth: "14x", direction: "row", gap: "2x", align: "center", justify: "center", flex: "1 1 auto", children: [startContent && jsx("span", { class: tabBarItemStartContentClasses, children: startContent }), label && (jsx(Text, { size: "md", weight: "semiBold", children: label })), endContent && jsx("span", { class: tabBarItemEndContentClasses, children: endContent })] }) }));
}

export { TabBar as T, TabBarItem as a };
//# sourceMappingURL=TabBarItem-cbce696e.js.map
