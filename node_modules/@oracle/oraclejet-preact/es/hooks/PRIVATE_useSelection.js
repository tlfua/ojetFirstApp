/* @oracle/oraclejet-preact: 15.1.2 */
import { useRef, useCallback } from 'preact/hooks';
import { stringLiteralArray } from '../utils/UNSAFE_arrayUtils.js';
import { containsKey, addKey, removeKey, isKeyDefined } from '../utils/UNSAFE_keys.js';
import { useUser } from './UNSAFE_useUser.js';
import { isMobile } from '../utils/PRIVATE_collectionUtils.js';
import '../index-f26154f2.js';
import 'preact';
import '../Common.js';
import '../Common/themes.js';
import '../Common/themes/redwood/theme.js';
import '../Common/themes/themeContract.css.js';
import 'preact/jsx-runtime';
import 'preact/compat';
import '../utils/PRIVATE_clientHints.js';
import '../clientHints-26cce6ec.js';

/**
 * Type for selection behavior.  See useMultipleSelection hook for details.
 */
const behaviors = stringLiteralArray(['toggle', 'replace']);
const isShiftModeSupported = (anchorKey, selectedKeys, selectionMode, selectionBehavior) => {
    return (selectionMode === 'multiple' &&
        selectionBehavior !== 'toggle' &&
        containsKey(selectedKeys, anchorKey));
};
const handleSelect = (event, keyExtractor, selectedKeys, selectionMode, selectionBehavior, isSelectionRequired, keyboardCursorRef, anchorKey, onChange, onRangeChange) => {
    const itemKey = keyExtractor(event.target);
    if (itemKey == null) {
        return;
    }
    // handle shift key selection
    if (event.shiftKey &&
        anchorKey !== undefined &&
        onRangeChange &&
        isShiftModeSupported(anchorKey, selectedKeys, selectionMode, selectionBehavior)) {
        onRangeChange({ value: { start: anchorKey, end: itemKey } });
        // set keyboard selection cursor in case user extends with SHIFT+ARROW
        if (keyboardCursorRef) {
            keyboardCursorRef.current = itemKey;
        }
        return;
    }
    const selected = containsKey(selectedKeys, itemKey);
    let keySet = selectedKeys;
    if (!selected) {
        if (selectionMode === 'single' ||
            event.key === 'Enter' ||
            (selectionBehavior === 'replace' && !(event.ctrlKey || event.metaKey))) {
            // should only contains this item key
            keySet = { all: false, keys: new Set([itemKey]) };
        }
        else {
            // add to existing selected keys
            keySet = addKey(selectedKeys, itemKey);
        }
    }
    else if (event.key !== 'Enter') {
        // no de-select for enter key
        if (selectionBehavior === 'toggle' ||
            event.ctrlKey ||
            event.metaKey ||
            event.key === ' ') {
            // de-select only when ctrl/meta key is pressed or selectionBehavior is
            // explicitly set to toggle
            keySet = removeKey(selectedKeys, itemKey, isSelectionRequired);
        }
        else if (selectionMode === 'multiple' && (selectedKeys.all || selectedKeys.keys.size > 1)) {
            // in this case everything should be de-selected except for this key
            keySet = { all: false, keys: new Set([itemKey]) };
        }
    }
    // only invoke callback if there is really a change
    // note onSelectionChange should never be null here
    if (selectedKeys != keySet && onChange) {
        onChange({ value: keySet, target: event.target });
        if (event.type === 'click') {
            event.stopPropagation();
        }
    }
};
/**
 * Hook for handling various selection mode.  This can be reuse by all Collection components.
 * @param keyExtractor function to extract the key based on provided element
 * @param selectedKeys the currently selected keys
 * @param selectionMode the selection mode
 * @param isSelectionRequired true if empty selected key is not allowed, false otherwise
 * @param selectionBehavior the selection behavior.  If the value is 'toggle', then the key is
 *                          added/removed from the current selected keys.  If the value is 'replace',
 *                          then the current selected keys are cleared first before the key is added
 *                          unless the ctrl/shift/meta key is pressed.
 * @param allowEnterKey whether enter key can be use to change selection.
 * @param onChange callback function that is invoked when selection has changed.
 * @param anchorKey the anchor key.  Usually this is the same as current key except when shift key is pressed.
 * @param currentKey the current key
 * @param getVerticalPrevNextKey function to get the previous/next key in the vertical direction based on the current key
 * @param getHorizontalPrevNextKey function to get the previous/next key in the horizontal direction based on the current key
 * @param scrollToKey function to scroll the item with the key to be visible
 * @param onRangeChange callback function that is invoked when the selection range has changed.
 * @returns an event map that the consumer can register as event listeners
 */
function useSelection(keyExtractor, selectedKeys, selectionMode, isSelectionRequired, selectionBehavior, allowEnterKey, onChange, anchorKey, currentKey, getVerticalPrevNextKey, getHorizontalPrevNextKey, scrollToKey, onRangeChange) {
    // ref to track the cursor for the SHIFT+ARROW keyboard selection separately than the anchor of the selection.
    const keyboardSelectionCursor = useRef();
    const onClick = useCallback((event) => {
        handleSelect(event, keyExtractor, selectedKeys, selectionMode, isMobile() ? 'toggle' : selectionBehavior, isSelectionRequired, keyboardSelectionCursor, anchorKey, onChange, onRangeChange);
        if (!event.shiftKey) {
            // reset keyboard cursor when using mouse to select
            keyboardSelectionCursor.current = undefined;
        }
    }, [
        keyExtractor,
        selectedKeys,
        selectionMode,
        selectionBehavior,
        isSelectionRequired,
        keyboardSelectionCursor,
        anchorKey,
        onChange,
        onRangeChange
    ]);
    // general keyboard events listen to keyUp for a11y
    const onKeyUp = useCallback((event) => {
        // older browser that we don't support returns 'Spacebar' for space key
        if (event.key === ' ' || (event.key === 'Enter' && allowEnterKey)) {
            handleSelect(event, keyExtractor, selectedKeys, selectionMode, selectionBehavior, isSelectionRequired, keyboardSelectionCursor, anchorKey, onChange, event.shiftKey && event.key === ' ' ? onRangeChange : undefined);
        }
    }, [
        keyExtractor,
        selectedKeys,
        selectionMode,
        selectionBehavior,
        isSelectionRequired,
        anchorKey,
        onChange,
        onRangeChange
    ]);
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    // arrowKey events listen to keyDown so they can support holding them down
    const onKeyDown = useCallback((event) => {
        // prevent default (propagation) for keyDown to space bar causing container to scroll
        if (event.key === ' ') {
            event.preventDefault();
            return;
        }
        const key = keyboardSelectionCursor.current || currentKey;
        const keyHandlers = {
            ArrowUp: getVerticalPrevNextKey?.(key, true),
            ArrowDown: getVerticalPrevNextKey?.(key, false),
            ArrowLeft: getHorizontalPrevNextKey?.(key, !isRtl),
            ArrowRight: getHorizontalPrevNextKey?.(key, isRtl)
        };
        const isBothDirections = getVerticalPrevNextKey && getHorizontalPrevNextKey;
        if (Object.keys(keyHandlers).includes(event.key)) {
            if (event.shiftKey && scrollToKey && selectionMode === 'multiple') {
                let keySet = selectedKeys;
                // on first selection event, set keyboard cursor to start at currentKey
                if (!keyboardSelectionCursor.current && isKeyDefined(currentKey)) {
                    keySet = { all: false, keys: new Set([currentKey]) };
                }
                const newAnchorKey = keyHandlers[event.key];
                const cursorKey = newAnchorKey?.();
                if (cursorKey != null) {
                    // keep visible
                    scrollToKey(cursorKey);
                    // if in 2D, use range selection to extend or subtract
                    if (isBothDirections) {
                        if (onRangeChange && currentKey != null) {
                            onRangeChange({ value: { start: currentKey, end: cursorKey } });
                        }
                    }
                    else {
                        // extend selection
                        if (!containsKey(keySet, cursorKey)) {
                            keySet = addKey(keySet, cursorKey);
                            // subtract from selection
                        }
                        else if (keyboardSelectionCursor.current != null &&
                            keyboardSelectionCursor.current !== cursorKey) {
                            keySet = removeKey(keySet, keyboardSelectionCursor.current, isSelectionRequired);
                        }
                        if (selectedKeys != keySet && onChange) {
                            onChange({ value: keySet, target: event.target });
                        }
                    }
                    // update selection cursor
                    keyboardSelectionCursor.current = cursorKey;
                }
            }
            else {
                // reset keyBoard on non-shifted arrow use as this interrupts the extend mode (and would make for messy logic that doesn't align with current Jet behavior)
                keyboardSelectionCursor.current = undefined;
            }
        }
    }, [
        selectedKeys,
        isSelectionRequired,
        onChange,
        currentKey,
        getVerticalPrevNextKey,
        getHorizontalPrevNextKey,
        scrollToKey
    ]);
    const selectionProps = selectionMode === 'none' || onChange == null ? {} : { onClick, onKeyDown, onKeyUp };
    return { selectionProps };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { useSelection };
//# sourceMappingURL=PRIVATE_useSelection.js.map
