/* @oracle/oraclejet-preact: 15.1.2 */
import { useRef, useEffect, useState, useCallback, useLayoutEffect } from 'preact/hooks';
import { jsx, Fragment } from 'preact/jsx-runtime';
import { useId } from './UNSAFE_useId.js';
import '../UNSAFE_Floating.js';
import { Layer } from '../UNSAFE_Layer.js';
import { useHover } from './UNSAFE_useHover.js';
import { useFocus } from './UNSAFE_useFocus.js';
import { useTouch } from './UNSAFE_useTouch.js';
import { mergeProps } from '../utils/UNSAFE_mergeProps.js';
import { stringLiteralArray } from '../utils/UNSAFE_arrayUtils.js';
import './UNSAFE_useAnimation.js';
import { useComponentTheme } from './UNSAFE_useComponentTheme.js';
import './UNSAFE_useThemeInterpolations.js';
import '../utils/UNSAFE_classNames.js';
import { TooltipContentRedwoodTheme } from './UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js';
import { u as useThemeInterpolations } from '../useThemeInterpolations-48ee20a7.js';
import { u as useAnimation } from '../useAnimation-50c5f5fb.js';
import { c as classNames } from '../classNames-f414daad.js';
import { a as EnvironmentProvider } from '../index-f26154f2.js';
import { useColorScheme } from './UNSAFE_useColorScheme.js';
import { F as Floating } from '../Floating-2d909840.js';
import 'preact/compat';
import './UNSAFE_useToggle.js';
import '../utils/UNSAFE_logger.js';
import '../_curry1-7629ff3f.js';
import '../_curry2-820ed778.js';
import './UNSAFE_useTooltip/themes/TooltipContentStyles.css.js';
import './../TooltipContentStyles.styles.css';
import './UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js';
import './UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './../TooltipContentVariants.styles.css';
import '../vanilla-extract-recipes-createRuntimeFn.esm-3311d9ef.js';
import './UNSAFE_useScale.js';
import '../utils/UNSAFE_interpolations/theme.js';
import '../UNSAFE_Theme.js';
import '../utils-9a0cb8dc.js';
import '../Common/themes/themeContract.css.js';
import '../utils/UNSAFE_mergeInterpolations.js';
import '../_curry3-bb17e901.js';
import '../_has-057b6f90.js';
import 'preact';
import '../Common.js';
import '../Common/themes.js';
import '../Common/themes/redwood/theme.js';
import '../index-326d7a5f.js';
import './UNSAFE_useUser.js';
import '../utils/PRIVATE_floatingUtils.js';
import '../utils/PRIVATE_refUtils.js';
import './UNSAFE_useOutsideClick.js';
import '../UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import '../UNSAFE_Floating/themes/FloatingStyles.css.js';
import './../FloatingStyles.styles.css';
import '../UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './../UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import '../UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import '../vanilla-extract-dynamic.esm-33365337.js';
import '../UNSAFE_Floating/themes/FloatingContract.css.js';

const TooltipContent = ({ children, id, isOpen, isDatatip, onTransitionEnd, ...props }) => {
    const wrapperRef = useRef(null);
    const popoverRef = useRef(null);
    const { classes, styles } = useComponentTheme(TooltipContentRedwoodTheme, {
        variant: isDatatip ? 'datatip' : 'tooltip'
    });
    const schemeClass = useThemeInterpolations();
    const { nodeRef } = useAnimation(isOpen ? 'mounted' : 'unmounted', {
        animationStates: {
            mounted: (_node) => {
                const childNode = _node.firstChild;
                return {
                    from: {
                        maxHeight: '0',
                        opacity: '0%'
                    },
                    to: {
                        maxHeight: `${childNode?.offsetHeight}px`,
                        opacity: isDatatip ? '100%' : '95%'
                    },
                    options: {
                        duration: isDatatip ? 1 : 100,
                        easing: [0.0, 0.0, 0.2, 1]
                    }
                };
            },
            unmounted: (_node) => {
                return {
                    from: {
                        opacity: isDatatip ? '100%' : '95%'
                    },
                    to: {
                        maxHeight: '0',
                        opacity: '0%'
                    },
                    options: {
                        duration: isDatatip ? 1 : 100,
                        easing: [0.0, 0.0, 0.2, 1]
                    }
                };
            }
        },
        isAnimatedOnMount: true,
        onAnimationEnd: () => onTransitionEnd?.()
    });
    // Set up initial wrapper height so Tooltip can animate from the bottom to the top
    useEffect(() => {
        if (wrapperRef.current && popoverRef.current?.offsetHeight) {
            wrapperRef.current.style.height = `${popoverRef.current?.offsetHeight}px`;
        }
    }, []);
    return (jsx("div", { ref: wrapperRef, id: id, role: "tooltip", class: classNames([styles.wrapper, schemeClass]), children: jsx("div", { ref: nodeRef, class: styles.inner, ...props, children: jsx("div", { ref: popoverRef, class: classNames([classes, styles.content]), children: children }) }) }));
};

const positions = stringLiteralArray([
    'start',
    'top-start',
    'top',
    'top-end',
    'end',
    'bottom-end',
    'bottom',
    'bottom-start'
]);
const positionToPlacement = (position) => {
    let placement = 'bottom';
    switch (position) {
        case 'top':
        case 'end':
        case 'bottom':
        case 'start':
            placement = position;
            break;
        case 'top-end':
            placement = 'top-end-corner';
            break;
        case 'bottom-end':
            placement = 'bottom-end-corner';
            break;
        case 'bottom-start':
            placement = 'bottom-start-corner';
            break;
        case 'top-start':
            placement = 'top-start-corner';
            break;
    }
    return placement;
};
const anchorTos = stringLiteralArray(['element', 'pointer']);
const useTooltipControlled = ({ text, isOpen = false, variant = 'tooltip', position = 'bottom', isDisabled = false, anchor = { x: 'element', y: 'element' }, offset = { mainAxis: 0, crossAxis: 0 }, onToggle }) => {
    const disabled = isDisabled || !text;
    const isInitialRenderState = useRef(true);
    const hiddenWithEsc = useRef(false);
    const [state, setState] = useState(!disabled && isOpen ? 'mounting' : 'unmounted');
    const [needsUpdate, setNeedsUpdate] = useState(false);
    setNeedsUpdate(false);
    const isDatatip = variant === 'datatip';
    const isInitialRenderTrigger = useRef(true);
    const { hoverProps, isHover } = useHover({});
    const { touchProps, isTouch } = useTouch({ isDisabled }); // TODO replace by useLongPress actionhook
    // we only care about keyboard focus, don't enable useFocus hook if isHover or isTouch are active
    const { focusProps, isFocus } = useFocus({ isDisabled: isHover || isTouch });
    const { hoverProps: popoverHoverProps, isHover: popoverIsHover } = useHover({ isDisabled });
    const isPointer = anchor.x === 'pointer' || anchor.y === 'pointer';
    const uniqueIdRef = useRef(useId());
    const targetRef = useRef(null);
    const coordsRef = useRef({ x: -9999, y: -9999 });
    // if anchor is set to pointer and target does not have keyboard focus, use coords
    const usedRef = isPointer && !isFocus ? coordsRef : targetRef;
    const delay = isDatatip ? 0 : 250;
    const toggleTimeoutRef = useRef(null);
    const updateTimeoutRef = useRef(null);
    const toggleTimeoutClear = () => {
        if (toggleTimeoutRef.current) {
            clearTimeout(toggleTimeoutRef.current);
        }
    };
    const updateTimeoutClear = () => {
        if (updateTimeoutRef.current) {
            clearTimeout(updateTimeoutRef.current);
        }
    };
    const updateState = useCallback((open) => {
        if (open) {
            // At least one toggle event is set to true
            switch (state) {
                case 'unmounting':
                case 'unmounted':
                    setState('mountPending'); // Set mount pending state if tooltip is unmounted or in unmounting transition
                    break;
                case 'unmountPending':
                    toggleTimeoutClear();
                    setState('mounted'); // Clear timers immediately and keep the tooltip mounted
                    break;
            }
        }
        else {
            // No toggle events are set to true
            switch (state) {
                case 'mounting':
                case 'mounted':
                    setState('unmountPending'); // Set unmount pending state if tooltip is mounted or in mounting transition
                    break;
                case 'mountPending':
                    toggleTimeoutClear();
                    __resetCoords();
                    setState('unmounted'); // Unmount tooltip immediately if mounting is pending
                    break;
            }
        }
    }, [state]);
    useEffect(() => {
        if (isInitialRenderState.current) {
            // On onitial render do not trigger rerender
            isInitialRenderState.current = false;
            return;
        }
        setState(isOpen ? 'mounting' : 'unmounting');
    }, [isOpen]);
    useEffect(() => {
        if (isInitialRenderTrigger.current) {
            // On onitial render do not trigger rerender
            isInitialRenderTrigger.current = false;
            return;
        }
        // When pointer is used, handleMouseMove method is responsible for state updates
        // until the tooltip is mounted
        if (isPointer && isHover && state === 'unmounted') {
            return;
        }
        updateTimeoutClear();
        // isHover and popoverIsHover may change rapidly as the pointer moves between the target
        // and tooltip. Need to wait for changes to settle to avoid flashing.
        updateTimeoutRef.current = setTimeout(() => {
            updateState(isHover || (isFocus && !hiddenWithEsc.current) || popoverIsHover || isTouch);
        }, 20);
    }, [
        isHover,
        isFocus,
        popoverIsHover,
        isTouch,
        isPointer,
        state,
        updateState,
        hiddenWithEsc.current
    ]);
    /*
     In some cases, several state transitions can occur at once. Due to the asynchronous nature
     of hooks, this can create a race condition. For example, when the cursor leaves the target
     element and immediately moves to the tooltip itself, the following sequence occurs:
     1. isHover is set to false and a new render is triggered
     2. The state is set to 'unmountPending' and a new render is triggered
     3. Pending timeout is set
     4. isHover is set to true and a new render is triggered
     5. Pending timeout is cleared
     However, sometimes the timeout is cleared before it is set. The useLayoutEffect prevents this
     race condition by always scheduling the timeout synchronously.
    */
    useLayoutEffect(() => {
        if (state === 'mountPending' || state === 'unmountPending') {
            toggleTimeoutRef.current = setTimeout(() => onToggle?.({ value: state === 'mountPending' }), delay);
        }
    }, [state, delay, onToggle]);
    const handleMouseMove = (event) => {
        // we only want track mouse move while the state is 'unmounted' or when moving a 'mounted' datatip
        if (state !== 'unmounted' && !(variant === 'datatip' && state === 'mounted')) {
            return;
        }
        const targetRect = targetRef?.current?.getBoundingClientRect();
        // Tooltip maintains static offset from left side of window
        const distanceX = document.body.scrollLeft + (targetRect?.left || 0) + (targetRect?.width || 0);
        // Tooltip maintains static offset from top side of the window
        const distanceY = document.body.scrollTop + (targetRect?.top || 0) + (targetRect?.height || 0);
        // Display tooltip at the mouse position if both anchors are set to pointer
        const x = anchor.x === 'pointer' ? event.clientX : distanceX;
        const y = anchor.y === 'pointer' ? event.clientY : distanceY;
        if (state === 'mounted') {
            coordsRef.current = { x, y };
            if (needsUpdate !== true)
                setNeedsUpdate(true);
        }
        else if (state === 'unmounted') {
            toggleTimeoutClear();
            toggleTimeoutRef.current = setTimeout(() => {
                if (state === 'unmounted') {
                    coordsRef.current = { x, y };
                    onToggle?.({ value: true });
                }
            }, delay);
        }
    };
    const focusInitProps = {
        onFocus: useCallback((event) => {
            if (event.eventPhase === Event.AT_TARGET ||
                (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)) {
                targetRef.current = event.target;
            }
        }, [isDatatip]),
        onBlur: useCallback((event) => {
            if (event.eventPhase === Event.AT_TARGET) {
                hiddenWithEsc.current = false;
            }
        }, [])
    };
    const hoverInitProps = {
        onMouseEnter: useCallback((event) => {
            if (event.eventPhase === Event.AT_TARGET ||
                (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)) {
                targetRef.current = event.target;
            }
        }, [isDatatip])
    };
    const keyInitProps = {
        onKeyUp: useCallback((event) => {
            if (event.code === 'Escape') {
                event.preventDefault();
                hiddenWithEsc.current = true;
                onToggle?.({ value: false });
            }
        }, [onToggle])
    };
    let actionableProps;
    const __resetCoords = () => {
        coordsRef.current = { x: -9999, y: -9999 };
    };
    if (disabled) {
        actionableProps = mergeProps(hoverProps, focusProps, hoverInitProps, focusInitProps);
    }
    else {
        const anchorInitProps = {
            'aria-describedby': uniqueIdRef.current,
            ...(isPointer && {
                onMouseLeave: () => {
                    if (state === 'mounting') {
                        return;
                    }
                    toggleTimeoutClear();
                },
                onMouseMove: (event) => {
                    if (event.eventPhase === Event.AT_TARGET ||
                        (event.eventPhase === Event.BUBBLING_PHASE && isDatatip)) {
                        handleMouseMove(event);
                    }
                }
            })
        };
        actionableProps = mergeProps(hoverProps, focusProps, touchProps, hoverInitProps, focusInitProps, anchorInitProps, keyInitProps);
    }
    // No need to process tooltip if disabled or no text is provided
    // Include actionableProps to detect mouseenter in components
    // hovered state won't update unless actionableProps are already present in the component when mouse enters
    if (disabled) {
        toggleTimeoutClear();
        __resetCoords();
        return {
            tooltipContent: null,
            tooltipProps: actionableProps
        };
    }
    const placement = positionToPlacement(position);
    const handleTransitionEnd = () => {
        if (state === 'mounting') {
            setState('mounted');
        }
        if (state === 'unmounting') {
            __resetCoords();
            setState('unmounted');
        }
    };
    const currentColorScheme = useColorScheme();
    const newColorScheme = !currentColorScheme || currentColorScheme === 'light' ? 'dark' : 'light';
    const renderRawContent = (jsx(TooltipContent, { id: uniqueIdRef.current, isOpen: ['mounting', 'mounted', 'unmountPending'].includes(state), ...popoverHoverProps, isDatatip: isDatatip, onTransitionEnd: handleTransitionEnd, children: text }));
    const renderTooltipOrDatatip = () => {
        if (variant === 'tooltip') {
            return (jsx(EnvironmentProvider, { environment: { colorScheme: newColorScheme }, children: renderRawContent }));
        }
        else {
            return jsx(Fragment, { children: renderRawContent });
        }
    };
    const renderContent = (jsx(Layer, { logicalParentRef: targetRef, children: jsx(Floating, { anchorRef: usedRef, placement: placement, offsetValue: offset, children: renderTooltipOrDatatip() }) }));
    return {
        tooltipContent: !['unmounted', 'mountPending'].includes(state) && renderContent,
        tooltipProps: actionableProps
    };
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const defaultOffset = 8; // Redwood tooltip has a default offset of 8 pixels
/**
 * A hook with tooltip implementation.
 * Returns event handlers that can enhance the target element with a tooltip displayed
 * on hover and focus.
 *
 * @param text tooltip text
 * @param position tooltip placement relative to the target element
 * @param isDisabled determines if the tooltip is disabled
 * @param anchor determines if the target is an element or the pointer
 * @param offset offset from the placement
 * @param variant specifies if the rendered popup should have 'tooltip' or 'datatip' look and behavior
 * @returns an object with the 'tooltipContent' and 'tooltipProps' properties.
 */
const useTooltip = ({ text, position = 'bottom', isDisabled = false, anchor = { x: 'element', y: 'element' }, offset, variant = 'tooltip' }) => {
    const [isOpen, setIsOpen] = useState(false);
    const disabled = isDisabled || !text;
    const newOffset = offset ? offset : { mainAxis: defaultOffset, crossAxis: 0 };
    const { tooltipContent, tooltipProps } = useTooltipControlled({
        text,
        isOpen,
        position,
        isDisabled: disabled,
        offset: newOffset,
        anchor,
        variant,
        onToggle: ({ value }) => setIsOpen(value)
    });
    return {
        tooltipContent,
        tooltipProps
    };
};

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { useTooltip, useTooltipControlled };
//# sourceMappingURL=UNSAFE_useTooltip.js.map
