/* @oracle/oraclejet-preact: 15.1.2 */
import { useCallback } from 'preact/hooks';
import { isKeyDefined } from '../utils/UNSAFE_keys.js';
import { useUser } from './UNSAFE_useUser.js';
import '../index-f26154f2.js';
import 'preact';
import '../Common.js';
import '../Common/themes.js';
import '../Common/themes/redwood/theme.js';
import '../Common/themes/themeContract.css.js';
import 'preact/jsx-runtime';
import 'preact/compat';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook for handling current key update due to user interaction including keyboard navigation.
 * This can be reuse by all Collection components.
 *
 * @param keyExtractor function to extract the key based on the provided element
 * @param allowShiftKey if set to false, then pressing arrow key while shift key is down will not change the current key
 * @param getVerticalPrevKey function to get the previous key in the vertical direction based on the current key
 * @param getVerticalNextKey function to get the next key in the vertical direction based on the current key
 * @param getHorizontalPrevKey function to get the previous key in the horizontal direction based on the current key
 * @param getHorizontalNextKey function to get the next key based on the current key
 * @param currentKey the current key
 * @param onCurrentChange function to invoke if the current key has changed
 * @param keyComparator an optional function to compare keys, otherwise === is used
 * @returns
 */
function useCurrentKey(keyExtractor, allowShiftKey, getVerticalPrevKey, getVerticalNextKey, getHorizontalPrevKey, getHorizontalNextKey, currentKey, onChange, keyComparator) {
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const keyEquals = useCallback((key1, key2) => {
        if (keyComparator) {
            return keyComparator(key1, key2);
        }
        return key1 === key2;
    }, [keyComparator]);
    const onKeyDown = useCallback((event) => {
        if (onChange && isKeyDefined(currentKey)) {
            const keyHandlers = {
                ArrowUp: getVerticalPrevKey,
                ArrowDown: getVerticalNextKey,
                ArrowLeft: isRtl ? getHorizontalNextKey : getHorizontalPrevKey,
                ArrowRight: isRtl ? getHorizontalPrevKey : getHorizontalNextKey
            };
            if (Object.keys(keyHandlers).includes(event.key) && (allowShiftKey || !event.shiftKey)) {
                const newKey = keyHandlers[event.key]?.();
                if (isKeyDefined(newKey) && !keyEquals(currentKey, newKey)) {
                    onChange({ value: newKey });
                }
                event.preventDefault();
            }
        }
    }, [
        currentKey,
        onChange,
        getVerticalPrevKey,
        getVerticalNextKey,
        getHorizontalPrevKey,
        getHorizontalNextKey,
        keyEquals
    ]);
    const onClickCapture = useCallback((event) => {
        if (onChange && !event.shiftKey) {
            const nextKey = keyExtractor(event.target);
            if (isKeyDefined(nextKey) && !keyEquals(currentKey, nextKey)) {
                onChange({ value: nextKey });
            }
        }
    }, [currentKey, keyExtractor, onChange, keyEquals]);
    const currentKeyProps = onChange == null ? {} : { onClickCapture, onKeyDown };
    return { currentKeyProps };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { useCurrentKey };
//# sourceMappingURL=PRIVATE_useCurrentKey.js.map
