/* @oracle/oraclejet-preact: 15.1.2 */
import { useState, useCallback } from 'preact/hooks';
import { isKeyDefined } from '../utils/UNSAFE_keys.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook for handling Tabbable mode set provider components.
 *
 * @param contains - callback to check  whether an element is in set
 * @param keyExtractor - function to extract the key based on provided element
 * @param currentKey - current key navigation "cursor" is on
 * @param onTabbableModeDisable - callback to parent when set is disabled
 * @param onTabbableModeEnable - callback to parent when set is enabled
 * @returns isCurrentTabbableKey - callback for parent to check if key is in interactive mode
 * @returns tabbableSetProps - event handlers mode relies on
 */
function useTabbableModeSet(contains, keyExtractor, currentKey, onTabbableModeDisable, onTabbableModeEnable) {
    // Track which row is in actionable in state
    const [currentTabbableKey, setCurrentTabbableKey] = useState();
    const disableTabbableMode = useCallback((target, isKeyboardEvent = false) => {
        setCurrentTabbableKey(undefined);
        onTabbableModeDisable && onTabbableModeDisable(target, isKeyboardEvent);
    }, [onTabbableModeDisable, setCurrentTabbableKey]);
    const enableTabbableMode = useCallback((key) => {
        setCurrentTabbableKey(key);
        onTabbableModeEnable && onTabbableModeEnable(key);
    }, [onTabbableModeEnable, setCurrentTabbableKey]);
    const isCurrentTabbableKey = useCallback((key) => {
        return key === currentTabbableKey;
    }, [currentTabbableKey]);
    const onFocus = (event) => {
        const key = keyExtractor(event.target);
        if (isKeyDefined(key) && !isCurrentTabbableKey(key)) {
            enableTabbableMode(key);
        }
    };
    const onBlur = (event) => {
        if (!event.relatedTarget || !contains(event.relatedTarget)) {
            disableTabbableMode(event.relatedTarget);
        }
    };
    const onPointerDown = (event) => {
        const key = keyExtractor(event.target);
        if (currentTabbableKey !== undefined && !isCurrentTabbableKey(key)) {
            disableTabbableMode(event.target);
        }
    };
    const onKeyDown = useCallback((event) => {
        if (event.key === 'F2') {
            currentKey !== undefined && !isCurrentTabbableKey(currentKey)
                ? enableTabbableMode(currentKey)
                : disableTabbableMode(event.target, true);
        }
        if (event.key === 'Esc' || event.key === 'Escape') {
            disableTabbableMode(event.target, true);
        }
    }, [currentKey, disableTabbableMode, enableTabbableMode, isCurrentTabbableKey]);
    const tabbableSetProps = {
        onFocus,
        onBlur,
        onKeyDown,
        onPointerDown
    };
    return [isCurrentTabbableKey, tabbableSetProps];
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { useTabbableModeSet };
//# sourceMappingURL=PRIVATE_useTabbableModeSet.js.map
