/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx } from 'preact/jsx-runtime';
import { PrefixSuffix } from '../UNSAFE_PrefixSuffix.js';
import { useUser } from './UNSAFE_useUser.js';
import '../UNSAFE_PrefixSuffix/themes/PrefixSuffixStyles.css.js';
import './../PrefixSuffixStyles.styles.css';
import '../vanilla-extract-recipes-createRuntimeFn.esm-3311d9ef.js';
import 'preact/hooks';
import '../index-f26154f2.js';
import 'preact';
import '../Common.js';
import '../Common/themes.js';
import '../Common/themes/redwood/theme.js';
import '../Common/themes/themeContract.css.js';
import 'preact/compat';

// returns the prefix and/or suffix components
// if the condition in which they should be shown is met.
const usePrefixSuffix = ({ baseId, hasEndContent, hasInsideLabel, hasStartContent, hasValue, isDisabled, isFocused, labelId, prefix, suffix, value }) => {
    const { direction } = useUser();
    // for accessibility, if you have a prefix, then you must have a prefixId
    const prefixId = `${baseId}-prefix`;
    const suffixId = `${baseId}-suffix`;
    const hasPrefixText = prefix !== undefined && prefix !== '';
    const hasSuffixText = suffix !== undefined && suffix !== '';
    const renderedPrefix = hasPrefixText && !isDisabled && (hasValue || isFocused) ? (jsx(PrefixSuffix, { id: prefixId, hasEndContent: hasEndContent, hasInsideLabel: hasInsideLabel, hasStartContent: hasStartContent, isDisabled: isDisabled, isFocused: isFocused, text: prefix, variant: "prefix" })) : undefined;
    const renderedSuffix = hasSuffixText && !isDisabled && (hasValue || isFocused) ? (jsx(PrefixSuffix, { id: suffixId, hasInsideLabel: hasInsideLabel, isDisabled: isDisabled, isFocused: isFocused, text: suffix, variant: "suffix" })) : undefined;
    // get value and prefix/suffix if available and return as plain text.
    const text = hasPrefixText || hasSuffixText ? getText(direction, hasValue, prefix, suffix, value) : value;
    // get aria-labelledby if there is a prefix or suffix
    const ariaLabelledBy = hasPrefixText || hasSuffixText
        ? getAriaLabelledBy(labelId, hasPrefixText ? prefixId : undefined, hasSuffixText ? suffixId : undefined)
        : undefined;
    return { renderedPrefix, renderedSuffix, text, ariaLabelledBy };
};
/**
 * Returns the value to render in plain text, taking into account the prefix and suffix
 * and reading direction. Do not add a prefix/suffix if the component doesn't have a value.
 * @returns string | undefined
 */
function getText(direction, hasValue, prefix, suffix, value) {
    // Do not add a prefix/suffix if the component doesn't have a value.
    if (!hasValue) {
        return value;
    }
    // TODO: direction is 'ltr' even though the storybook is rtl.
    // Test this when the storybook bug is fixed. ?src=confmacro
    const isLTR = direction === 'ltr';
    const plainPrefix = prefix === undefined ? `` : isLTR ? `${prefix} ` : ` ${prefix}`;
    const plainSuffix = suffix === undefined ? `` : isLTR ? ` ${suffix}` : `${suffix} `;
    const ltrPlainText = `${plainPrefix}${value}${plainSuffix}`;
    const rtlPlainText = `${plainSuffix}${value}${plainPrefix}`;
    return isLTR ? ltrPlainText : rtlPlainText;
}
function getAriaLabelledBy(labelId, prefixId, suffixId) {
    const label = labelId ?? '';
    const prefix = prefixId === undefined ? '' : label.length === 0 ? prefixId : ` ${prefixId}`;
    const suffix = suffixId === undefined
        ? ''
        : label.length === 0 && prefix.length === 0
            ? suffixId
            : ` ${suffixId}`;
    const ariaLabelledBy = `${label}${prefix}${suffix}`;
    return ariaLabelledBy.length === 0 ? undefined : ariaLabelledBy;
}

export { usePrefixSuffix };
//# sourceMappingURL=UNSAFE_usePrefixSuffix.js.map
