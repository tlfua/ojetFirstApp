{"version":3,"file":"UNSAFE_useCategories.js","sources":["../../../src/hooks/UNSAFE_useCategories/useCategories.ts","../../../src/hooks/UNSAFE_useCategories/index.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useMemo, useRef } from 'preact/hooks';\n\n/**\n * Compares if two sets are equal.\n */\nconst isEqual = <T>(setA: Set<T>, setB: Set<T>) => {\n  return setA.size === setB.size && [...setA].every((value) => setB.has(value));\n};\n\n/**\n * Toggles the existing categories/id with updated categories/id.\n * @param original The set of original ids/categories\n * @param updated The set of updated ids/categories\n * @returns\n */\nconst toggle = <T>(original: Set<T>, updated: Set<T>) => {\n  const matches = new Set(original);\n  updated.forEach((item) => {\n    if (!original.has(item)) {\n      matches.add(item);\n    } else {\n      matches.delete(item);\n    }\n  });\n  return matches;\n};\n\n/**\n * Creates initial map of category and data items.\n * @param items Data item objects. If 'categories' field is not present, id will be assumed to be default category.\n */\nfunction getCategoryMap<K extends number | string>(\n  items: any[],\n  getCategory: (item: any) => string[]\n) {\n  const categoryToItem: Map<string, Set<K>> = new Map();\n  const itemToCategory: Map<K, Set<string>> = new Map();\n  items.forEach((item: any) => {\n    const id: K = item.id;\n    const categories: string[] = getCategory(item);\n    itemToCategory.set(id, new Set(categories));\n    categories.forEach((category) => {\n      if (categoryToItem.has(category)) {\n        categoryToItem.get(category)?.add(id);\n      } else {\n        categoryToItem.set(category, new Set([id]));\n      }\n    });\n  });\n  return { categoryToItem, itemToCategory };\n}\n\n/**\n * Returns the items for a given categories.\n * @param categoryToItemMap Map of categories to Item.\n * @param matchCriteria Whether to match any or all categories.\n * @param categories categories\n * @returns\n */\nfunction getItemsFromCategories<K>(\n  categoryToItemMap: Map<string, Set<K>>,\n  matchCriteria: 'any' | 'all' = 'any',\n  categories: Set<string>\n) {\n  return [...categories].reduce((acc: Set<K>, cur: string, index: number) => {\n    const curItems = categoryToItemMap.get(cur)!;\n    if (matchCriteria === 'any') {\n      return curItems ? new Set([...acc, ...curItems]) : acc;\n    }\n\n    if (!index) return curItems;\n    return new Set([...acc].filter((item) => curItems.has(item)));\n  }, new Set<K>());\n}\n\n/**\n * @param items The array of items.\n * @param getCategoriesFromItem The function that returns the categories array for given item.\n * @param initialCategories The initial categories.\n * @param matchCriteria  The matching condition for the categories.\n * By default, matchCriteria is 'all' and only items whose categories match all of the values specified in the categories array will be matched.\n * If matchCriteria is 'any', then items that match at least one of the categories values will be matched.\n * @param replace Whether the new categories should completely replace the old categories (for highlighting) or just toggle previous categories (for hideAndShow)\n * @param onCategoriesChange The callback to invoke when categories change.\n * @returns\n */\nexport function useCategories<K extends string | number>(\n  items: any[],\n  getCategoriesFromItem: (item: any) => string[],\n  initialCategories: string[] = [],\n  matchCriteria: 'any' | 'all' = 'all',\n  replace = true,\n  onCategoriesChange?: (categories: string[]) => void\n) {\n  const categoryMap = useMemo(\n    () => getCategoryMap<K>(items, getCategoriesFromItem),\n    [items, getCategoriesFromItem]\n  );\n\n  const initialCategoriesSet = new Set(initialCategories);\n  const newIds = getItemsFromCategories(\n    categoryMap.categoryToItem,\n    matchCriteria,\n    initialCategoriesSet\n  );\n\n  const categoriesRef = useRef(initialCategoriesSet);\n  const idsRef = useRef(newIds);\n\n  if (!isEqual(newIds, idsRef.current)) {\n    idsRef.current = newIds;\n  }\n\n  if (!isEqual(categoriesRef.current, initialCategoriesSet)) {\n    categoriesRef.current = initialCategoriesSet;\n    onCategoriesChange?.([...initialCategoriesSet]);\n  }\n\n  const updateCategories = (id: K | undefined) => {\n    let updatedCategories = id != null ? categoryMap.itemToCategory.get(id)! : new Set([]);\n    let updatedItems = getItemsFromCategories(\n      categoryMap.categoryToItem,\n      matchCriteria,\n      updatedCategories\n    );\n\n    if (!replace) {\n      updatedItems = toggle(idsRef.current, updatedItems);\n      updatedCategories = toggle(categoriesRef.current, updatedCategories);\n    }\n\n    if (!isEqual(updatedItems, idsRef.current)) {\n      idsRef.current = updatedItems;\n    }\n\n    if (updatedCategories && !isEqual(updatedCategories, categoriesRef.current)) {\n      categoriesRef.current = updatedCategories;\n      onCategoriesChange?.([...updatedCategories]);\n    }\n  };\n\n  return {\n    ids: [...idsRef.current],\n    updateCategories\n  };\n}\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nexport { useCategories } from './useCategories';\n"],"names":[],"mappings":"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"}