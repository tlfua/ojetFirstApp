{"version":3,"file":"colors.js","sources":["../../../../src/utils/UNSAFE_interpolations/colors/colors.ts"],"sourcesContent":["import { Property } from 'csstype';\nimport { colorSchemeVars } from '../../../Common/themes/themeContract.css';\n\ntype Props = {\n  color?: Property.Color;\n  backgroundColor?: Property.BackgroundColor;\n};\n\n// Take a string in the form of \"rgb(palette.token.str)\" and return the \"palette.token.str\"\nconst parsePaletteTokenFromRGB = (rgbStr: string) => {\n  const tokenArg = rgbStr.split('(')[1].split(')')[0];\n  return tokenArg ? tokenArg : ''; // return the matched palette token\n};\n// Take a string in the form of \"rgba(palette.token.str,opacity)\" and return the token and opacity\nconst parsePaletteTokenAndOpacityFromRGBA = (rgbaStr: string) => {\n  const tokenArgs = rgbaStr.split('(')[1].split(')')[0];\n  const argArray = tokenArgs.split(',');\n  // should have two arguments\n  if (argArray.length === 2) {\n    return [argArray[0], argArray[1]];\n  }\n  return ['', '']; // return empty string values on no match\n};\n// This will either return the interpolated token, or the original value if the token isn't found.\n// Any colorSchemeVars token can be referenced, but the palette tokens need to be wrapped with rgb(token)\n// or rgba(token,opacity).\nconst tokenInterpolate = (color: string) => {\n  const evaluateToken = (tokenStr: string) => {\n    const tokenKeys = tokenStr.split('.');\n    let evaluatedToken: any = colorSchemeVars;\n    tokenKeys.every((key) => {\n      if (evaluatedToken && typeof evaluatedToken === 'object' && evaluatedToken[key]) {\n        evaluatedToken = evaluatedToken[key];\n        return evaluatedToken;\n      } else {\n        evaluatedToken = tokenStr; // bad evaluation, return the original string;\n        return false;\n      }\n    });\n    return evaluatedToken;\n  };\n  let interpolatedColor = color.replace(/\\s/g, ''); // remove all whitespace before parsing\n  if (interpolatedColor.startsWith('rgb(palette.')) {\n    const evaluatedToken = evaluateToken(parsePaletteTokenFromRGB(interpolatedColor));\n    if (evaluatedToken) {\n      interpolatedColor = `rgb(${evaluatedToken})`;\n    }\n  } else if (interpolatedColor.startsWith('rgba(palette.')) {\n    const [token, opacity] = parsePaletteTokenAndOpacityFromRGBA(interpolatedColor);\n    const evaluatedToken = evaluateToken(token);\n    if (evaluatedToken) {\n      interpolatedColor = `rgba(${evaluatedToken},${opacity})`;\n    }\n  } else if (!interpolatedColor.startsWith('palette.') && interpolatedColor.includes('.')) {\n    // Don't allow palette tokens without the rbg() or rbga() wrapper.\n    interpolatedColor = evaluateToken(interpolatedColor);\n  }\n  // TWe want to pass the original value through, even if it was an unsuccessfully interploated token.\n  // An app developer will be able to see when a specified token is not parsed correctly and can fix\n  // any typoes, etc.\n  return interpolatedColor;\n};\n\nconst colorInterpolations = {\n  color: ({ color }: Pick<Props, 'color'>) =>\n    color === undefined\n      ? {}\n      : {\n          color: tokenInterpolate(color)\n        },\n  backgroundColor: ({ backgroundColor }: Pick<Props, 'backgroundColor'>) =>\n    backgroundColor === undefined\n      ? {}\n      : {\n          backgroundColor: tokenInterpolate(backgroundColor)\n        }\n};\n\nexport { colorInterpolations };\nexport type ColorProps = Props;\n"],"names":[],"mappings":"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"}