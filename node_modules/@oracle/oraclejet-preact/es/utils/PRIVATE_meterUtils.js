/* @oracle/oraclejet-preact: 15.1.2 */
import { getDvtThresholdColor } from './UNSAFE_dvtCommonUtils.js';
import '../Common/themes/themeContract.css.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Validates the min, max, value and step passed to the meter are in appropriate range.
 * @throws { RangeError }
 * @param min The minimum value of the meter.
 * @param max The maximum value of the meter.
 * @param value The metric value of the meter.
 * @param step The step value of the meter.
 */
function validateRange(min, max, value, step) {
    if (min > max) {
        throw new RangeError('The min must be lower or equal to max.');
    }
    if (value < min || value > max) {
        throw new RangeError('The value must be between min and max.');
    }
    if (step > max - min) {
        throw new RangeError('The step value must be less than the difference of max and min');
    }
}
/**
 * Returns the threshold that the current value belongs to. Returns undefined if the current value does not belong to
 * any threshold or if thresholds is undefined.
 * @param value The value in meter.
 * @param thresholds The list of thresholds.
 * @returns The Threshold that current value belongs to.
 */
function findThreshold(value, thresholds) {
    if (!thresholds) {
        return;
    }
    if (value <= thresholds[0].max) {
        return thresholds[0];
    }
    let minValue = thresholds[0].max;
    for (let i = 1; i < thresholds.length; i++) {
        if (minValue < value && value <= thresholds[i].max) {
            return thresholds[i];
        }
        minValue = thresholds[i].max;
    }
    return;
}
/**
 * Returns the color of track for the meter.
 * @param trackColor The color provided via trackColor prop of the meter.
 * @param thresholdDisplay  Specifies whether current threshold to display in track, indicator or all thresholds in track.
 * @param currentThreshold Current threshold for the meter value.
 * @returns The color of the track for the meter.
 */
function getTrackColor(thresholdDisplay, currentThreshold, trackColor) {
    if (thresholdDisplay === 'track' && currentThreshold?.color) {
        return getDvtThresholdColor(currentThreshold?.color);
    }
    return trackColor;
}
/**
 * Returns the color of indicator for the meter.
 * @param indicatorColor The color provided via indicatorColor prop of the meter.
 * @param thresholdDisplay  Specifies whether current threshold to display in track, indicator or all thresholds in track.
 * @param currentThreshold Current threshold for the meter value.
 * @returns The color of the indicator of the meter.
 */
function getIndicatorColor(thresholdDisplay, currentThreshold, indicatorColor) {
    if (currentThreshold?.color && thresholdDisplay === 'indicator') {
        return getDvtThresholdColor(currentThreshold.color);
    }
    return indicatorColor;
}
/**
 * Returns the color of track and indicator of the meter.
 * @param value The value of the meter.
 * @param trackColor The color provided via trackColor prop.
 * @param indicatorColor The color provided via indicatorColor prop.
 * @param thresholdDisplay Specifies whether current threshold to display in track, indicator or all thresholds in track.
 * @param thresholds The thresholds for metric value of the meter.
 * @returns The color of the indicator and track of the meter.
 */
function getTrackAndIndicatorColor(value, thresholdDisplay, trackColor, indicatorColor, thresholds) {
    const currentThreshold = findThreshold(value, thresholds);
    return {
        trackColor: getTrackColor(thresholdDisplay, currentThreshold, trackColor),
        indicatorColor: getIndicatorColor(thresholdDisplay, currentThreshold, indicatorColor)
    };
}
/**
 * Returns the aria properties of the meter bar.
 * @param value The value of the meter bar.
 * @param min The minimum value of the meter bar.
 * @param max The maximum value of the meter bar.
 * @param ariaLabel The aria label of the meter bar.
 * @param ariaLabelledby The ariaLabelledBy of the meter bar.
 * @param thresholds The thresholds values for the meter bar.
 * @param isDisabled The gauge is disabled or not.
 * @param isReadonly the gauge is readonly or not.
 * @param tooltip The tooltip values for the rating gauge.
 * @returns The aria properties of the meter
 */
function getMeterAriaProps(value, min, max, ariaLabel, ariaLabelledby, thresholds, isDisabled, isReadonly, tooltip) {
    const currentThreshold = findThreshold(value, thresholds);
    const ariaValueText = currentThreshold?.accessibleLabel
        ? `${value} ${currentThreshold.accessibleLabel}`
        : `${value}`;
    const ariaLabelText = ariaLabel
        ? ariaLabel
        : tooltip && isReadonly && !isDisabled
            ? tooltip
            : undefined;
    return {
        'aria-label': ariaLabelText,
        'aria-valuenow': value,
        'aria-valuemin': min,
        'aria-valuetext': ariaValueText,
        'aria-valuemax': max,
        'aria-labelledby': ariaLabelledby,
        'aria-disabled': isDisabled ? true : undefined,
        'aria-readonly': isReadonly && !isDisabled ? true : undefined,
        role: 'slider'
    };
}
/**
 * Returns the threshold color that the current value belongs to. Returns component color if the current value does not belong to
 * any threshold or if thresholds is undefined.
 * @param value The value in meter.
 * @param thresholds The list of thresholds.
 * @returns The threshold color that current value belongs to.
 */
function getThresholdColorFromValue(value, color, thresholds) {
    const currentThreshold = findThreshold(value, thresholds);
    if (currentThreshold?.color) {
        return currentThreshold?.color;
    }
    return color;
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the angle in radians
 * @param angle The angle in degrees.
 * @returns The angle in radians.
 */
function toRad(angle) {
    return (angle * Math.PI) / 180;
}
/**
 * Returns equivalent angle between 0 and 360 (exclusive) corresponding to given angle.
 * @param angle The angle in degrees.
 * @returns Returns the posiive angle for a given angle.
 */
function getPositiveAngle(angle) {
    return (angle + 360) % 360;
}
/**
 * Returns the polar coordinate of point (x,y) relative to center (cx, cy)
 * @param cx The x coordinate of the center.
 * @param cy The y coordinate of the center.
 * @param x  The x coordinate of the point.
 * @param y  The y coordinate of the point.
 * @returns The polar coordinate of point (x,y) relative to center (cx, cy)
 */
function convertToPolar(cx, cy, x, y) {
    return {
        radius: Math.sqrt((x - cx) ** 2 + (y - cy) ** 2),
        angle: (Math.atan2(cy - y, x - cx) * 180) / Math.PI
    };
}
/**
 * Transforms the coordinate x, y in a unit square to the coordinates in given half sector. For eg, (0.5, 0.5) in full
 * unit square will be (0.5, 1) in top half and (0.5, 0) for bottom half.
 * @param x The x coordinate of the point.
 * @param y The y coordinate of the point.
 * @param sector The Sector to trasform
 * @returns The coordinate of point relative to center of the sector.
 */
function transformCoord(x, y, sector) {
    switch (sector) {
        case 'top':
            y = 2 * y;
            break;
        case 'bottom':
            y = 2 * y - 1;
            break;
        case 'left':
            x = 2 * x;
            break;
        case 'right':
            x = 2 * x - 1;
            break;
    }
    return { x, y };
}
/**
 * For a given angle and section, returns the relative coordinate of the point where the radius for
 * the angle intersects the bounding box.
 * @param angle The angle in degrees
 * @param section The section in which the meter circle lies.
 * @returns The relative coordinate of point of intersection of radius and bounding box.
 */
function getPolygonCoord(angle, section) {
    angle = getPositiveAngle(angle);
    let x, y;
    if (angle < 45) {
        y = 0.5 - 0.5 * Math.tan(toRad(angle));
        x = 1;
    }
    else if (angle < 135) {
        if (angle < 90) {
            x = 0.5 + 0.5 * Math.tan(toRad(90 - angle));
        }
        else {
            x = 0.5 - 0.5 * Math.tan(toRad(angle - 90));
        }
        y = 0;
    }
    else if (angle < 225) {
        if (angle < 180) {
            y = 0.5 - 0.5 * Math.tan(toRad(180 - angle));
        }
        else {
            y = 0.5 + 0.5 * Math.tan(toRad(angle - 180));
        }
        x = 0;
    }
    else if (angle < 315) {
        if (angle < 270) {
            x = 0.5 - 0.5 * Math.tan(toRad(270 - angle));
        }
        else {
            x = 0.5 + 0.5 * Math.tan(toRad(angle - 270));
        }
        y = 1;
    }
    else {
        x = 1;
        y = 0.5 + 0.5 * Math.tan(toRad(360 - angle));
    }
    return transformCoord(x, y, section);
}
/**
 * Returns the relative coordinate of the center of the half/full circle in which the meter circle lies.
 * @param sector The section in which the meter circle lies.
 * @returns The relative coordinate of the center.
 */
function getCenterCoord(sector) {
    return transformCoord(0.5, 0.5, sector);
}
/**
 * Returns whether the angle lies on top half of the circle
 * @param angle The angle in degrees
 * @returns Whether the angle lies on top half of the circle.
 */
function OnTopHalf(angle) {
    return angle <= 180;
}
/**
 * Returns whether the angle lies on right half of the circle
 * @param angle The angle in degrees
 * @returns Whether the angle lies on right half of the circle.
 */
function OnRightHalf(angle) {
    return angle <= 90 || angle >= 270;
}
/**
 * Returns whether the angle lies on left half of the circle
 * @param angle The angle in degrees
 * @returns Whether the angle lies on left half of the circle.
 */
function OnLeftHalf(angle) {
    return angle >= 90 && angle <= 270;
}
/**
 * Returns whether the angle lies on bottom half of the circle
 * @param angle The angle in degrees
 * @returns Whether the angle lies on bottom half of the circle.
 */
function OnBottomHalf(angle) {
    return angle >= 180 || angle === 0;
}
/**
 * Returns the Sector the meter circle lies on.
 * @param startAngle The start angle.
 * @param angleExtent The angle extent.
 * @param isRtl If the reading mode is rtl
 * @returns Which half the meter circle lies on.
 */
function getCircleSection(startAngle, angleExtent, isRtl) {
    if (angleExtent > 180) {
        return 'full';
    }
    const meanAngle = getPositiveAngle(startAngle + (isRtl ? 0.5 : -0.5) * angleExtent);
    const endAngle = getPositiveAngle(startAngle + (isRtl ? 1 : -1) * angleExtent);
    if (OnTopHalf(startAngle) && OnTopHalf(meanAngle) && OnTopHalf(endAngle)) {
        return 'top';
    }
    else if (OnRightHalf(startAngle) && OnRightHalf(meanAngle) && OnRightHalf(endAngle)) {
        return 'right';
    }
    else if (OnLeftHalf(startAngle) && OnLeftHalf(meanAngle) && OnLeftHalf(endAngle)) {
        return 'left';
    }
    else if (OnBottomHalf(startAngle) && OnBottomHalf(meanAngle) && OnBottomHalf(endAngle)) {
        return 'bottom';
    }
    return 'full';
}
/**
 * Returns the clip polygon for given startAngle and angleExtent.
 * @param startAngle The start angle of arc in degrees.
 * @param angleExtent The angle extent of arc in degrees.
 * @param isRtl  The reading mode of the document.
 * @param section The Sector circular meter lies on.
 * @returns The clippath for given startAngle and angleExtent
 */
function getClipPath(startAngle, angleExtent, isRtl, section) {
    let start = isRtl ? startAngle + angleExtent : startAngle;
    const firstVertexCoords = getPolygonCoord(start, section);
    let clipPath = `${firstVertexCoords.x * 100}% ${firstVertexCoords.y * 100}%`;
    let nextVertex, nextVertexCoords;
    do {
        nextVertex = Math.max(start - angleExtent, 45 * (Math.ceil(start / 45) - 1));
        nextVertexCoords = getPolygonCoord(nextVertex, section);
        clipPath += `, ${nextVertexCoords.x * 100}% ${nextVertexCoords.y * 100}%`;
        angleExtent = angleExtent - (start - nextVertex);
        start = nextVertex;
    } while (nextVertex > start - angleExtent);
    const centerVertex = getCenterCoord(section);
    // close the polygon with a vertex in center to get the radial clipping
    return `polygon(${clipPath}, ${centerVertex.x * 100}% ${centerVertex.y * 100}%)`;
}
/**
 * Returns the clip polygon for given percentage.
 * @param percentage The percentage of the circle the clipPath covers.
 * @returns The clippath for given percentage it covers
 */
function getProgressClipPath(percentage) {
    let tangent;
    if (percentage < 0.125) {
        tangent = _calculateTangent(percentage) + 50;
        return `polygon(50% 0, ${tangent}% 0, 50% 50%)`;
    }
    else if (percentage < 0.375) {
        if (percentage < 0.25) {
            tangent = 50 - _calculateTangent(0.25 - percentage);
        }
        else {
            tangent = _calculateTangent(percentage - 0.25) + 50;
        }
        return `polygon(50% 0, 100% 0, 100% ${tangent}%, 50% 50%)`;
    }
    else if (percentage < 0.625) {
        if (percentage < 0.5) {
            tangent = 50 + _calculateTangent(0.5 - percentage);
        }
        else {
            tangent = 50 - _calculateTangent(percentage - 0.5);
        }
        return `polygon(50% 0, 100% 0, 100% 100%, ${tangent}% 100%, 50% 50%)`;
    }
    else if (percentage < 0.875) {
        if (percentage < 0.75) {
            tangent = 50 + _calculateTangent(0.75 - percentage);
        }
        else {
            tangent = 50 - _calculateTangent(percentage - 0.75);
        }
        return `polygon(50% 0, 100% 0, 100% 100%, 0% 100%, 0% ${tangent}%, 50% 50%)`;
    }
    tangent = 50 - _calculateTangent(1 - percentage);
    return `polygon(50% 0, 100% 0, 100% 100%, 0% 100%, 0% 0%, ${tangent}% 0%, 50% 50%)`;
}
function _calculateTangent(percentage) {
    return 50 * Math.tan(percentage * 2 * Math.PI);
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { convertToPolar, findThreshold, getCenterCoord, getCircleSection, getClipPath, getMeterAriaProps, getPositiveAngle, getProgressClipPath, getThresholdColorFromValue, getTrackAndIndicatorColor, validateRange };
//# sourceMappingURL=PRIVATE_meterUtils.js.map
