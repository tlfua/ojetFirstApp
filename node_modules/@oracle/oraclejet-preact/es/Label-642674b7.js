/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { useFormFieldContext } from './hooks/UNSAFE_useFormFieldContext.js';
import './utils/UNSAFE_classNames.js';
import { useFormContext } from './hooks/UNSAFE_useFormContext.js';
import { useComponentTheme } from './hooks/UNSAFE_useComponentTheme.js';
import { CompactLabelAssistance } from './UNSAFE_UserAssistance.js';
import { TextFieldRedwoodTheme } from './UNSAFE_TextField/themes/redwood/TextFieldTheme.js';
import { LabelRedwoodTheme } from './UNSAFE_Label/themes/redwood/LabelTheme.js';
import { c as classNames } from './classNames-f414daad.js';

const StyledLabel = ({ hasValue, readonly, disabled, isFocused, isRequiredShown, helpIconId, helpSourceLink, helpSourceText, userAssistanceDensity = 'reflow', variant = 'inside', parentComponentVariant = 'textField', ...props }) => {
    const { isFormLayout, isReadonly: isReadonlyForm, labelWrapping } = useFormContext();
    const isInside = variant === 'inside' || variant === 'insideError' || variant === 'insideWarning';
    const inTextField = parentComponentVariant === 'textField';
    // because variants have to match strings, we have to take any boolean props and convert
    // them to a string value, (ie prefixed with "is" or "non")
    const { classes, styles: { uaDensityCompactLabel, uaDensityCompactLabelStart, uaDensityCompactLabelTopInside } } = useComponentTheme(LabelRedwoodTheme, {
        labelWrapping,
        position: variant,
        inside: isInside ? 'isInside' : 'notInside',
        inEnabledForm: isFormLayout && !isReadonlyForm ? 'isInEnabledForm' : 'notInEnabledForm',
        readonly: readonly ? 'isReadonly' : 'notReadonly',
        focused: isFocused ? 'isFocused' : 'nonFocused',
        formLayout: isFormLayout ? 'isFormLayout' : 'nonFormLayout',
        readonlyForm: isReadonlyForm ? 'isReadonlyForm' : 'notReadonlyForm',
        value: hasValue ? 'hasValue' : 'noValue',
        valueOrFocus: hasValue || isFocused ? 'hasValueOrFocus' : 'noValueOrFocus',
        animatedWhenInside: inTextField ? 'isAnimated' : 'notAnimated',
        disabled: inTextField && disabled ? 'isDisabled' : 'nonDisabled',
        userAssistanceDensity
    });
    const { baseTheme: textFieldTheme } = useComponentTheme(TextFieldRedwoodTheme);
    // TODO: We need to decide whether to standardize on 'class' or 'className'.  Otherwise, we'll
    // run into issues destructuring style interpolations, for example having to concatenate both.
    const compactLabelStyles = classNames([
        uaDensityCompactLabel,
        variant === 'start' ? uaDensityCompactLabelStart : uaDensityCompactLabelTopInside
    ]);
    const compactUADLabel = jsx("label", { ...props, class: compactLabelStyles });
    return userAssistanceDensity === 'compact' ? (jsxs("div", { class: classNames([classes, textFieldTheme]), children: [variant !== 'start' && compactUADLabel, jsx(CompactLabelAssistance, { isRequiredShown: isRequiredShown, helpIconId: helpIconId, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, labelEdge: variant === 'top' || variant === 'start' ? variant : 'inside' }), variant === 'start' && compactUADLabel] })) : (jsx("label", { ...props, class: classNames([classes, textFieldTheme]) }));
};
const Label = ({ forId, ...props }) => {
    const { hasValue, isDisabled, isFocused, isReadonly } = useFormFieldContext();
    return (jsx(StyledLabel, { for: forId, hasValue: hasValue, disabled: isDisabled, isFocused: isFocused, readonly: isReadonly, ...props }));
};

export { Label as L };
//# sourceMappingURL=Label-642674b7.js.map
