/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx, jsxs } from 'preact/jsx-runtime';

import { Grid } from './UNSAFE_Grid.js';
import './utils/UNSAFE_classNames.js';
import { c as classNames } from './classNames-f414daad.js';
import './UNSAFE_Text.js';
import { useTabbableMode } from './hooks/UNSAFE_useTabbableMode.js';
import { T as Text } from './Text-0dad47bb.js';

const childrenStyles = "aum1n0";
// TODO: revisit idea of negative margin when selector has a proper API for handling spacing
// Jira: JET-54543
// negative margin added to selector
const selectorStyles = "_1ao9mn4";
// most content will be vertically centered
const centerVerticalStyles = "dprr4x";
// extra spacing is needed between meta, trailing, and action components
const leftPaddingStyles = "_1dkd4c6";
// the central text area displays overline, primary, secondary, and tertiary in a column
const flexColumnStyles$1 = "emn4j9";
// "extra" components in row 1 and the link in row 2 are justified on the righthand side of the list item layout
const flexRowStyles = "_7h83vg";
const rightJustifyStyles = "_19o6j82";
const rowAlignStyles = "_1rc1gid";
function ListItemLayout({
  children,
  selector,
  leading,
  primary,
  secondary,
  tertiary,
  overline,
  metadata,
  trailing,
  action,
  quaternary,
  navigation
}) {
  // generate grid skeleton, adding cells based on which props are defined
  const {
    columnsTemplate,
    firstCell,
    secondCell,
    lastCell,
    hasSecondRow
  } = getColumnsTemplate(selector, leading, metadata, trailing, action, quaternary, navigation);
  // if ListItemLayout component has a child (ListItemTextLayout) then render that instead of individual props
  const textArea = children ? jsx("div", {
    className: childrenStyles,
    children: children
  }) : jsxs("div", {
    className: flexColumnStyles$1,
    children: [jsx("div", {
      children: overline
    }), jsx("div", {
      children: primary
    }), jsx("div", {
      children: secondary
    }), jsx("div", {
      children: tertiary
    })]
  });
  // a second row is needed when quaternary or navigation are defined
  const secondRow = hasSecondRow ? [firstCell && jsx("span", {
    children: " "
  }), secondCell && jsx("span", {
    children: " "
  }), jsx("div", {
    className: rowAlignStyles,
    children: quaternary
  }), lastCell && jsx("div", {
    className: rightJustifyStyles,
    children: navigation
  })] : null;
  return jsxs(Grid, {
    gap: "4x",
    gridTemplateColumns: columnsTemplate,
    children: [firstCell, secondCell, jsx("div", {
      className: centerVerticalStyles,
      children: textArea
    }), lastCell, secondRow]
  });
}
function getColumnsTemplate(selector, leading, metadata, trailing, action, quaternary, navigation) {
  const columnsTemplateBuilder = [];
  let firstCell = null;
  if (selector) {
    columnsTemplateBuilder.push('auto');
    firstCell = jsx("div", {
      className: selectorStyles,
      children: selector
    });
  }
  let secondCell = null;
  if (leading) {
    columnsTemplateBuilder.push('auto');
    secondCell = jsx("div", {
      className: centerVerticalStyles,
      children: leading
    });
  }
  columnsTemplateBuilder.push('1fr'); // Text area always gets 1 full fraction of allotted space
  let lastCell = null;
  if (metadata || trailing || action || navigation) {
    columnsTemplateBuilder.push('auto');
    lastCell = jsxs("div", {
      className: flexRowStyles,
      children: [jsx("div", {
        className: classNames([centerVerticalStyles, metadata ? leftPaddingStyles : '']),
        children: metadata
      }), jsx("div", {
        className: classNames([centerVerticalStyles, trailing ? leftPaddingStyles : '']),
        children: trailing
      }), jsx("div", {
        className: classNames([centerVerticalStyles, action ? leftPaddingStyles : '']),
        children: action
      })]
    });
  }
  const columnsTemplate = columnsTemplateBuilder.join(' ');
  const hasSecondRow = quaternary || navigation ? true : false;
  return {
    columnsTemplate,
    firstCell,
    secondCell,
    lastCell,
    hasSecondRow
  };
}

const textVariants = {
    primary: 'primary',
    secondary: 'primary',
    tertiary: 'secondary',
    quaternary: 'secondary',
    overline: 'secondary',
    metadata: 'secondary'
};
const textSizes = {
    primary: 'md',
    secondary: 'sm',
    tertiary: 'xs',
    quaternary: 'sm',
    overline: 'xs',
    metadata: 'sm'
};
const textLineClamps = {
    primary: undefined,
    secondary: 2,
    tertiary: 2,
    quaternary: 2,
    overline: 1,
    metadata: 1
};
function ListItemText({ children, variant }) {
    const { isTabbable } = useTabbableMode();
    const textContent = (jsx(Text, { variant: textVariants[variant], size: textSizes[variant], lineClamp: textLineClamps[variant], children: children }));
    return isTabbable ? jsx("div", { tabIndex: 0, children: textContent }) : textContent;
}

const flexColumnStyles = "_18rdkei";
function ListItemTextLayout({
  primary,
  secondary,
  tertiary,
  overline
}) {
  return jsxs("div", {
    className: flexColumnStyles,
    children: [jsx(ListItemText, {
      variant: "overline",
      children: overline
    }), jsx(ListItemText, {
      variant: "primary",
      children: primary
    }), jsx(ListItemText, {
      variant: "secondary",
      children: secondary
    }), jsx(ListItemText, {
      variant: "tertiary",
      children: tertiary
    })]
  });
}

export { ListItemLayout as L, ListItemText as a, ListItemTextLayout as b };
//# sourceMappingURL=ListItemTextLayout-65306fbe.js.map
