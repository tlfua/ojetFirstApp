/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import './UNSAFE_ButtonLayout.js';
import { NavDownIcon as SvgNavDown } from './PRIVATE_ThemedIcons/NavDownIcon.js';
import './UNSAFE_Menu.js';
import './UNSAFE_BaseButton.js';
import './utils/UNSAFE_classNames.js';
import { TabbableModeContext } from './hooks/UNSAFE_useTabbableMode.js';
import { dimensionInterpolations } from './utils/UNSAFE_interpolations/dimensions.js';
import { mergeInterpolations } from './utils/UNSAFE_mergeInterpolations.js';

import { forwardRef } from 'preact/compat';
import { useState, useCallback, useRef, useImperativeHandle } from 'preact/hooks';
import { c as classNames } from './classNames-f414daad.js';
import { B as BaseButton } from './BaseButton-06d74a34.js';
import { B as ButtonLayout } from './ButtonLayout-8ea4b106.js';
import { M as Menu } from './Menu-31a689f5.js';

const compStyles = {
  divider: "_1wi4nye",
  disabledDivider: "_1qljftu",
  icon: "knfga3",
  root: "_1jbmydi",
  childrenMargins: "_12wt61q"
};
const menuButtonStyling = ['embedded', 'min', 'noBorderRadiusStart'];
const menuButtonActiveStyling = [...menuButtonStyling, 'active'];
const actionbuttonStyling = ['embedded', 'fill', 'noBorderRadiusEnd'];
const actionButtonActiveStyling = [...actionbuttonStyling, 'active'];
const interpolations = [...Object.values(dimensionInterpolations)];
const styleInterpolations = mergeInterpolations(interpolations);
/**
 * A SplitMenuButton is a combined action and menu button.
 */
const SplitMenuButton = forwardRef(({
  children,
  label = '',
  variant = 'outlined',
  isDisabled = false,
  size = 'md',
  onAction,
  ...props
}, ref) => {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [isActive, setIsActive] = useState(false);
  const {
    class: cls,
    ...styles
  } = styleInterpolations(props);
  // SPACE or ENTER on root area invokes action, as does CLICK/TAP on LEFT SIDE ACTION AREA
  // DOWN ARROW invokes menu, as does CLICK/TAP on RIGHT SIDE MENU AREA
  const onKeyDown = useCallback(event => {
    if (event.key === ' ' || event.key === 'Enter') {
      setIsActive(true);
    } else if (event.key == 'ArrowDown') {
      !isDisabled && setIsMenuOpen(menuOpen => !menuOpen);
      // Prevent page scroll for down arrow, user definitely wanted to show menu in this case.
      // Don't prevent other keypress defaults, as user may want to hold SPACE down to scroll page.
      event.preventDefault();
    }
  }, [isDisabled, setIsMenuOpen, setIsActive]);
  const onKeyUp = useCallback(event => {
    if (event.key === ' ' || event.key === 'Enter') {
      !isDisabled && onAction && onAction();
      setIsActive(false);
    }
  }, [isDisabled, onAction, setIsActive]);
  const onBlur = useCallback(() => {
    setIsActive(false);
  }, [setIsActive]);
  const _ref = useRef(null);
  useImperativeHandle(ref, () => _ref.current, [_ref]);
  const menuHandler = () => {
    setIsMenuOpen(!isMenuOpen);
  };
  const handleClose = e => {
    //Focus has to be set on the launcher when menu is dismissed or
    //item is "selected"
    if (e.reason === 'dismissed' || e.reason === 'itemAction') {
      _ref.current?.focus();
    }
    setIsMenuOpen(false);
  };
  const dividerStyles = classNames([compStyles.divider, isDisabled && compStyles.disabledDivider]);
  const rootStyles = classNames([compStyles.root]);
  // Using Span for top button allows us to avoid :hover state rendering by
  // taking advantage of :enabled not on spans
  const rootButton = () => {
    return jsx(BaseButton, {
      elementDetails: {
        type: 'span'
      },
      ref: _ref,
      isDisabled: isDisabled,
      styling: ['container', 'min'],
      variant: variant,
      size: size,
      "aria-label": label,
      "aria-roledescription": "split menu button, press down arrow to invoke menu",
      "aria-expanded": isMenuOpen,
      children: jsxs(TabbableModeContext.Provider, {
        value: {
          isTabbable: false
        },
        children: [jsx(BaseButton, {
          elementDetails: {
            type: 'span'
          },
          variant: variant,
          styling: getActionButtonStyling(isActive),
          size: size,
          isDisabled: isDisabled,
          "aria-hidden": true,
          onAction: onAction,
          children: label
        }), jsx("div", {
          class: `${dividerStyles}`
        }), jsx(BaseButton, {
          elementDetails: {
            type: 'span'
          },
          variant: variant,
          styling: getMenuButtonStyling(isMenuOpen),
          size: size,
          isDisabled: isDisabled,
          "aria-hidden": true,
          onAction: menuHandler,
          children: jsx(ButtonLayout, {
            display: "icons",
            startIcon: jsx(SvgNavDown, {}),
            size: size,
            styling: "embedded"
          })
        })]
      })
    });
  };
  if (isDisabled) {
    return jsx("span", {
      role: "toolbar",
      class: `${rootStyles} ${cls}`,
      style: styles,
      children: rootButton()
    });
  } else {
    return jsxs("span", {
      role: "toolbar",
      class: `${rootStyles} ${cls}`,
      style: styles,
      onKeyDown: !isDisabled && onKeyDown,
      onKeyUp: onKeyUp,
      onBlur: onBlur,
      children: [rootButton(), jsx(Menu, {
        anchorRef: _ref,
        isOpen: isMenuOpen,
        onClose: handleClose,
        children: jsx("span", {
          className: compStyles.childrenMargins,
          children: children
        })
      })]
    });
  }
});
function getMenuButtonStyling(isActive) {
  return isActive ? menuButtonActiveStyling : menuButtonStyling;
}
function getActionButtonStyling(isActive) {
  return isActive ? actionButtonActiveStyling : actionbuttonStyling;
}

export { SplitMenuButton as S };
//# sourceMappingURL=SplitMenuButton-a7ac9d3e.js.map
