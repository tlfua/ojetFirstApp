/* @oracle/oraclejet-preact: 15.1.2 */
import { jsxs, jsx } from 'preact/jsx-runtime';
import { useRef, useState, useLayoutEffect, useMemo, useCallback, useEffect } from 'preact/hooks';
import { forwardRef } from 'preact/compat';
import { o as offset, b, l as logicalSide, D, L, m, k, u as useFloating, N } from './index-326d7a5f.js';
import { mergeRefs } from './utils/PRIVATE_refUtils.js';
import { useOutsideClick } from './hooks/UNSAFE_useOutsideClick.js';
import { useUser } from './hooks/UNSAFE_useUser.js';
import { useComponentTheme } from './hooks/UNSAFE_useComponentTheme.js';
import './utils/UNSAFE_classNames.js';
import { a as rgba } from './utils-9a0cb8dc.js';
import { colorSchemeVars } from './Common/themes/themeContract.css.js';
import { FloatingRedwoodTheme } from './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import { c as classNames } from './classNames-f414daad.js';
import { floatingVisibilityStyles, floatingStyle } from './UNSAFE_Floating/themes/FloatingStyles.css.js';
import { a as assignInlineVars } from './vanilla-extract-dynamic.esm-33365337.js';
import { floatingVars } from './UNSAFE_Floating/themes/FloatingContract.css.js';

const ARROW_SIZE = 7;
const ARROW_SIZE_CORNER = 6;
const ARROW_INNER_SIZE = 5;
const ARROW_INNER_SIZE_CORNER = 5;
const FloatingTail = forwardRef(({ data, anchorRef, tail, isRtl, backgroundColor }, ref) => {
    const { styles, baseTheme } = useComponentTheme(FloatingRedwoodTheme);
    const { baseStyle } = styles;
    const arrowRef = useRef(null);
    const [arrowStyles, setArrowStyles] = useState({
        arrowStyle: { visibility: 'hidden' },
        arrowInnerStyle: { visibility: 'hidden' }
    });
    useLayoutEffect(() => {
        if (arrowRef.current == null)
            return;
        const { isCornerVerticalPlacement, isCornerHorizontalPlacement } = isCorner(anchorRef, tail, data);
        setArrowStyles(setStyles(tail, isRtl, isCornerVerticalPlacement, isCornerHorizontalPlacement, data, backgroundColor));
    }, [data?.placement, data?.x, data?.y, data?.offset, data?.arrow, tail, isRtl, anchorRef]);
    const stableRef = useMemo(() => mergeRefs(ref, arrowRef), [ref, arrowRef]);
    return (tail === 'simple' && (jsxs("div", { ref: stableRef, class: classNames([baseTheme, baseStyle]), style: arrowStyles.arrowStyle, children: [' ', jsx("div", { class: classNames([baseStyle]), style: arrowStyles.arrowInnerStyle }), ' '] })));
});
function isCorner(anchorRef, tail, data) {
    if (tail === 'simple' && data && data.arrow) {
        const { centerOffset } = data.arrow;
        const arrowSize = ARROW_SIZE;
        let anchorRefHeight = 0;
        let anchorRefWidth = 0;
        const current = anchorRef.current;
        // @ts-ignore. Type 'Element | Coords' issues
        // Property 'x' does not exist on type 'Element'.
        // Property 'y' does not exist on type 'Element'.
        const isAnchorRefElement = current?.x === undefined && current?.y === undefined;
        if (isAnchorRefElement) {
            // @ts-ignore. Property 'getBoundingClientRect' does not exist on type 'Coords'.
            anchorRefHeight = Math.round(current.getBoundingClientRect().height);
            // @ts-ignore. Property 'getBoundingClientRect' does not exist on type 'Coords'.
            anchorRefWidth = Math.round(anchorRef.current?.getBoundingClientRect().width);
        }
        const isCornerVerticalPlacement = isAnchorRefElement
            ? Math.abs(centerOffset) >= anchorRefHeight / 2 - arrowSize / 2
            : ['start-top-corner', 'start-bottom-corner', 'end-top-corner', 'end-bottom-corner'].includes(data.origPlacement);
        const isCornerHorizontalPlacement = isAnchorRefElement
            ? Math.abs(centerOffset) >= anchorRefWidth / 2 - arrowSize / 2
            : ['top-start-corner', 'top-end-corner', 'bottom-start-corner', 'bottom-end-corner'].includes(data.origPlacement);
        return { isCornerVerticalPlacement, isCornerHorizontalPlacement };
    }
    else
        return { isCornerVerticalPlacement: false, isCornerHorizontalPlacement: false };
}
function setStyles(
//arrowEl: HTMLDivElement,
tail, isRtl, isCornerVerticalPlacement, isCornerHorizontalPlacement, data, backgroundColor) {
    const result = { visibility: 'visible' };
    const innerResult = { visibility: 'visible' };
    if (tail === 'simple' && data && data.arrow) {
        const { x, y, centerOffset } = data.arrow;
        const arrowSize = ARROW_SIZE;
        const arrowSizeCorner = ARROW_SIZE_CORNER;
        //const arrowInnerEl = arrowEl.querySelector('div') as Element;
        const arrowInnerSize = ARROW_INNER_SIZE;
        const arrowInnerSizeCorner = ARROW_INNER_SIZE_CORNER;
        const isCenter = centerOffset === 0;
        const isCenterOffsetPositive = centerOffset > 0;
        // Set sizes of the arrow
        setArrowSizes(isCornerVerticalPlacement || isCornerHorizontalPlacement);
        // Corner vs. normal arrow
        function setArrowSizes(isCornerPlacement) {
            // Outer arrow (shadow)
            const arrowFinalSize = isCornerPlacement ? arrowSizeCorner : arrowSize;
            setArrowStyle({
                // Tracked: 
                borderTop: `${getSize(arrowFinalSize)} solid ${rgba(colorSchemeVars.palette.neutral[90], 0.1)}`,
                borderRight: getTransparentBorder(arrowFinalSize),
                borderLeft: getTransparentBorder(arrowFinalSize)
            }, result);
            // Inner arrow
            const arrowInnerFinalSize = isCornerPlacement ? arrowInnerSizeCorner : arrowInnerSize;
            setArrowInnerStyle({
                // Tracked: 
                borderTop: `${getSize(arrowInnerFinalSize)} solid ${backgroundColor}`,
                borderRight: `${getTransparentBorder(arrowInnerFinalSize)}`,
                borderLeft: `${getTransparentBorder(arrowInnerFinalSize)}`
            }, innerResult);
        }
        function setArrowStyle(style, result) {
            Object.assign(result, style);
        }
        function setArrowInnerStyle(style, result) {
            Object.assign(result, style);
        }
        function getTurn(eighth) {
            return `rotate(${eighth * 45}deg)`;
        }
        function getSize(size) {
            return `${size}px`;
        }
        function getTransparentBorder(size) {
            return `${getSize(size)} solid transparent`;
        }
        const placementArr = data.placement.split('-');
        const side = placementArr[0];
        switch (side) {
            case 'top':
                setArrowTop();
                break;
            case 'end':
                isRtl ? setArrowStart() : setArrowEnd();
                break;
            case 'bottom':
                setArrowBottom();
                break;
            case 'start':
                isRtl ? setArrowEnd() : setArrowStart();
                break;
        }
        function setArrowTop() {
            if (x != undefined) {
                if (isCornerHorizontalPlacement) {
                    // Top corners
                    setArrowStyle({
                        top: '',
                        bottom: getSize(-arrowSize + 2),
                        left: getSize(x + (isCenterOffsetPositive ? 5 : -5)),
                        transform: getTurn(isCenterOffsetPositive ? 5 : 3)
                    }, result);
                    setCornerArrowInner();
                }
                else {
                    setArrowStyle({
                        top: '',
                        bottom: getSize(-arrowSize),
                        left: isCenter ? getSize(x) : getSize(x + (isCenterOffsetPositive ? 1 : -1)),
                        transform: getTurn(0)
                    }, result);
                    setNonCornerArrowInner();
                }
            }
        }
        function setArrowEnd() {
            if (y != undefined) {
                if (isCornerVerticalPlacement) {
                    // End corners
                    setArrowStyle({
                        top: getSize(y + (isCenterOffsetPositive ? 2 : -2)),
                        right: '',
                        left: getSize(-arrowSize - 1),
                        transform: getTurn(isCenterOffsetPositive ? 7 : 5)
                    }, result);
                    setCornerArrowInner();
                }
                else {
                    // End
                    setArrowStyle({
                        top: isCenter ? getSize(y) : getSize(y + (isCenterOffsetPositive ? -2 : +2)),
                        right: '',
                        left: getSize(-arrowSize * 1.5),
                        transform: getTurn(2)
                    }, result);
                    setNonCornerArrowInner();
                }
            }
        }
        function setArrowBottom() {
            if (x != undefined) {
                if (isCornerHorizontalPlacement) {
                    // Bottom corners
                    setArrowStyle({
                        top: getSize(-arrowSize + 3),
                        bottom: '',
                        left: getSize(x + (isCenterOffsetPositive ? 4 : -4)),
                        transform: getTurn(isCenterOffsetPositive ? 2 : 6)
                    }, result);
                    setArrowInnerStyle({
                        top: getSize(-arrowInnerSize),
                        left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? 1 : -1))
                    }, innerResult);
                }
                else {
                    setArrowStyle({
                        top: getSize(-arrowSize),
                        bottom: '',
                        left: isCenter ? getSize(x) : getSize(x + (isCenterOffsetPositive ? 1 : -1)),
                        transform: getTurn(4)
                    }, result);
                    setNonCornerArrowInner();
                }
            }
        }
        function setArrowStart() {
            if (y != undefined) {
                if (isCornerVerticalPlacement) {
                    // Start corners
                    setArrowStyle({
                        top: getSize(y + (isCenterOffsetPositive ? 2 : -2)),
                        right: getSize(-arrowSize - 1),
                        left: '',
                        transform: getTurn(isCenterOffsetPositive ? 1 : 3)
                    }, result);
                    setArrowInnerStyle({
                        top: getSize(-arrowInnerSize),
                        left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? -2 : 2))
                    }, innerResult);
                }
                else {
                    // Start
                    setArrowStyle({
                        top: isCenter ? getSize(y) : getSize(y + (isCenterOffsetPositive ? -2 : +2)),
                        right: getSize(-arrowSize * 1.5),
                        left: '',
                        transform: getTurn(6)
                    }, result);
                    setNonCornerArrowInner();
                }
            }
        }
        function setCornerArrowInner() {
            setArrowInnerStyle({
                top: getSize(-arrowInnerSize),
                left: getSize(-arrowInnerSize + (isCenterOffsetPositive ? 2 : -2))
            }, innerResult);
        }
        function setNonCornerArrowInner() {
            setArrowInnerStyle({
                top: getSize(-arrowInnerSize - 2),
                left: getSize(-arrowInnerSize)
            }, innerResult);
        }
    }
    return { arrowStyle: result, arrowInnerStyle: innerResult };
}

function isElement(value) {
    return value instanceof Element;
}
/**
 * A floating component allows the user to create a floating element that is displayed relative to an anchor element or pointer coordinates
 * and at the same time on the "top layer" of all other elements.
 * The Floating component is a base component and is often used by such components as Popup, Tooltip, SelectMultiple, Menu and other components.
 */
const Floating = forwardRef(({ children, backgroundColor, onClickOutside, placement = 'bottom', anchorRef, offsetValue, class: className, tail = 'none', flipOptions = { mainAxis: true, crossAxis: false }, shiftOptions = { mainAxis: true, crossAxis: false }, sizeOptions = { isMaxHeightAdjusted: false, isMaxWidthAdjusted: false }, boundaryOptions = { padding: 0 }, onPosition }, ref) => {
    const arrowRef = useRef(null);
    const [positionData, setPositionData] = useState();
    const [previousAnchor, setPreviousAnchor] = useState(null);
    // we need to be sure anchorRef.current exists in first call
    // to be able to set the previousAnchor state
    useLayoutEffect(() => {
        setPreviousAnchor(anchorRef.current);
    }, []);
    // In case anchorRef.current changes and we need to update floating position
    // when it changes, we need to have copy in the state.
    // For example when anchorRef is Coords( virtual element)
    if (anchorRef.current !== previousAnchor) {
        setPreviousAnchor(anchorRef.current);
    }
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const _onPosition = useCallback((data) => {
        setPositionData(data);
        onPosition?.(data);
    }, [placement, anchorRef, tail, onPosition]);
    const middleware = [
        offset(offsetValue),
        b({
            mainAxis: flipOptions.mainAxis,
            crossAxis: flipOptions.crossAxis,
            fallbackPlacements: flipOptions.fallbackPlacements?.map((placement) => logicalSide(placement, direction)),
            padding: boundaryOptions.padding
        }),
        D({
            mainAxis: shiftOptions.mainAxis,
            crossAxis: shiftOptions.crossAxis,
            limiter: L({
                mainAxis: shiftOptions.mainAxis,
                crossAxis: shiftOptions.crossAxis
            })
        }),
        ...(arrowRef.current
            ? [
                m({
                    element: arrowRef.current
                })
            ]
            : [])
    ];
    if (sizeOptions.isMaxHeightAdjusted || sizeOptions.isMaxWidthAdjusted) {
        middleware.push(k({
            apply({ availableWidth, availableHeight, elements }) {
                if (sizeOptions.isMaxHeightAdjusted) {
                    if (parseInt(elements.floating.style.maxHeight) !== availableHeight) {
                        Object.assign(elements.floating.style, {
                            maxHeight: `${Math.min(availableHeight, sizeOptions.maxHeightCeiling || availableHeight)}px`
                        });
                    }
                }
                if (sizeOptions.isMaxWidthAdjusted) {
                    if (parseInt(elements.floating.style.maxWidth) !== availableWidth) {
                        Object.assign(elements.floating.style, {
                            maxWidth: `${Math.min(availableWidth, sizeOptions.maxWidthCeiling || availableWidth)}px`
                        });
                    }
                }
            },
            padding: boundaryOptions.padding
        }));
    }
    const { x, y, reference, floating, refs, update } = useFloating({
        placement: placement,
        middleware: middleware,
        onPosition: _onPosition
    });
    // To solve "loop limit exceeds" problem from the ResizeObserver in autoUpdate
    // we need to make sure that we utilize autoUpdate function
    // after the Floating component is positioned and has x, y coordinates.
    const [isPositioned, setIsPositioned] = useState(false);
    // here autoUpdate should be called only once during the Component lifecycle,
    // if the floating, reference, placement and middleware do not change
    useEffect(() => {
        if (!refs.reference.current || !refs.floating.current || isPositioned !== true) {
            return;
        }
        return N(refs.reference.current, refs.floating.current, update);
    }, [refs.floating, refs.reference, update, isPositioned]);
    // here we should know when the Floating is positioned
    useEffect(() => {
        if (x != null && y != null) {
            setIsPositioned(true);
        }
    }, [x, y]);
    useOutsideClick({ isDisabled: false, ref: refs.floating, handler: onClickOutside });
    useLayoutEffect(() => {
        if (isElement(previousAnchor)) {
            const element = previousAnchor;
            reference(element);
            return;
        }
        const coords = previousAnchor;
        const virtualEl = {
            getBoundingClientRect() {
                return {
                    width: 0,
                    height: 0,
                    x: coords.x,
                    y: coords.y,
                    top: coords.y,
                    left: coords.x,
                    right: coords.x,
                    bottom: coords.y
                };
            }
        };
        if (coords && coords.x != null) {
            reference(virtualEl);
        }
    }, [previousAnchor, reference]);
    const stableRef = useMemo(() => mergeRefs(ref, floating), [ref, floating]);
    const positionStyle = { top: y, left: x };
    let assignedVars = {}; // empty var override unless background is specified
    if (backgroundColor) {
        assignedVars = assignInlineVars({
            [floatingVars.backgroundColor]: backgroundColor
        });
    }
    const visibilityStyles = x == null && y == null ? floatingVisibilityStyles.hidden : floatingVisibilityStyles.visible;
    const floatingClasses = classNames([className, floatingStyle, visibilityStyles]);
    const content = (jsxs("div", { class: floatingClasses, ref: stableRef, style: { ...positionStyle, ...assignedVars }, children: [children, jsx(FloatingTail, { ref: arrowRef, backgroundColor: backgroundColor, data: positionData, anchorRef: anchorRef, tail: tail, isRtl: isRtl })] }));
    return content;
});

export { Floating as F };
//# sourceMappingURL=Floating-2d909840.js.map
