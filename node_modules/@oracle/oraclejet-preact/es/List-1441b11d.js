/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx } from 'preact/jsx-runtime';
import { useRef, useMemo, useEffect, useState, useCallback } from 'preact/hooks';
import './utils/UNSAFE_classNames.js';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { isKeyDefined, containsKey } from './utils/UNSAFE_keys.js';
import './PRIVATE_LoadMoreCollection.js';
import './PRIVATE_VirtualizedCollection.js';
import { memo } from 'preact/compat';
import { TabbableModeContext } from './hooks/UNSAFE_useTabbableMode.js';
import './UNSAFE_FocusTrap.js';
import { useId } from './hooks/UNSAFE_useId.js';
import { useInteractionStyle } from './hooks/UNSAFE_useInteractionStyle.js';
import { mergeInterpolations } from './utils/UNSAFE_mergeInterpolations.js';
import './utils/UNSAFE_interpolations/flexitem.js';
import { listItemMultiVariantStyles, listItemStyles, sparkleStyles, listStyles } from './PRIVATE_List/themes/ListStyles.css.js';
import { c as classNames } from './classNames-f414daad.js';
import { f as flexitemInterpolations } from './flexitem-89d8a00a.js';
import { F as FocusTrap } from './FocusTrap-9dc31155.js';
import { useSelection } from './hooks/PRIVATE_useSelection.js';
import { useCurrentKey } from './hooks/PRIVATE_useCurrentKey.js';
import { useCollectionFocusRing } from './hooks/PRIVATE_useCollectionFocusRing.js';
import { useTabbableModeSet } from './hooks/PRIVATE_useTabbableModeSet.js';
import { useItemAction } from './hooks/PRIVATE_useItemAction.js';
import { S as SkeletonContainer } from './SkeletonContainer-8f229433.js';
import './UNSAFE_Skeleton.js';
import './UNSAFE_Flex.js';
import { keyExtractor, getPrevNextKey, findElementByKey, getFirstVisibleKey } from './utils/PRIVATE_collectionUtils.js';
import { Selector } from './UNSAFE_Selector.js';
import { useCollectionGestureContext } from './hooks/PRIVATE_useCollectionGestureContext.js';
import { P as PLACEHOLDER_STYLE_CLASS, V as VirtualizedCollection } from './VirtualizedCollection-435128ef.js';
import { L as LoadMoreCollection, a as LOADMORE_STYLE_CLASS } from './LoadMoreCollection-213ad68a.js';
import { F as Flex } from './Flex-46adb0e4.js';
import { S as Skeleton } from './Skeleton-18c022d9.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * List Roles need to be kept in matching sets, this module encapsulates the sets
 *
 * @param ariaRole
 * @returns matching, valid set of roles
 */
const getListViewRoles = (ariaRole) => {
    switch (ariaRole) {
        case 'listbox':
            return { list: 'listbox', item: 'presentation', cell: 'option' };
        case 'treegrid':
            return { list: 'treegrid', item: 'row', cell: 'gridcell' };
        default:
            return { list: 'grid', item: 'row', cell: 'gridcell' };
    }
};

// default style class for items in ListView
const ITEM_STYLE_CLASS = 'oj-c-listview-item';
const ITEM_SELECTOR = '.' + ITEM_STYLE_CLASS;
/**
 * The internal component used to render a single item in ListView.
 */
function ListViewItem({ children, itemKey, itemIndex, itemDepth, isFocused, isFocusRingVisible, isActive, isGridlineVisible, isSelected, isTopGridlineVisible = false, isTabbable = false, role, selectionMode, suggestion, currentItemVariant }) {
    const rootRef = useRef(null);
    const roles = useMemo(() => getListViewRoles(role), [role]);
    // some roles come with related aria attributes which need to be set
    const cellRoleAttributes = roles.cell === 'option'
        ? {
            role: roles.cell,
            'aria-posinset': itemIndex + 1,
            'aria-setsize': -1
        }
        : {
            role: roles.cell
        };
    // don't bubble Arrow Up and Down events to parent when in isTabbable mode
    // this bubbling causes the outer CollectionFocus ring to change index while in the isTabbable mode.
    const handleKeyDown = (event) => {
        if (isTabbable && (event.key === 'ArrowDown' || event.key === 'ArrowUp')) {
            event.stopPropagation();
        }
    };
    const { interactionProps, applyActiveStyle, applyHoverStyle, applyPseudoHoverStyle } = useInteractionStyle();
    const variantClasses = listItemMultiVariantStyles({
        selectable: isSelectable(selectionMode, isSelected) ? 'isSelectable' : 'notSelectable',
        selected: isSelected ? 'isSelected' : 'notSelected',
        selectedSingle: isSelected && selectionMode === 'single' ? 'isSelectedSingle' : 'notSelectedSingle',
        needsEventsHover: applyHoverStyle ? 'isNeedsEventsHover' : 'notNeedsEventsHover',
        pseudoHover: applyPseudoHoverStyle ? 'isPseudoHover' : 'notPseudoHover',
        active: applyActiveStyle || isActive ? 'isActive' : 'notActive',
        focusHighlight: currentItemVariant === 'highlight' && isFocused ? 'isFocusHighlight' : 'notFocusHighlight',
        focusRingVisible: isFocusRingVisible && isFocused ? 'isFocusRingVisible' : 'notFocusRingVisible',
        gridlineTop: isTopGridlineVisible ? 'visible' : 'hidden',
        gridlineBottom: isGridlineVisible ||
            (suggestion === 'end' && !isGridlineVisible && (!isSelected || selectionMode !== 'single'))
            ? 'visible'
            : 'hidden'
    });
    const classes = classNames([ITEM_STYLE_CLASS, variantClasses]);
    const styleInterpolations = mergeInterpolations([
        ...Object.values(flexitemInterpolations)
    ]);
    const { class: cls, ...cellStyles } = styleInterpolations({
        flex: '1 1 auto',
        alignSelf: 'center'
    });
    const cellClasses = classNames([
        cls,
        selectionMode === 'multiple' && listItemStyles.checkboxContainer
    ]);
    // todo: use translated text for selector
    // note cannot put focus on gridcell div since JAWS will not read the aria-rowindex
    // correctly, so unfortunately needed another div
    return (jsx("div", { "aria-rowindex": itemIndex + 1, "aria-level": itemDepth, "data-oj-key": itemKey, class: classes, ref: rootRef, role: roles.item, ...(suggestion && { 'data-oj-suggestion': true }), ...(typeof itemKey === 'number' && { 'data-oj-key-type': 'number' }), ...interactionProps, children: jsx("div", { id: useId(), style: cellStyles, class: cellClasses, "aria-posinset": itemIndex + 1, "aria-setsize": -1, onKeyDown: handleKeyDown, "aria-colindex": 1, "aria-selected": selectionMode !== 'none' ? isSelected : undefined, ...cellRoleAttributes, children: jsx(TabbableModeContext.Provider, { value: { isTabbable }, children: jsx(FocusTrap, { isDisabled: !isTabbable, restoreFocusRef: false, children: children }) }) }) }));
}
/**
 * Helper method to determine whether item is selectable
 * @returns true if item is selectable (show hover effect), false otherwise
 */
const isSelectable = (selectionMode, isItemSelected) => {
    return selectionMode !== 'none' && (selectionMode === 'multiple' || !isItemSelected);
};
const MemoizeListViewItem = memo(ListViewItem, (prev, next) => {
    if (prev && next) {
        return (prev.itemKey === next.itemKey &&
            prev.itemIndex === next.itemIndex &&
            prev.itemData === next.itemData &&
            prev.isFocused === next.isFocused &&
            prev.isFocusRingVisible === next.isFocusRingVisible &&
            prev.isSelected === next.isSelected &&
            prev.isTabbable === next.isTabbable &&
            prev.isActive === next.isActive &&
            prev.suggestion === next.suggestion);
    }
    return false;
});

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook to detect and handle when the current key has been removed
 * and try to find the next available current key.
 * TODO: put in its own private module as we should be able to share
 * between other Collection components.
 * @param dataState
 * @param currentKey
 * @param onChange
 */
function useHandleRemoveCurrentKey(dataState, currentKey, onChange) {
    const prevDataState = useRef();
    useEffect(() => {
        const oldDataState = prevDataState.current;
        if (currentKey &&
            onChange &&
            oldDataState &&
            dataState &&
            oldDataState.offset === dataState.offset &&
            oldDataState !== dataState) {
            const newKeys = dataState.data.map((dataMetadata) => {
                return dataMetadata.metadata.key;
            });
            // first check if currentKey exists in new data, if it is then we
            // don't need to do anything
            if (newKeys.indexOf(currentKey) === -1) {
                const oldKeys = oldDataState?.data.map((dataMetadata) => {
                    return dataMetadata.metadata.key;
                });
                // figure out what the new currentKey should be
                let index = oldKeys.indexOf(currentKey);
                if (index > -1) {
                    const backward = index === oldKeys.length - 1;
                    while (index >= 0 && index < oldKeys.length) {
                        index = backward ? index - 1 : index + 1;
                        const newCurrentKey = oldKeys[index];
                        if (newKeys.indexOf(newCurrentKey) > -1) {
                            onChange({ value: newCurrentKey });
                            break;
                        }
                    }
                }
            }
        }
        // update previous DataState
        prevDataState.current = dataState;
    }, [dataState, currentKey, onChange]);
}

const SPARKLE_STYLE_CLASS = 'oj-collection-sparkle';
/**
 * A sparkle component for smart suggestion indicator in ListView
 * @param sparkleHeight the height of sparkle
 */
function Sparkle({ sparkleHeight }) {
    if (sparkleHeight <= 0) {
        return null;
    }
    const height = sparkleHeight + 'px';
    const sparkleClasses = classNames([sparkleStyles.base]);
    const containerClasses = classNames([sparkleStyles.container, SPARKLE_STYLE_CLASS]);
    return (jsx("div", { class: containerClasses, children: jsx("div", { class: sparkleClasses, style: { height } }) }, "sparkle"));
}
/**
 * A helper function that finds the data with suggestions, and
 * returns the corresponding keys
 * @param dataState
 */
const findSuggestions = (data, count) => {
    if (count === 0) {
        return null;
    }
    const suggestionsData = data.slice(0, count);
    return suggestionsData.reduce((suggestions, value, index) => {
        const key = value.metadata.key;
        if (index === count - 1) {
            suggestions.set(key, 'end');
        }
        else {
            suggestions.set(key, true);
        }
        return suggestions;
    }, new Map());
};

/**
 * Component that renders items as a flat list.
 * In order to maximize performance, only items that are visible in the viewport are rendered.
 */
function List({ 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, allowTabbableMode = true, children, currentKey, data, gridlines, loadingIndicator = defaultLoadingIndicator, onCurrentKeyChange, onLoadRange, onSelectionChange, onItemAction, rangeExtractor, role = 'grid', selectedKeys = emptyKeys, selectionMode = 'none', viewportConfig, currentItemVariant = 'none', promotedSection, isVirtualized = true, customItemRenderer, eventHandlers, scrollToVisibleOffset }) {
    const rootRef = useRef(null);
    const listRoles = useMemo(() => getListViewRoles(role), [role]);
    // tracking the anchor key which is used for shift+click selection
    const anchorKey = useRef();
    // tracking pending selection/current key that is not in current data
    const pendingSelection = useRef();
    const pendingCurrentKey = useRef();
    const [active, setActive] = useState(false);
    // tracking sparkle height
    const [sparkleHeight, setSparkleHeight] = useState(0);
    const showGridline = (index) => {
        // show bottom gridlines for each item, and for the last item if specified
        return (gridlines?.item === 'visible' &&
            (index + 1 !== data?.totalSize || gridlines?.bottom === 'visible'));
    };
    const showGridlineTop = () => {
        // show the top gridline for the first item
        return gridlines?.item === 'visible' && gridlines?.top === 'visible';
    };
    const ariaMultiSelectable = selectionMode === 'none' ? undefined : selectionMode === 'multiple';
    const ariaRowCount = data === null ? undefined : data.sizePrecision === 'exact' ? data.totalSize : -1;
    const classes = classNames([listStyles.base]);
    // find out whether the current key was there before in prev render
    // and adjust current key as needed.  This should be run before other
    // useEffect(s) that could also alter current key.
    useHandleRemoveCurrentKey(data, currentKey, onCurrentKeyChange);
    const { currentKeyProps } = useCurrentKey((element) => keyExtractor(element, ITEM_SELECTOR), selectionMode !== 'multiple', getPrevNextKey(rootRef.current, currentKey, true, ITEM_SELECTOR), getPrevNextKey(rootRef.current, currentKey, false, ITEM_SELECTOR), undefined, undefined, currentKey, onCurrentKeyChange);
    const listViewContains = (elem) => {
        return !!rootRef.current?.contains(elem);
    };
    const [showFocusRing, focusRingProps] = useCollectionFocusRing(listViewContains, [
        'ArrowUp',
        'ArrowDown'
    ]);
    let pendingFocusRingChange = false;
    const [isCurrentTabbableKey, tabbableModeProps] = useTabbableModeSet(listViewContains, (element) => {
        // we don't want List to go into Tabbable mode when user clicks on expander
        return isExpander(element) ? null : keyExtractor(element, ITEM_SELECTOR);
    }, currentKey, 
    // handle clean-up on disabling of the mode
    (target, isKeyboardEvent) => {
        if (listViewContains(target)) {
            // delay focus reset for keyboard disable so focus is reset to ListView after the FocusTrap blur lifecycle completes.
            // pointer initiated changes will fire the onBlur organically and delaying the focus, just generates an unwanted second blur
            if (isKeyboardEvent) {
                // do not show a focus ring during this timeOut
                pendingFocusRingChange = true;
                setTimeout(() => {
                    rootRef.current?.focus();
                }, 0);
            }
            else {
                rootRef.current?.focus();
            }
        }
        // otherwise target is not in list (including body, which target should be null in that case)
    }, 
    // set currentKey when mode is enabled
    (key) => {
        onCurrentKeyChange && onCurrentKeyChange({ value: key });
    });
    useEffect(() => {
        if (currentKey != null && rootRef.current) {
            const elem = findElementByKey(rootRef.current, currentKey, ITEM_SELECTOR);
            if (elem) {
                const activeDescendant = rootRef.current.getAttribute('aria-activedescendant');
                const cell = elem.querySelector(`[role=${listRoles.cell}]`);
                if (cell && activeDescendant !== cell.id) {
                    // update aria-activedescendant for screenreader
                    rootRef.current.setAttribute('aria-activedescendant', cell.id);
                    const scroller = viewportConfig?.scroller();
                    const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;
                    // make sure item is visible
                    scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);
                }
            }
        }
        // listen to data because the current item would re-render when the virtualizer
        // is fetching data or updating the data, i.e. the id of current item would be updated,
        // so the currentKey itself couldn't guarantee the root has latest aria-activedescendant
    }, [currentKey, data, listRoles.cell, viewportConfig]);
    const handleSelectionChange = useCallback((detail) => {
        if (onSelectionChange) {
            if (detail.value.all === false && detail.value.keys.size > 0) {
                // the last key selected by a user gesture is the anchor key
                anchorKey.current = Array.from(detail.value.keys.values()).pop();
            }
            onSelectionChange(detail);
        }
    }, [anchorKey, onSelectionChange]);
    const handleSelectionRangeChange = useCallback((detail) => {
        if (data && onSelectionChange) {
            const value = handleSelectionRange(detail, data);
            if (Array.isArray(value)) {
                onSelectionChange({ value: { all: false, keys: new Set(value) }, target: null });
            }
            else {
                pendingSelection.current = {
                    detail: detail,
                    range: { offset: data.offset, count: data.data.length }
                };
                onLoadRange(value);
            }
        }
    }, [data, onSelectionChange, onLoadRange]);
    const handleInitialFocus = useCallback(() => {
        if (rootRef.current &&
            onCurrentKeyChange &&
            (!allowTabbableMode || isCurrentTabbableKey(undefined))) {
            const firstKey = pendingCurrentKey.current || getFirstVisibleKey(rootRef.current, ITEM_SELECTOR);
            if (isKeyDefined(firstKey)) {
                onCurrentKeyChange({ value: firstKey });
            }
        }
    }, [allowTabbableMode, onCurrentKeyChange, isCurrentTabbableKey]);
    /**
     * Used by allowTabbableMode = false, to prevent focus from getting onto checkboxes on click
     * @param event
     */
    const handleSelectorFocusCapture = useCallback((event) => {
        const key = keyExtractor(event.target, ITEM_SELECTOR);
        if (key && event.relatedTarget?.getAttribute('type') === 'checkbox') {
            rootRef.current?.focus();
            if (onCurrentKeyChange && key) {
                onCurrentKeyChange({ value: key });
            }
        }
    }, [onCurrentKeyChange]);
    const handleFocus = useCallback((event) => {
        if (isExpander(event.target)) {
            rootRef.current?.focus();
            const key = keyExtractor(event.target, ITEM_SELECTOR);
            if (onCurrentKeyChange && key) {
                onCurrentKeyChange({ value: key });
            }
            return;
        }
        !isKeyDefined(currentKey) && onCurrentKeyChange && handleInitialFocus();
        !allowTabbableMode && handleSelectorFocusCapture(event);
    }, [
        allowTabbableMode,
        currentKey,
        handleInitialFocus,
        handleSelectorFocusCapture,
        onCurrentKeyChange
    ]);
    const value = useCollectionGestureContext();
    const { selectionProps } = useSelection((element) => {
        if (element === rootRef.current) {
            return currentKey === undefined ? null : currentKey;
        }
        return keyExtractor(element, ITEM_SELECTOR);
    }, selectedKeys, selectionMode, false, 'replace', value === 'embedded', handleSelectionChange, anchorKey.current, currentKey, (currentKey, isPrev) => getPrevNextKey(rootRef.current, currentKey, isPrev, ITEM_SELECTOR), undefined, (key) => {
        if (rootRef.current) {
            const elem = findElementByKey(rootRef.current, key, ITEM_SELECTOR);
            if (elem) {
                const scroller = viewportConfig?.scroller();
                const offset = scrollToVisibleOffset ? scrollToVisibleOffset(rootRef.current) : 0;
                scrollToVisible(elem, scroller != null ? scroller : rootRef.current, offset);
            }
        }
    }, handleSelectionRangeChange);
    if (data && pendingSelection.current !== undefined && onSelectionChange) {
        const keys = handleSelectionRange(pendingSelection.current.detail, data);
        if (Array.isArray(keys)) {
            onSelectionChange({ value: { all: false, keys: new Set(keys) }, target: null });
        }
        const range = pendingSelection.current
            ? pendingSelection.current.range
            : { offset: data.offset, count: data.data.length };
        data = adjustDataState(data, range);
        pendingSelection.current = undefined;
        onLoadRange(range);
    }
    const suggestions = useMemo(() => data && promotedSection && findSuggestions(data.data, promotedSection.count), [data, promotedSection]);
    // TODO: check suggestions before Sparkle would cause a scrolling issue
    const sparkleIndicator = jsx(Sparkle, { sparkleHeight: sparkleHeight });
    const itemActionProps = useItemAction(currentKey, data, onItemAction, ITEM_SELECTOR, value === 'embedded');
    useEffect(() => {
        // update sparkleHeight only when we have suggestions
        // avoid unnecessary iterating through elements
        if (suggestions) {
            const placeholder = rootRef.current?.querySelector('.' + PLACEHOLDER_STYLE_CLASS);
            let height = placeholder?.offsetHeight || 0;
            const suggestionItems = rootRef.current?.querySelectorAll('[data-oj-suggestion]');
            suggestionItems?.forEach((item) => (height += item.offsetHeight));
            setSparkleHeight(height);
        }
    }, [suggestions]);
    // returns an ListItemContext based on ItemContext (added metadata and selector)
    const getItemContext = useCallback((context) => {
        const selectorRenderer = selectionMode === 'multiple'
            ? () => (jsx(Selector, { onChange: handleSelectionChange, rowKey: context.data.metadata.key, selectedKeys: selectedKeys }))
            : undefined;
        return {
            index: context.index,
            data: context.data.data,
            metadata: context.data.metadata,
            selector: selectorRenderer
        };
    }, [selectionMode, selectedKeys, handleSelectionChange]);
    const ItemComponent = isVirtualized ? ListViewItem : MemoizeListViewItem;
    const childrenComponent = (context) => {
        const listItemContext = getItemContext(context);
        const suggestion = suggestions?.get(listItemContext.metadata.key);
        const isTabbable = allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key);
        const isFocused = currentKey === listItemContext.metadata.key && !isTabbable;
        const isActive = isFocused && active;
        const isSelected = containsKey(selectedKeys, listItemContext.metadata.key);
        const isFocusRingVisible = isFocused && showFocusRing && !pendingFocusRingChange;
        const listItemFunc = (context, otherProps) => (jsx(ItemComponent, { isFocused: isFocused, isFocusRingVisible: isFocusRingVisible, isActive: isActive, isGridlineVisible: showGridline(listItemContext.index), isSelected: isSelected, isTabbable: allowTabbableMode && isCurrentTabbableKey(listItemContext.metadata.key), itemIndex: listItemContext.index, itemKey: listItemContext.metadata.key, itemData: listItemContext.data, role: role, selectionMode: selectionMode, currentItemVariant: currentItemVariant, ...(suggestion && { suggestion }), ...(listItemContext.index === 0 && { isTopGridlineVisible: showGridlineTop() }), ...otherProps, children: children(context) }, listItemContext.metadata.key));
        // if customItemRenderer is specified (ExpandableList and GroupedList)
        // create a custom context with additional info including a function
        // that helps create the default item component
        if (customItemRenderer) {
            const customRendererContext = {
                listItemContext,
                isFocused,
                isFocusRingVisible,
                isSelected,
                isTabbable,
                isActive,
                defaultListItem: listItemFunc
            };
            return customItemRenderer(customRendererContext);
        }
        return listItemFunc(listItemContext);
    };
    viewportConfig = getViewportConfig(rootRef, viewportConfig);
    /**
     * Need to track pointer down element to set currentItem when initial focus happens
     */
    const handlePointerDown = useCallback((event) => {
        const key = keyExtractor(event.target, ITEM_SELECTOR);
        if (isKeyDefined(key))
            pendingCurrentKey.current = key;
    }, []);
    const handleKeyDown = useCallback((event) => {
        if (event.key === ' ' && currentKey && selectionMode !== 'none') {
            setActive(true);
        }
    }, [currentKey, selectionMode, setActive]);
    const handleKeyUp = useCallback(() => {
        setActive(false);
    }, [setActive]);
    // if data is not specified, listview should show loading indicator
    // todo: replace placeholder with actual SkeletonContainer component (Ash is working on)
    return (jsx("div", { ...mergeProps(allowTabbableMode ? tabbableModeProps : {}, currentKeyProps, focusRingProps, selectionProps, itemActionProps, {
            onFocus: handleFocus,
            onPointerDown: handlePointerDown,
            onKeyDown: handleKeyDown,
            onKeyUp: handleKeyUp
        }, eventHandlers !== undefined ? eventHandlers : {}), role: role, "aria-rowcount": ariaRowCount, "aria-colcount": 1, ref: rootRef, class: classes, tabIndex: 0, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-multiselectable": ariaMultiSelectable, children: data == null ? (loadingIndicator) : isVirtualized ? (jsx(VirtualizedCollection, { data: data, itemSelector: ITEM_SELECTOR, loadMoreIndicator: defaultLoadMoreIndicator, onLoadRange: onLoadRange, rangeExtractor: rangeExtractor, suggestions: sparkleIndicator, viewportConfig: viewportConfig, children: childrenComponent })) : (jsx(LoadMoreCollection, { data: data.data, loadMoreIndicator: defaultLoadMoreIndicator, hasMore: data.sizePrecision === 'atLeast' && data.data.length <= data.totalSize, onLoadMore: () => {
                data && onLoadRange({ offset: 0, count: data.data.length + 25 });
            }, suggestions: sparkleIndicator, viewportConfig: viewportConfig, children: childrenComponent })) }));
}
const isExpander = (elem) => {
    if (elem.parentElement && elem.parentElement.classList.contains('oj-listview-expander')) {
        return true;
    }
    return false;
};
/**
 * A helper function to make sure specified elem is visible in the specified container
 */
const scrollToVisible = (elem, scroller, offset) => {
    if (elem && scroller) {
        if (elem.scrollIntoViewIfNeeded) {
            // for Safari, we'll need the non-standard scrollIntoViewIfNeeded
            elem.scrollIntoViewIfNeeded();
        }
        else {
            elem.scrollIntoView({ block: 'nearest' });
        }
        if (offset > 0) {
            const scrollerBounds = scroller.getBoundingClientRect();
            const elemBounds = elem.getBoundingClientRect();
            const diff = scrollerBounds.top + offset - elemBounds.top;
            if (diff > 0) {
                scroller.scrollTop = scroller.scrollTop - diff;
            }
        }
    }
};
const getViewportConfig = (rootRef, config) => {
    return (config ?? {
        scroller: () => {
            return rootRef.current;
        }
    });
};
const emptyKeys = { all: false, keys: new Set() };
const handleSelectionRange = (detail, dataState) => {
    const keys = dataState.data.map((value) => {
        return value.metadata.key;
    });
    const startIndex = keys.indexOf(detail.value.start);
    const endIndex = keys.indexOf(detail.value.end);
    const minIndex = Math.min(startIndex, endIndex);
    const maxIndex = Math.max(startIndex, endIndex);
    if (minIndex === -1) {
        // return a range to fetch so we can find all the keys, maxIndex should not be -1
        return { offset: 0, count: dataState.totalSize };
    }
    else {
        // range of keys are in the current viewport, return them
        return keys.slice(minIndex, maxIndex + 1);
    }
};
const defaultLoadingIndicator = (jsx(SkeletonContainer, { minimumCount: 25, children: () => {
        return (jsx(Flex, { height: "12x", align: "center", children: jsx(Skeleton, { height: "4x" }) }));
    } }));
const defaultLoadMoreIndicator = (jsx("div", { class: LOADMORE_STYLE_CLASS, children: jsx(SkeletonContainer, { minimumCount: 3, children: () => {
            return (jsx(Flex, { height: "12x", align: "center", children: jsx(Skeleton, { height: "4x" }) }));
        } }) }));
/**
 * Adjust the DataState as needed if it contains more than needed for the specified range
 */
const adjustDataState = (dataState, range) => {
    if (range) {
        // prevent range offset from being larger than the data state
        const safeRangeOffset = Math.min(range.offset, dataState.offset + dataState.totalSize);
        const diff = safeRangeOffset - dataState.offset;
        if (diff > 0) {
            dataState = {
                offset: safeRangeOffset,
                data: dataState.data.slice(diff, diff + range.count),
                totalSize: dataState.totalSize,
                sizePrecision: dataState.sizePrecision
            };
        }
    }
    return dataState;
};

export { ITEM_STYLE_CLASS as I, List as L };
//# sourceMappingURL=List-1441b11d.js.map
