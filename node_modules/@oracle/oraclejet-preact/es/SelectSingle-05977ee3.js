/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { Fragment } from 'preact';
import { forwardRef } from 'preact/compat';
import { useFocusableTextField } from './hooks/UNSAFE_useFocusableTextField.js';
import { useFormContext } from './hooks/UNSAFE_useFormContext.js';
import { FormFieldContext } from './hooks/UNSAFE_useFormFieldContext.js';
import { useLoadingIndicatorTimer } from './hooks/UNSAFE_useLoadingIndicatorTimer.js';
import { useTextField } from './hooks/UNSAFE_useTextField.js';
import './UNSAFE_Label.js';
import { LiveRegion } from './UNSAFE_LiveRegion.js';
import { ReadonlyTextField, TextField } from './UNSAFE_TextField.js';
import { InlineUserAssistance, CompactUserAssistance } from './UNSAFE_UserAssistance.js';
import { renderItemText, useSelectCommon, KEYS, isControlOrFunctionKey, isBeforeDataFetch, isMobile, DropdownArrow, DropdownUserAssistance, EmptyResults, DefaultList, Dropdown, DropdownList } from './PRIVATE_SelectCommon.js';
import { useMemo, useRef, useCallback, useEffect } from 'preact/hooks';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { useTranslationBundle } from './hooks/UNSAFE_useTranslationBundle.js';
import { L as Label } from './Label-642674b7.js';
import { R as ReadonlyTextFieldInput } from './ReadonlyTextFieldInput-cc60e2b7.js';
import { T as TextFieldInput } from './TextFieldInput-f1ae0ae9.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
function useDisplayValue(itemText, valueItem) {
    // create the text displayed in the field from the selected value
    const displayValue = useMemo(() => {
        return valueItem === undefined ? '' : renderItemText(valueItem, itemText) ?? '';
    }, [valueItem, itemText]);
    return displayValue;
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Hook that manages SelectSingle state and behavior.  This hook creates state variables and
 * event listeners, returning properties to apply to components internally rendered by
 * SelectSingle, as well as state information.
 *
 * @param data Specifies data for the dropdown list.
 * @param inputRef Ref to the input element.
 * @param isDisabled Specifies whether the component is disabled.
 * @param isFocused Specifies whether the component has focus.
 * @param isReadonly Specifies whether the component is readonly.
 * @param onCommit Callback invoked when the selected value is committed.
 * @param onFilter Callback function to trigger loading data for the dropdown list,
 * which may or may not be filtered by user entered text.
 * @param valueItem Specifies the key, data, and optional metadata for the selected value.
 *
 * @returns Properties to apply to internal components that SelectSingle renders, and component
 * state.
 */
function useSelectSingle({ data, inputRef, isDisabled, isFocused: propIsFocused, isReadonly, onCommit: propOnCommit, onFilter, valueItem }) {
    const { currentRow, dropdownRef, handleDropdownArrowClick, handleDropdownAutoDismiss: baseHandleDropdownAutoDismiss, handleDropdownPosition, handleInput, handleMainFieldKeyDown: baseHandleMainFieldKeyDown, handleMainFieldKeyUp, isDropdownAbove, isDropdownOpen, isFocused, isUserFiltering, mainFieldRef, onCurrentKeyChange, onMouseDown, searchText, selectedKeys, setCurrentRow, setDropdownOpen, setSelectedKeys, stopFiltering, userInput } = useSelectCommon({
        data,
        inputRef,
        isFocused: propIsFocused,
        onFilter
    });
    // refs used by some of the effects below to determine whether the effect needs to run,
    // for when the list of dependencies is longer than what we want the trigger to actually be
    const prevDataRef = useRef(data);
    const prevDropdownOpenRef = useRef(isDropdownOpen);
    const prevSearchText = useRef(searchText);
    const onCommit = useCallback((value) => {
        propOnCommit?.({
            value: value,
            previousValue: valueItem !== undefined ? valueItem.key : undefined
        });
    }, [propOnCommit, valueItem]);
    const clearValue = useCallback(() => {
        setDropdownOpen(false);
        setSelectedKeys(new Set());
        // call the onCommit callback so that the consuming code can update the valueItem
        onCommit(undefined);
    }, [onCommit]);
    const clearValueIfNeeded = useCallback(() => {
        if (isUserFiltering && userInput === '' && valueItem !== undefined) {
            clearValue();
            return true;
        }
        return false;
    }, [clearValue, isUserFiltering, userInput, valueItem]);
    // when the field loses focus, check to see if we need to clear the value
    useEffect(() => {
        if (!isFocused) {
            clearValueIfNeeded();
        }
        // only run when focus changes, at which point the current value of clearValueIfNeeded will
        // be used
    }, [isFocused]);
    const focusInput = useCallback(() => {
        inputRef.current?.focus();
    }, []);
    const removeDropdown = useCallback(() => {
        dropdownRef.current?.parentElement?.removeChild(dropdownRef.current);
    }, []);
    const myHandleDropdownAutoDismiss = useCallback((event) => {
        if (isDropdownOpen) {
            if (event?.type === 'keydown') {
                const keyboardEvent = event;
                switch (keyboardEvent.code) {
                    case KEYS.TAB:
                        // if there is a currentRow in the dropdown, select it and commit it
                        if (currentRow !== undefined && currentRow.rowKey !== undefined) {
                            setSelectedKeys(new Set([currentRow.rowKey]));
                            onCommit(currentRow.rowKey);
                        }
                        // Put focus on an element in the main field, but don't kill the event, so that
                        // the browser can naturally transfer focus to the next focusable item relative
                        // to the element in the main field.
                        focusInput();
                        // Remove the dropdown immediately, without waiting for a rerender based on changing
                        // state, so that the open dropdown cannot get focus when the browser handles the
                        // Tab key.
                        removeDropdown();
                        break;
                    default:
                        break;
                }
            }
        }
    }, [currentRow, focusInput, isDropdownOpen, onCommit]);
    const myHandleMainFieldKeyDown = useCallback((event) => {
        // ignore control key and function key
        if (isControlOrFunctionKey(event)) {
            return;
        }
        switch (event.code) {
            case KEYS.TAB:
                // check whether we need to clear the value;
                // if not, check whether we need to select the current item
                const isValueClearedTab = clearValueIfNeeded();
                if (!isValueClearedTab && isDropdownOpen && data != null && data.data.length > 0) {
                    // if there is a currentRow in the dropdown (meaning a highlighted item that would
                    // have keyboard focus if the dropdown list had physical focus, which may be different
                    // from the currently selected item), select it and commit it;
                    // otherwise commit the currently selected value again so that a valueAction event
                    // will be fired
                    if (currentRow !== undefined && currentRow.rowKey !== undefined) {
                        setSelectedKeys(new Set([currentRow.rowKey]));
                        onCommit(currentRow.rowKey);
                    }
                    else {
                        onCommit(valueItem?.key ?? undefined);
                    }
                }
                // Remove the dropdown immediately, without waiting for a rerender based on changing
                // state, so that the open dropdown cannot get focus when the browser handles the
                // Tab key.
                removeDropdown();
                setDropdownOpen(false);
                break;
            case KEYS.ENTER:
                // check whether we need to clear the value;
                // if not, check whether we need to select the current item
                const isValueCleared = clearValueIfNeeded();
                if (!isValueCleared && isDropdownOpen && data != null && data.data.length > 0) {
                    setDropdownOpen(false);
                    // after selecting a value, the user is no longer actively filtering, so update related
                    // state accordingly so that the newly selected value appears in the field
                    stopFiltering();
                    // if there is a currentRow in the dropdown, select it and commit it;
                    // otherwise commit the currently selected value again
                    if (currentRow !== undefined && currentRow.rowKey !== undefined) {
                        setSelectedKeys(new Set([currentRow.rowKey]));
                        onCommit(currentRow.rowKey);
                    }
                    else {
                        onCommit(valueItem?.key ?? undefined);
                    }
                }
                break;
            default:
                break;
        }
    }, [clearValueIfNeeded, currentRow, data, isDropdownOpen, onCommit, valueItem]);
    // when the valueItem changes, save the new selectedKeys
    useEffect(() => {
        setSelectedKeys(valueItem === undefined ? undefined : new Set([valueItem.key]));
    }, [valueItem]);
    const onItemAction = useCallback((detail) => {
        focusInput();
        setDropdownOpen(false);
        // after selecting a value, the user is no longer actively filtering, so update related
        // state accordingly so that the newly selected value appears in the field
        stopFiltering();
        const newKey = detail.context.metadata.key;
        // update the selectedKeys so that the selection visual state of the collection
        // updates immediately while waiting for a new valueItem to be set
        setSelectedKeys(new Set([newKey]));
        // call the onCommit callback so that the consuming code can update the valueItem
        onCommit(newKey);
    }, [focusInput, onCommit]);
    useEffect(() => {
        // only run this effect when data changes because we need to wait for the new set of
        // filtered data to be set before highlighting the first result
        if (data === prevDataRef.current) {
            return;
        }
        // when filtering, set the first result of the filtered data set to be the current item
        // (check the data offset so we don't try to highlight again if the user scrolls through
        // the list and more data is fetched)
        if (isDropdownOpen &&
            isUserFiltering &&
            data != null &&
            data.offset === 0 &&
            data.data.length > 0) {
            // if there are results and search text, highlight the first row, otherwise clear
            // an existing highlight
            setCurrentRow({
                rowKey: searchText !== undefined && searchText?.length > 0 ? data.data[0].metadata.key : undefined
            });
        }
    }, [data, isDropdownOpen, isUserFiltering, searchText]);
    useEffect(() => {
        // only run this effect when the state of the dropdown changes
        if (isDropdownOpen === prevDropdownOpenRef.current) {
            return;
        }
        // clear the current item when the dropdown opens if there is no filter text
        if (isDropdownOpen &&
            (!isUserFiltering || searchText === undefined || searchText.length === 0)) {
            setCurrentRow({ rowKey: undefined });
        }
    }, [isDropdownOpen, isUserFiltering, searchText]);
    const dropdownEventHandlers = useMemo(() => {
        return mergeProps({
            onAutoDismiss: baseHandleDropdownAutoDismiss,
            onPosition: handleDropdownPosition
        }, { onAutoDismiss: myHandleDropdownAutoDismiss });
    }, [baseHandleDropdownAutoDismiss, handleDropdownPosition, myHandleDropdownAutoDismiss]);
    const inputEventHandlers = useMemo(() => {
        return mergeProps({
            onInput: handleInput,
            onKeyDown: baseHandleMainFieldKeyDown,
            onKeyUp: handleMainFieldKeyUp
        }, { onKeyDown: myHandleMainFieldKeyDown });
    }, [baseHandleMainFieldKeyDown, handleInput, handleMainFieldKeyUp, myHandleMainFieldKeyDown]);
    // update refs used in some of the above effects in a useEffect on every render so that they
    // update after the above effects run
    useEffect(() => {
        prevDataRef.current = data;
        prevDropdownOpenRef.current = isDropdownOpen;
        prevSearchText.current = searchText;
    });
    return {
        collectionProps: {
            currentKey: currentRow.rowKey,
            onCurrentKeyChange,
            onItemAction,
            selectedKeys
        },
        dropdownArrowEventHandlers: {
            onClick: handleDropdownArrowClick
        },
        dropdownEventHandlers,
        dropdownRef,
        inputEventHandlers,
        inputRef,
        isDropdownAbove,
        isDropdownOpen,
        isFocused,
        isUserFiltering,
        mainFieldRef,
        mouseProps: isDisabled || isReadonly ? {} : { onMouseDown },
        searchText,
        userInput
    };
}

/**
 * A SelectSingle is a dropdown list that supports single selection and search filtering.
 */
const SelectSingle = forwardRef(({ 'aria-describedby': ariaDescribedBy, assistiveText, data, helpSourceLink, helpSourceText, isDisabled: propIsDisabled, isLoading: propIsLoading, isReadonly: propIsReadonly, isRequired, isRequiredShown, itemText, label, labelEdge: propLabelEdge, labelStartWidth: propLabelStartWidth, messages, onCommit, onFilter, onLoadRange, placeholder, textAlign: propTextAlign, userAssistanceDensity: propUserAssistanceDensity, valueItem, variant = 'default', virtualKeyboard }, ref) => {
    const { isDisabled: isFormDisabled, isReadonly: isFormReadonly, labelEdge: formLabelEdge, labelStartWidth: formLabelStartWidth, textAlign: formTextAlign, userAssistanceDensity: formUserAssistanceDensity } = useFormContext();
    // default to FormContext values if component properties are not specified
    const isDisabled = propIsDisabled ?? isFormDisabled;
    const isReadonly = propIsReadonly ?? isFormReadonly;
    const labelEdge = propLabelEdge ?? formLabelEdge;
    const labelStartWidth = propLabelStartWidth ?? formLabelStartWidth;
    const textAlign = propTextAlign ?? formTextAlign;
    const userAssistanceDensity = propUserAssistanceDensity ?? formUserAssistanceDensity;
    const { enabledElementRef, focusProps, isFocused: origIsFocused, readonlyElementRef } = useFocusableTextField({ isDisabled, isReadonly, ref });
    const { collectionProps, dropdownArrowEventHandlers, dropdownEventHandlers, dropdownRef, inputEventHandlers, isDropdownAbove, isDropdownOpen, isFocused, isUserFiltering, mainFieldRef, mouseProps, searchText, userInput } = useSelectSingle({
        data,
        inputRef: enabledElementRef,
        isDisabled,
        isFocused: origIsFocused,
        isReadonly,
        onCommit,
        onFilter,
        valueItem
    });
    // The incoming propIsLoading tells us that we are in a loading state, but we don't want to
    // show the loading indicator until after a delay, because showing it immediately could result
    // in unwanted flashing.  The isLoading var below will be set to true by useLoadingIndicatorTimer
    // after the delay, when the timer expires, at which point we should show the loading indicator.
    // If propIsLoading is set to false before the timer expires, then the timer will be cancelled
    // and no loading indicator will be shown.
    // (ListView detects its loading state by checking data === null.  While it would be nice for
    // us to be consistent and check valueItems === null, we need to use a separate isLoading prop.
    // If valueItems === null triggers our loading state, then the selections in the dropdown
    // are cleared for that period of time, which is undesirable.)
    const isLoading = useLoadingIndicatorTimer(propIsLoading ?? false);
    const { baseId, formFieldContext, inputProps, labelProps, textFieldProps, userAssistanceProps } = useTextField({
        ariaDescribedBy,
        helpSourceLink,
        helpSourceText,
        isDisabled,
        isFocused,
        isLoading,
        isReadonly,
        isRequiredShown,
        labelEdge,
        messages,
        styleVariant: variant,
        userAssistanceDensity,
        value: valueItem !== undefined ? true : undefined
    });
    // JET-54256 - inside label animates up on initial display with selected value
    // If we're waiting for the selected values to load, the component should look like it
    // has a value in the meantime.
    // Use the original propIsLoading instead of isLoading because we don't want to delay
    // the inside label position by a timer like we do the progressive loading indicator.
    formFieldContext.hasValue = propIsLoading || formFieldContext.hasValue;
    const dropdownId = `${baseId}-dropdown`;
    const displayValue = useDisplayValue(itemText, valueItem);
    const labelComp = labelEdge !== 'none' ? jsx(Label, { ...labelProps, children: label }) : undefined;
    const fieldLabelProps = {
        label: labelEdge !== 'none' ? labelComp : undefined,
        labelEdge: labelEdge !== 'none' ? labelEdge : undefined,
        labelStartWidth: labelEdge !== 'none' ? labelStartWidth : undefined
    };
    const ariaLabel = labelEdge === 'none' ? label : undefined;
    const isInlineDensity = userAssistanceDensity === 'efficient' || userAssistanceDensity === 'reflow';
    const inlineUserAssistance = isInlineDensity ? (isDisabled || isReadonly ? (
    // save space for user assistance if density is 'efficient', even though we don't
    // render user assistance for disabled or readonly fields
    userAssistanceDensity !== 'efficient' ? undefined : (jsx(InlineUserAssistance, { userAssistanceDensity: userAssistanceDensity, ...userAssistanceProps }))) : (jsx(InlineUserAssistance, { assistiveText: assistiveText, fieldLabel: label, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, messages: messages, isRequiredShown: isRequiredShown, userAssistanceDensity: userAssistanceDensity, ...userAssistanceProps }))) : undefined;
    const compactUserAssistance = userAssistanceDensity === 'compact' ? (jsx(CompactUserAssistance, { anchorRef: mainFieldRef, messages: messages, assistiveText: assistiveText, ...userAssistanceProps })) : undefined;
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    if (isReadonly) {
        return (jsx(FormFieldContext.Provider, { value: formFieldContext, children: jsx(ReadonlyTextField, { role: "presentation", compactUserAssistance: compactUserAssistance, inlineUserAssistance: inlineUserAssistance, onBlur: focusProps.onfocusout, onFocus: focusProps.onfocusin, ref: mainFieldRef, ...fieldLabelProps, children: jsx(ReadonlyTextFieldInput, { "aria-describedby": inputProps['aria-describedby'], "aria-label": ariaLabel, "aria-labelledby": labelProps.id, as: "div", elementRef: readonlyElementRef, hasEmptyLabel: label === '' && labelEdge === 'none', hasInsideLabel: label !== undefined && labelEdge === 'inside', textAlign: textAlign, value: displayValue }) }) }));
    }
    const isDataFetched = data !== undefined && data !== null && !isBeforeDataFetch(data);
    const hasInsideLabel = labelComp !== undefined && labelEdge === 'inside';
    const liveRegionText = isDropdownOpen && isDataFetched
        ? data?.totalSize === 0
            ? translations.select_noMatchesFound()
            : data?.totalSize === 1
                ? translations.select_oneMatchFound()
                : data?.sizePrecision === 'exact'
                    ? translations.select_sizeMatchesFound({ TOTAL_SIZE: `${data?.totalSize}` })
                    : translations.select_sizeOrMoreMatchesFound({ TOTAL_SIZE: `${data?.totalSize}` })
        : '';
    const mainContent = (jsxs(Fragment, { children: [jsx(TextFieldInput, { "aria-autocomplete": "list", "aria-controls": dropdownId, "aria-expanded": isDropdownOpen, "aria-label": ariaLabel, autoComplete: "off", hasEmptyLabel: label === '' && labelEdge === 'none', hasInsideLabel: hasInsideLabel, inputRef: enabledElementRef, isRequired: isRequired, ...inputEventHandlers, placeholder: placeholder, role: "combobox", spellcheck: false, textAlign: textAlign, type: isMobile() ? (virtualKeyboard === 'auto' ? 'search' : virtualKeyboard) : undefined, value: isUserFiltering ? userInput : displayValue, ...inputProps }), jsx(LiveRegion, { children: liveRegionText })] }));
    const dropdownArrow = (jsx(DropdownArrow, { isDisabled: isDisabled, size: hasInsideLabel ? 'md' : 'sm', ...dropdownArrowEventHandlers }));
    const dropdownInlineUserAssistance = isDropdownOpen &&
        !isDropdownAbove &&
        !isDisabled &&
        !isReadonly &&
        (assistiveText || helpSourceLink) &&
        (userAssistanceDensity === 'efficient' || userAssistanceDensity === 'reflow') ? (jsx(DropdownUserAssistance, { assistiveText: assistiveText, fieldLabel: label, helpSourceLink: helpSourceLink, helpSourceText: helpSourceText, userAssistanceDensity: userAssistanceDensity })) : undefined;
    const isEmptyResults = isDataFetched && data?.totalSize === 0;
    const dropdownListContent = isEmptyResults ? (jsx(EmptyResults, {})) : (jsx(DefaultList, { ...collectionProps, "aria-label": label ?? '', currentItemVariant: "highlight", data: data, itemText: itemText, onLoadRange: onLoadRange, searchText: isUserFiltering ? searchText : undefined, selectionMode: "single" }));
    return (jsxs(Fragment, { children: [jsx(FormFieldContext.Provider, { value: formFieldContext, children: jsx(TextField, { compactUserAssistance: compactUserAssistance, endContent: isLoading ? undefined : dropdownArrow, inlineUserAssistance: inlineUserAssistance, mainContent: mainContent, mainFieldRef: mainFieldRef, onBlur: focusProps?.onfocusout, onFocus: focusProps?.onfocusin, ...textFieldProps, ...fieldLabelProps, ...mouseProps }) }), jsxs(Dropdown, { dropdownRef: dropdownRef, id: dropdownId, isOpen: isDropdownOpen &&
                    data !== undefined &&
                    (data === null || data.totalSize > 0 || isBeforeDataFetch(data) || isEmptyResults), anchorRef: mainFieldRef, ...dropdownEventHandlers, children: [jsx(DropdownList, { hasBottomGap: dropdownInlineUserAssistance === undefined, isLoading: data === null, children: dropdownListContent }), dropdownInlineUserAssistance] })] }));
});

export { SelectSingle as S };
//# sourceMappingURL=SelectSingle-05977ee3.js.map
