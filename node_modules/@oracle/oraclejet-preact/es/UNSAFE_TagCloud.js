/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import './utils/UNSAFE_classNames.js';
import { g as getContrastingTextColor } from './ColorUtils-92c7992f.js';
import { i as intersects, g as getUnion, a as getRandomId } from './LayoutUtils-6c39654a.js';
import { styles, baseStyles } from './UNSAFE_TagCloud/themes/TagCloudStyles.css.js';
import { c as classNames } from './classNames-f414daad.js';
import { useState, useRef, useLayoutEffect } from 'preact/hooks';
import { useUser } from './hooks/UNSAFE_useUser.js';
import { TrackResizeContainer } from './PRIVATE_TrackResizeContainer.js';
import { useTooltipControlled } from './hooks/UNSAFE_useTooltip.js';
import { mergeProps } from './utils/UNSAFE_mergeProps.js';
import { useTranslationBundle } from './hooks/UNSAFE_useTranslationBundle.js';
import { useTextDimensions } from './hooks/PRIVATE_useTextDimensions.js';
import { useSelection } from './hooks/PRIVATE_useVizSelection.js';
import { sizeToCSS } from './utils/UNSAFE_size.js';
import './TagCloudStyles.styles.css';
import './index-f26154f2.js';
import 'preact';
import './Common.js';
import './Common/themes.js';
import './Common/themes/redwood/theme.js';
import './Common/themes/themeContract.css.js';
import 'preact/compat';
import './hooks/PRIVATE_useSize.js';
import './hooks/PRIVATE_useResizeObserver.js';
import './hooks/UNSAFE_useId.js';
import './UNSAFE_Floating.js';
import './Floating-2d909840.js';
import './index-326d7a5f.js';
import './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_refUtils.js';
import './hooks/UNSAFE_useOutsideClick.js';
import './utils/UNSAFE_arrayUtils.js';
import './hooks/UNSAFE_useComponentTheme.js';
import './utils/UNSAFE_logger.js';
import './_curry1-7629ff3f.js';
import './_curry2-820ed778.js';
import './utils-9a0cb8dc.js';
import './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import './UNSAFE_Floating/themes/FloatingStyles.css.js';
import './FloatingStyles.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import './vanilla-extract-recipes-createRuntimeFn.esm-3311d9ef.js';
import './vanilla-extract-dynamic.esm-33365337.js';
import './UNSAFE_Floating/themes/FloatingContract.css.js';
import './UNSAFE_Layer.js';
import './useThemeInterpolations-48ee20a7.js';
import './hooks/UNSAFE_useColorScheme.js';
import './hooks/UNSAFE_useScale.js';
import './utils/UNSAFE_interpolations/theme.js';
import './UNSAFE_Theme.js';
import './utils/UNSAFE_mergeInterpolations.js';
import './_curry3-bb17e901.js';
import './_has-057b6f90.js';
import './hooks/UNSAFE_useHover.js';
import './hooks/UNSAFE_useToggle.js';
import './hooks/UNSAFE_useFocus.js';
import './hooks/UNSAFE_useTouch.js';
import './hooks/UNSAFE_useAnimation.js';
import './useAnimation-50c5f5fb.js';
import './hooks/UNSAFE_useThemeInterpolations.js';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentTheme.js';
import './hooks/UNSAFE_useTooltip/themes/TooltipContentStyles.css.js';
import './TooltipContentStyles.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.css.js';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentBaseTheme.styles.css';
import './hooks/UNSAFE_useTooltip/themes/redwood/TooltipContentVariants.css.js';
import './TooltipContentVariants.styles.css';
import './utils/PRIVATE_clientHints.js';
import './clientHints-26cce6ec.js';

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
/**
 * Returns the item based on item info in a tag cloud.
 * @param itemInfo
 * @param items
 * @returns
 */
function getItem(itemInfo, items) {
    const { idx } = itemInfo;
    return items[idx];
}
function getItemPadding(height) {
    return height != null ? 0.15 * height : 0;
}
/**
 * Returns the next item's info in a tag cloud.
 * @param itemInfo
 * @param items
 * @returns
 */
function getNextItemInfo(itemInfo, items) {
    let idx = itemInfo.idx;
    idx = Math.min(items.length - 1, idx + 1);
    return { idx, id: items[idx].id };
}
/**
 * Returns the previous item's info in a tag cloud.
 * @param itemInfo
 * @param items
 * @returns
 */
function getPrevItemInfo(itemInfo, items) {
    let idx = itemInfo.idx;
    idx = Math.max(0, idx - 1);
    return { idx, id: items[idx].id };
}
/**
 * Returns utils functions for navigation in a tag cloud.
 * @param items
 * @returns
 */
function getTagCloudNavUtils(items) {
    return {
        getItem: (itemInfo) => {
            return getItem(itemInfo, items);
        },
        getDetailFromInfo: (itemInfo) => {
            if (!itemInfo) {
                return { id: undefined };
            }
            const item = getItem(itemInfo, items);
            return { id: item.id };
        },
        getPrevItemInfo: (itemInfo) => {
            return getPrevItemInfo(itemInfo, items);
        },
        getNextItemInfo: (itemInfo) => {
            return getNextItemInfo(itemInfo, items);
        }
    };
}

const BOTTOM_PADDING = 20;
const DEFAULT_FONT_SIZE = 12;
/**
 * helper layout functions for font size calc
 * @param {number} minValue
 * @param {number} maxValue
 * @param {number} range
 * @return {number}
 */
const fontSizeCalc = (value, minValue, maxValue, range) => {
    return minValue === maxValue
        ? DEFAULT_FONT_SIZE
        : DEFAULT_FONT_SIZE +
            Math.ceil((((range - 1) * (value - minValue)) / (maxValue - minValue)) * DEFAULT_FONT_SIZE);
};
/**
 * returns initial font size arr of items for layout
 * @param {Array} items
 * @return {Array}
 */
function getInitialFontSize(items) {
    const fontSizeArr = [];
    let minValue = Number.MAX_VALUE;
    let maxValue = -Number.MAX_VALUE;
    // First iterate thru data items to find the min and max values
    for (let i = 0; i < items.length; i++) {
        minValue = Math.min(minValue, items[i].value);
        maxValue = Math.max(maxValue, items[i].value);
    }
    for (let i = 0; i < items.length; i++) {
        const x = fontSizeCalc(items[i].value, minValue, maxValue, 3);
        fontSizeArr.push({ ...items[i], fontSize: x });
    }
    return fontSizeArr;
}
/**
 * Calculates the line breaks for rectangular layout
 * @param {Array} arDims an array of dvt.Dimension objects for each tag
 * @param {number} width the available width
 * @return {Array} an array containing the starting tag index for each line in the layout
 * @private
 */
function calculateLineBreaks(arDims, width) {
    const hPadding = 2;
    const lines = [0];
    let curWidth = arDims[0].w + hPadding;
    if (arDims.length > 1) {
        for (let i = 1; i < arDims.length; i++) {
            if (curWidth + arDims[i].w > width) {
                lines.push(i);
                curWidth = 0;
            }
            curWidth += arDims[i].w + hPadding;
        }
    }
    return lines;
}
/**
 * Returns the items position and font size in cloud layout.
 * @param items
 * @param tagcloudH
 * @param tagcloudW
 */
function getCloudLayout(items, tagcloudW, tagcloudH, isRTL, getTextDimensions) {
    const positions = [];
    const steps = 180;
    let xrStep = 10 / steps;
    let yrStep = 10 / steps;
    if (tagcloudW > tagcloudH)
        xrStep *= tagcloudW / tagcloudH;
    else
        yrStep *= tagcloudH / tagcloudW;
    const thetaStep = (2 * Math.PI) / steps;
    let bounds = null;
    let maxFontSize = 0;
    const cosCache = [];
    const sinCache = [];
    const tagWordData = [];
    const tagCloudX = 0; // availSpace.x
    const tagCloudY = 0; // availSpace.y
    const initialFontItems = getInitialFontSize(items);
    for (let i = 0; i < initialFontItems.length; i++) {
        let placed = false;
        let step = 0;
        let stepIncrement = 4;
        const tag = initialFontItems[i];
        const tagDimensions = getTextDimensions(tag.label, {
            fontSize: tag.fontSize + 'px'
        });
        maxFontSize = Math.max(maxFontSize, tag.fontSize);
        let lastCollisionIndex = -1;
        while (!placed) {
            // cache sin/cos values because Chrome is slow at these calculations
            const lookup = step % steps;
            if (cosCache[lookup] === undefined)
                cosCache[lookup] = Math.cos(step * thetaStep);
            if (sinCache[lookup] === undefined)
                sinCache[lookup] = Math.sin(step * thetaStep);
            const _x = xrStep * step * cosCache[lookup];
            const _y = yrStep * step * sinCache[lookup];
            const padding = getItemPadding(tagDimensions.height);
            const tagCloudDiv = {
                x: _x,
                y: _y,
                w: tagDimensions.width + 2 * padding,
                h: tagDimensions.height + 2 * padding
            }; // this needs to change
            placed = true;
            if (lastCollisionIndex !== -1) {
                if (intersects(positions[lastCollisionIndex], tagCloudDiv)) {
                    placed = false;
                }
            }
            if (placed) {
                for (let j = 0; j < i; j++) {
                    if (intersects(positions[j], tagCloudDiv)) {
                        lastCollisionIndex = j;
                        placed = false;
                        break;
                    }
                }
            }
            if (placed) {
                if (!bounds) {
                    bounds = tagCloudDiv;
                }
                else {
                    bounds = getUnion(bounds, tagCloudDiv);
                }
                lastCollisionIndex = -1;
                positions[i] = tagCloudDiv;
                tag.x = _x; // tag.setX(x)
                tag.y = _y; // tag.setY(-tagCloudDiv.y + y);
                tag.w = tagDimensions.width;
                tag.h = tagDimensions.height;
            }
            // Adjust stepIncrement so we check smaller degrees as spiral loops out
            if (step == 3600) {
                // 20 loops
                stepIncrement = 3;
            }
            else if (step == 5400) {
                // 30 loops
                stepIncrement = 2;
            }
            else if (step == 10800) {
                // 60 loops
                stepIncrement = 1;
            }
            step += stepIncrement;
        }
    }
    if (bounds) {
        const scale = Math.max(bounds.w / tagcloudW, bounds.h / tagcloudH);
        const cx = bounds.x + bounds.w / 2;
        const cy = bounds.y + bounds.h / 2;
        for (let k = 0; k < initialFontItems.length; k++) {
            let tagItemX;
            const tagItem = initialFontItems[k];
            if (!isRTL) {
                tagItemX =
                    tagItem.x != null ? tagCloudX + tagItem.x / scale + (tagcloudW / 2 - cx / scale) : 0;
            }
            else {
                tagItemX =
                    tagItem.x != null ? tagCloudX - tagItem.x / scale - (tagcloudW / 2 - cx / scale) : 0;
            }
            const tagItemY = tagItem.y != null ? tagCloudY + tagItem.y / scale + (tagcloudH / 2 - cy / scale) : 0;
            const tagItemW = tagItem.w != null ? tagItem.w / scale : 0;
            const tagItemH = tagItem.h != null ? tagItem.h / scale : 0;
            const fontSize = tagItem.fontSize;
            const tagItemFontSize = fontSize / scale;
            tagWordData.push({
                ...tagItem,
                x: tagItemX,
                y: tagItemY,
                fontSize: tagItemFontSize,
                w: tagItemW,
                h: tagItemH
            });
        }
    }
    return tagWordData;
}
/**
 * Returns the items position and font size in rectangle layout.
 * @param items
 * @param hiddenIds
 * @param tagcloudH
 * @param tagcloudW
 */
function getRectangleLayout(items, tagcloudW, tagcloudH, isRTL, getTextDimensions) {
    const tagWordData = [];
    const arDims = [];
    let maxWidth = 0;
    let maxHeight = 0;
    let maxFontSize = 0;
    const vPadding = 2;
    const margin = 0;
    const tagCloudX = 0; // availSpace.x
    const tagCloudY = 0; // availSpace.y
    // initial items processing
    const initialFontItems = getInitialFontSize(items);
    // Get the unscaled dimensions
    for (let i = 0; i < initialFontItems.length; i++) {
        const tag = initialFontItems[i];
        const tagDimensions = getTextDimensions(tag.label, {
            fontSize: tag.fontSize + 'px'
        });
        maxWidth = Math.max(maxWidth, tagDimensions.width);
        maxHeight = Math.max(maxHeight, tagDimensions.height);
        maxFontSize = Math.max(maxFontSize, tag.fontSize);
        arDims.push({
            w: tagDimensions.width,
            h: tagDimensions.height,
            x: tagDimensions.x,
            y: tagDimensions.y
        });
    }
    // Iteratively calculate the ideal font scale
    let minScale = 0;
    let maxScale = (tagcloudW - 2 * margin) / maxWidth; // This is the max scale that can be applied before the longest word will no longer fit
    let scale;
    let arLines;
    while (maxScale - minScale > 0.001) {
        scale = (minScale + maxScale) / 2;
        arLines = calculateLineBreaks(arDims, (tagcloudW - 2 * margin) / scale);
        const h = arLines.length * (scale * maxHeight + vPadding) - vPadding;
        if (h > tagcloudH - 2 * margin) {
            maxScale = scale;
        }
        else {
            minScale = scale;
        }
    }
    // Calculate final line breaks
    scale = minScale;
    arLines = calculateLineBreaks(arDims, (tagcloudW - 2 * margin) / scale);
    arLines.push(initialFontItems.length);
    for (let k = 0; k < arLines.length - 1; k++) {
        const lineStart = arLines[k];
        const lineEnd = arLines[k + 1];
        let hPadding = 5;
        let maxLineHeight = 0;
        let justified = true;
        if (lineEnd - lineStart > 1) {
            let lineWidth = 0;
            for (let j = lineStart; j < lineEnd; j++) {
                lineWidth += arDims[j].w * scale;
                maxLineHeight = Math.max(maxLineHeight, arDims[j].h * scale);
            }
            hPadding = (tagcloudW - 2 * margin - lineWidth) / (lineEnd - lineStart - 1);
            if (k == arLines.length - 2) {
                // Don't justify the last line unless flowing it with a gap of .5 * maxLineHeight fills more than
                // 90% of the width
                const flowPadding = 0.5 * maxLineHeight;
                if (flowPadding < hPadding &&
                    lineWidth + (lineEnd - lineStart) * flowPadding < 0.9 * (tagcloudW - 2 * margin)) {
                    hPadding = flowPadding;
                    justified = false;
                }
            }
        }
        const bottomY = margin + (k + 1) * (maxHeight * scale + vPadding) - vPadding;
        let curX = margin;
        for (let m = lineStart; m < lineEnd; m++) {
            const tagLine = initialFontItems[m];
            const fontSize = tagLine.fontSize;
            const tagItemFontSize = fontSize * scale;
            tagLine.fontSize = tagItemFontSize;
            const tagDimensionsWidth = arDims[m].w * scale;
            tagLine.y = tagCloudY + bottomY + arDims[m].y * scale - BOTTOM_PADDING;
            if (justified && m === lineEnd - 1 && m !== lineStart) {
                if (!isRTL)
                    tagLine.x = tagCloudX + tagcloudW - tagDimensionsWidth - margin;
                else
                    tagLine.x = tagCloudX + tagDimensionsWidth + margin - tagcloudW;
                // alignRight(tagLine);
            }
            else {
                // alignLeft(tagLine);
                tagLine.x = tagCloudX + curX;
                if (!isRTL) {
                    curX += arDims[m].w * scale + hPadding;
                }
                else {
                    // tagLine.alignRight();
                    curX -= arDims[m].w * scale + hPadding;
                }
            }
            tagWordData.push({ ...tagLine, w: tagDimensionsWidth, h: arDims[m].h * scale });
        }
    }
    return tagWordData;
}
/**
 * Calls the right layout algorithm based on tagcloud type.
 * @param layout cloud or rectangle. cloud if not defined.
 * @param items
 * @param hiddenIds
 * @param tagcloudH tagcloud height
 * @param tagcloudW tagcloud width
 */
function getLayout(layout, items, tagcloudW, tagcloudH, isRTL, getTextDimensions) {
    let layoutTagCloud;
    if (layout === 'cloud' || !layout) {
        layoutTagCloud = getCloudLayout(items, tagcloudW, tagcloudH, isRTL, getTextDimensions);
    }
    else {
        layoutTagCloud = getRectangleLayout(items, tagcloudW, tagcloudH, isRTL, getTextDimensions);
    }
    return layoutTagCloud;
}
/**
 * Checks if the item is highlighted.
 * @param id Id of the item
 * @param highlighted The set of highlighted item
 */
function isItemHighlighted(id, highlightedIds) {
    if (!highlightedIds) {
        return;
    }
    if (highlightedIds.length === 0) {
        return true;
    }
    return new Set(highlightedIds).has(id);
}
/**
 * Checks if the item is highlighted.
 * @param id Id of the item
 * @param selectedIds The set of highlighted item
 */
function isItemSelected(id, selectedIds) {
    if (!selectedIds || selectedIds.length === 0) {
        return false;
    }
    return new Set(selectedIds).has(id);
}
/**
 * Checks if the item is hidden.
 * @param id Id of the item.
 * @param hiddenIds The set of hidden items.
 * @returns
 */
function isItemHidden(id, hiddenIds) {
    if (!hiddenIds) {
        return;
    }
    return new Set(hiddenIds).has(id);
}
/**
 * Returns the aria properties for the tag cloud.
 * @param isReadOnly { boolean } If the tag cloud is readonly.
 * @param accessibleLabel { string } The aria-label set by the app.
 * @returns The aria props.
 */
function getAriaProps(translations, hasData, accessibleLabel) {
    return {
        'aria-label': `${accessibleLabel || ''} ${hasData ? '' : translations.dataVisualization_noData()}`,
        role: 'application'
    };
}
/**
 * Returns the aria properties for the tag cloud.
 * @param isReadOnly { boolean } If the tag cloud is readonly.
 * @param accessibleLabel { string } The aria-label set by the app.
 * @returns The aria props.
 */
function getItemAriaProps(supportsSelection, translations, isSelected, accessibleLabel, role) {
    const selectionAriaLabel = !supportsSelection
        ? ''
        : isSelected
            ? translations?.dataVisualization_stateSelected()
            : translations?.dataVisualization_stateUnselected();
    return {
        'aria-label': [accessibleLabel, selectionAriaLabel].filter(Boolean).join('. ') || undefined,
        role: role || 'img'
    };
}
/**
 * Returns the item props for BaseTagCloudItem.
 * @param item The tagcloud item.
 * @param itemId The item index of the item.
 * @param focusedItem The info of currently focused item.
 * @param isReadOnly Whether the tagcloud is readonly.
 * @param hoveredItem The info of the currently hovered item.
 * @param hiddenIds The hidden ids.
 * @param highlightedIds The highlighted ids.
 */
function getItemProps(item, itemIdx, supportsSelection, isReadOnly, hoveredItem, selectedIds, focusedItem, highlightedIds, activeId) {
    let isCurrent = false;
    let style;
    if (!isReadOnly) {
        const isFocusedItem = itemIdx === focusedItem?.idx;
        const isHoveredItem = itemIdx === hoveredItem?.idx;
        isCurrent = !!((isFocusedItem && focusedItem?.isCurrent) ||
            (isHoveredItem && hoveredItem?.isCurrent));
    }
    const isHighlighted = isItemHighlighted(item.id, highlightedIds);
    const isSelected = isItemSelected(item.id, selectedIds);
    if (item.color) {
        let color, backgroundColor, backgroundImage;
        if (isSelected) {
            backgroundColor = item.color;
            color = getContrastingTextColor(backgroundColor);
        }
        // hovered and selection supported
        else
            color = item.color;
        style = {
            color,
            backgroundColor,
            backgroundImage
        };
    }
    else if (!supportsSelection) {
        style = {
            backgroundColor: 'none'
        };
    }
    return {
        isCurrent,
        isHighlighted: isHighlighted,
        isSelected: isSelected,
        isFocused: focusedItem ? hasFocusRing(focusedItem, itemIdx) : false,
        key: item.id,
        itemIdx,
        style,
        activeId: isCurrent ? activeId : undefined,
        isReadOnly,
        ...item
    };
}
/**
 * Returns the text for the tag cloud datatip.
 * @param items The tag cloud items data.
 * @param focusedItem The item currently keyboard focused.
 * @param hoveredItem The item that is currently hovered.
 * @param datatip The datatip.
 */
function getDatatipText(items, getItem, focusedItem, hoveredItem, datatip) {
    if (datatip)
        return datatip;
    const isPointerActive = hoveredItem?.isCurrent;
    if (isPointerActive && hoveredItem.idx != null) {
        return getItem(hoveredItem, items)?.accessibleLabel;
    }
    if (focusedItem && focusedItem.isCurrent) {
        return getItem(focusedItem, items)?.accessibleLabel;
    }
    return;
}
/**
 * Returns the value of the data-oj-item-index attribute for a given element.
 * @param element The HTML element.
 */
function getItemInfo(element) {
    const itemIdx = element.dataset['idx'];
    if (itemIdx == null)
        return;
    return {
        idx: Number(itemIdx)
    };
}
/**
 * Compares if two ItemInfo are equal
 * @param item1
 * @param item2
 * @returns
 */
function isEqualItem(item1, item2) {
    return item1?.idx === item2?.idx;
}
/**
 * Checks if the item is the currentItem and if the focus ring
 * is visible.
 * @param itemInfo ItemInfo
 * @param itemId Item index
 */
function hasFocusRing(itemInfo, itemIdx) {
    if (!itemInfo.isFocusVisible)
        return false;
    const { idx: idx } = itemInfo;
    return idx === itemIdx;
}

const TagCloudItem = (props) => {
    const { itemBase, itemStyle, hoverUnselectedItemStyle, selectedItemStyle, hoveredSelectedItemStyle, dimmedItemStyle, interactiveCursorStyle } = styles;
    const isNotDimmed = props.isHighlighted || props.isHighlighted == null; // null means no highlighting feature
    const itemClasses = classNames([
        itemBase,
        props.isSelected ? selectedItemStyle : itemStyle,
        props.isCurrent
            ? props.isSelected
                ? hoveredSelectedItemStyle
                : props.isFocused || props.supportsSelection
                    ? hoverUnselectedItemStyle
                    : ''
            : '',
        isNotDimmed ? '' : dimmedItemStyle,
        props.supportsAction || props.supportsSelection ? interactiveCursorStyle : ''
    ]);
    const itemAriaProps = getItemAriaProps(!!props.supportsSelection, props.translations, props.isSelected, props.accessibleLabel, props.role);
    const padding = getItemPadding(props.h);
    return (jsx("div", { class: itemClasses, "data-id": `${props.id}`, "data-idx": props.itemIdx, style: {
            ...props.style,
            transform: `translate(${(props.x || 0) - padding}px,${(props.y || 0) - padding}px)`,
            fontSize: props.fontSize,
            padding: `${padding}px`,
            lineHeight: props.fontSize + 'px'
        }, id: props.activeId, ...itemAriaProps, children: props.label }));
};

function useEvents(isInteractive, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onInput) {
    const [focusedItemInfo, setfocusedItemInfo] = useState({ idx: 0 });
    const [hoveredItemInfo, sethoveredItemInfo] = useState();
    const activeId = useRef();
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const cancelEvent = (event) => {
        event.preventDefault();
        event.stopPropagation();
    };
    const hoverHandler = (event) => {
        const itemInfo = getItemInfo(event.target);
        if (!isEqualItem(itemInfo, hoveredItemInfo)) {
            sethoveredItemInfo(itemInfo && { ...itemInfo, isCurrent: true });
            activeId.current = getRandomId();
            if (isInteractive) {
                setfocusedItemInfo({ ...focusedItemInfo, isCurrent: false });
                onInput?.(getDetailFromInfo(itemInfo));
            }
        }
    };
    const pointerLeaveHandler = () => {
        sethoveredItemInfo(undefined);
        activeId.current = undefined;
        if (isInteractive) {
            onInput?.(getDetailFromInfo());
        }
    };
    if (!isInteractive) {
        return {
            focusedItemInfo,
            hoveredItemInfo,
            // include pointer leave and pointer move for datatip
            onPointerLeave: pointerLeaveHandler,
            onPointerMove: hoverHandler
        };
    }
    function updatefocusedItemInfo(itemInfo) {
        onInput?.(getDetailFromInfo(itemInfo));
        activeId.current = getRandomId();
        setfocusedItemInfo(itemInfo);
    }
    function handleKeyboardInput(item) {
        if (!isEqualItem(item, focusedItemInfo)) {
            item.isCurrent = true;
            item.isFocusVisible = true;
            if (hoveredItemInfo) {
                sethoveredItemInfo({ ...hoveredItemInfo, isCurrent: false });
            }
            updatefocusedItemInfo(item);
        }
    }
    const triggerOnAction = () => {
        const { id } = getDetailFromInfo(focusedItemInfo);
        if (id != null) {
            onItemAction?.({ id });
            activeId.current = getRandomId();
        }
    };
    const pointerUpHandler = (event) => {
        const itemInfo = getItemInfo(event.target);
        if (itemInfo != null) {
            setfocusedItemInfo(itemInfo);
            const { id } = getDetailFromInfo(itemInfo);
            if (id != null) {
                onItemAction?.({ id });
                activeId.current = getRandomId();
            }
        }
        else
            onItemAction?.({ id: undefined });
    };
    const keyDownHandler = (event) => {
        const key = event.key;
        switch (key) {
            case 'Tab':
                return;
            case 'ArrowDown': {
                const nextItemInfo = getNextItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                break;
            }
            case 'ArrowUp': {
                const nextItemInfo = getPrevItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                break;
            }
            case 'ArrowRight': {
                const nextItemInfo = isRtl
                    ? getPrevItemInfo(focusedItemInfo)
                    : getNextItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                break;
            }
            case 'ArrowLeft': {
                const nextItemInfo = isRtl
                    ? getNextItemInfo(focusedItemInfo)
                    : getPrevItemInfo(focusedItemInfo);
                handleKeyboardInput(nextItemInfo);
                break;
            }
        }
        cancelEvent(event);
    };
    const keyUpHandler = (event) => {
        const key = event.code;
        switch (key) {
            case 'Space': {
                triggerOnAction();
                break;
            }
            case 'Enter': {
                triggerOnAction();
                break;
            }
            case 'Tab': {
                updatefocusedItemInfo({
                    ...focusedItemInfo,
                    isCurrent: true,
                    isFocusVisible: true
                });
                break;
            }
        }
    };
    const blurHandler = () => {
        if (hoveredItemInfo != null || focusedItemInfo.isCurrent) {
            onInput?.(getDetailFromInfo(undefined));
        }
        const itemInfo = { ...focusedItemInfo, isCurrent: false, isFocusVisible: false };
        setfocusedItemInfo(itemInfo);
    };
    return {
        focusedItemInfo,
        hoveredItemInfo,
        'aria-activedescendant': activeId.current,
        onPointerUp: pointerUpHandler,
        onPointerMove: hoverHandler,
        onKeyUp: keyUpHandler,
        onKeyDown: keyDownHandler,
        onPointerLeave: pointerLeaveHandler,
        onBlur: blurHandler
    };
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */
const DEFAULT_OFFSET = 8;
/**
 * Calculate the datatip offset for datatip when keyboard focus is active.
 * @param rootRef The ref for root of the tag cloud.
 * @param currentItem The ItemInfo of the current keyboard focused item.
 * @param isRtl The direction.
 * @param focusedItemRef The ref for currentItem node.
 * @returns
 */
const calculateOffset = (rootRef, currentItem, isRtl, focusedItemRef) => {
    let crossAxis = 0;
    let mainAxisOffset = DEFAULT_OFFSET;
    if (focusedItemRef?.current &&
        currentItem.isCurrent &&
        rootRef.current &&
        focusedItemRef?.current.x != null &&
        focusedItemRef?.current.w != null &&
        focusedItemRef?.current.y != null &&
        focusedItemRef?.current.h != null) {
        const rootDim = rootRef.current.getBoundingClientRect(); // TODO: make this more efficient
        crossAxis =
            (isRtl ? -1 : 1) * focusedItemRef.current.x +
                focusedItemRef.current.w / 2 -
                rootDim.width / 2;
        mainAxisOffset += -1 * focusedItemRef.current.y;
    }
    return { crossAxis, mainAxis: mainAxisOffset };
};
/**
 * Returns the datatip.
 * @param text The text string for the tag cloud item.
 * @param rootRef The ref for root of the tag cloud.
 * @param focusedItemRef The ref for focused item node.
 * @param focusedItemInfo The ItemInfo for focused item node.
 * @returns
 */
const useTagCloudDatatip = ({ text, rootRef, focusedItemRef, focusedItemInfo }) => {
    const { direction } = useUser();
    const isRtl = direction === 'rtl';
    const [offset, setOffset] = useState(calculateOffset(rootRef, focusedItemInfo, isRtl, focusedItemRef));
    const [isOpen, setIsOpen] = useState(false);
    useLayoutEffect(() => {
        setOffset(calculateOffset(rootRef, focusedItemInfo, isRtl, focusedItemRef));
    }, [focusedItemInfo]);
    const anchor = focusedItemInfo?.isCurrent ? 'element' : 'pointer';
    const { tooltipContent, tooltipProps } = useTooltipControlled({
        text: text,
        position: 'top',
        isDisabled: false,
        variant: 'datatip',
        anchor: { x: anchor, y: anchor },
        offset: offset,
        isOpen,
        onToggle: ({ value }) => setIsOpen(value)
    });
    return { datatipContent: tooltipContent, datatipProps: tooltipProps };
};

/**
 * Tag clouds are used to display text data with the importance of each tag shown with font size and/or color.
 */
function TagCloud({ selectionMode = 'none', layout = 'cloud', height = '112x', width = '100%', items, onItemAction, onItemInput, ...props }) {
    const rootRef = useRef(null);
    const focusedItemRef = useRef(null);
    const translations = useTranslationBundle('@oracle/oraclejet-preact');
    const filteredItems = items.filter((i) => !props.hiddenIds?.includes(i.id));
    const hasData = filteredItems && filteredItems.length !== 0;
    const supportsSelection = !!(selectionMode && selectionMode !== 'none');
    const supportsAction = onItemAction != null;
    const isReadOnly = supportsAction && onItemInput === null;
    const ariaProps = getAriaProps(translations, hasData, props.accessibleLabel);
    const { getItem, getDetailFromInfo, getPrevItemInfo, getNextItemInfo } = getTagCloudNavUtils(filteredItems);
    const { hoveredItemInfo, focusedItemInfo, ...eventsProps } = useEvents(!isReadOnly && hasData, getDetailFromInfo, getPrevItemInfo, getNextItemInfo, onItemAction, onItemInput);
    const datatipText = getDatatipText(filteredItems, getItem, focusedItemInfo, hoveredItemInfo, props.datatip);
    const { datatipContent, datatipProps } = useTagCloudDatatip({
        text: datatipText,
        rootRef,
        focusedItemInfo,
        focusedItemRef
    });
    const idExtracter = (event) => {
        // return focused item for keyboard event.
        // eventsProps should have already updated the focused item
        const info = event.type === 'keyup' ? focusedItemInfo : getItemInfo(event.target);
        return getDetailFromInfo(info).id;
    };
    const selectionProps = useSelection({
        idExtracter,
        selection: props.selectedIds,
        selectionMode: selectionMode,
        onChange: props.onSelectionChange
    });
    const mergedProps = mergeProps(eventsProps, datatipProps, selectionProps);
    const { direction } = useUser();
    return (jsx(TrackResizeContainer, { width: sizeToCSS(width) || width || '0px', height: sizeToCSS(height) || height || '0px', children: (width, height) => {
            const { textMeasureContent, getTextDimensions } = useTextDimensions();
            const [layoutTags, setLayoutTags] = useState([]);
            useLayoutEffect(() => {
                if (!getTextDimensions || !hasData)
                    return;
                setLayoutTags(getLayout(layout, filteredItems, width, height, direction === 'rtl', getTextDimensions));
            }, [layout, filteredItems, width, height, direction, getTextDimensions]);
            return (jsxs("div", { ref: rootRef, tabIndex: isReadOnly ? undefined : 0, style: { width, height }, class: baseStyles, ...ariaProps, ...mergedProps, children: [layoutTags.map((item, itemIndex) => {
                        const itemProps = getItemProps(item, itemIndex, supportsSelection, isReadOnly, hoveredItemInfo, props.selectedIds, focusedItemInfo, props.highlightedIds, eventsProps['aria-activedescendant']);
                        const isFocusedItem = focusedItemInfo.idx === itemIndex;
                        isFocusedItem ? (focusedItemRef.current = item) : null;
                        return (jsx(TagCloudItem, { fontSize: item.fontSize, x: item.x, y: item.y, accessibleLabel: item.accessibleLabel, supportsSelection: supportsSelection, supportsAction: supportsAction, translations: translations, ...itemProps }));
                    }), textMeasureContent, datatipContent] }));
        } }));
}

/**
 * @license
 * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.
 * The Universal Permissive License (UPL), Version 1.0
 * as shown at https://oss.oracle.com/licenses/upl/
 * @ignore
 */

export { TagCloud };
//# sourceMappingURL=UNSAFE_TagCloud.js.map
