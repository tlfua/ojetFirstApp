/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx, jsxs } from 'preact/jsx-runtime';
import { Fragment } from 'preact';
import { forwardRef, useRef, useCallback, useEffect } from 'preact/compat';
import './utils/UNSAFE_classNames.js';

import { focusOn, focusWithin, focusOnEnd, focusOnStart, getActiveElement, isTabbableElement } from './utils/PRIVATE_tabbableUtils.js';
import { c as classNames } from './classNames-f414daad.js';

const styles = {
  guard: "_72dli0"
};
/**
 * Styled FocusTrap sub-component to render non-visible focus guards
 */
const FocusGuard = forwardRef(({
  onFocus
}, guardRef) => {
  return jsx("div", {
    class: styles.guard,
    onFocus: onFocus,
    ref: guardRef,
    tabIndex: 0
  });
});

/**
 * Trap focus within a DOM node.  When a user hits Tab or Shift+Tab, focus remains in the focus trap.
 */
const FocusTrap = ({
  autoFocusRef,
  children,
  isDisabled = false,
  restoreFocusRef
}) => {
  const trapRef = useRef(null);
  const startGuardRef = useRef(null);
  const endGuardRef = useRef(null);
  const lastActiveElementRef = useRef(null);
  // classes to be set on the children wrapper
  const classes = classNames([childrenStyles]);
  /**
   * contain focus if trap is enabled, and target is not already contained
   *
   * calling cases for side-effect of setting focus
   *   - on initial mount of (enabled) trap, where target is not inside trap
   *   - on enabling of a disabled trap, where target is not inside trap
   *   - target of click event is outside of trap.
   */
  const conditionallyContainFocus = useCallback(target => {
    const trap = trapRef.current;
    //  short-circuit, if trap or target not valid
    if (isDisabled || !trap || !target) return;
    // just update ref if, target already has focus
    if (target && hasFocus([trap, startGuardRef.current, endGuardRef.current], target)) {
      lastActiveElementRef.current = target;
      return;
    }
    // set focus to last active tab-stop if lastElement is defined and inside trap
    if (lastActiveElementRef.current) {
      focusOn(lastActiveElementRef.current);
    } else {
      // otherwise just contain focus within trap as target is outside enabled trap and we have no last-known tab-stop
      focusWithin(trap);
    }
  }, [isDisabled]);
  // loop focus
  const handleStartGuardOnFocus = event => {
    if (isDisabled || !trapRef.current) return;
    focusOnEnd(trapRef.current);
    // prevent scroll jump and bubbling this event up as a focus event
    event.stopPropagation();
    event.preventDefault();
  };
  const handleEndGuardOnFocus = event => {
    if (isDisabled || !trapRef.current) return;
    focusOnStart(trapRef.current);
    // prevent scroll jump and bubbling guard event up as a focus event
    event.stopPropagation();
    event.preventDefault();
  };
  const handleTrapOnFocus = event => {
    lastActiveElementRef.current = event.target;
  };
  // handle initial render or re-render as enabled
  useEffect(() => {
    const trap = trapRef.current;
    if (!trap || isDisabled) return;
    const originalActiveElement = getActiveElement(trap);
    // init focus
    if (autoFocusRef && autoFocusRef.current) {
      focusOn(autoFocusRef.current);
    } else {
      conditionallyContainFocus(originalActiveElement);
    }
    const restoreFocusRefForCleanup = restoreFocusRef;
    return () => {
      if (restoreFocusRefForCleanup === false) return;
      restoreFocusAfterUnmount(restoreFocusRefForCleanup?.current || originalActiveElement);
    };
  }, [autoFocusRef, conditionallyContainFocus, isDisabled, restoreFocusRef]);
  return jsxs(Fragment, {
    children: [!isDisabled && jsx(FocusGuard, {
      onFocus: handleStartGuardOnFocus,
      ref: startGuardRef
    }), jsx("div", {
      onFocus: handleTrapOnFocus,
      ref: trapRef,
      class: classes,
      children: children
    }), !isDisabled && jsx(FocusGuard, {
      onFocus: handleEndGuardOnFocus,
      ref: endGuardRef
    })]
  });
};
// setTimeout ensures that unmount lifecycle has completed
const restoreFocusAfterUnmount = element => {
  if (element && isTabbableElement(element)) {
    setTimeout(() => {
      focusOn(element);
    }, 0);
  }
};
// is focus already contained?
const hasFocus = (elements, target) => {
  if (elements.length === 0) return false;
  const activeElement = target ?? getActiveElement(elements[0]);
  return elements.some(el => el === activeElement || el?.contains(activeElement));
};
// remove margins from children
const childrenStyles = "_14asjhp";

export { FocusTrap as F };
//# sourceMappingURL=FocusTrap-9dc31155.js.map
