/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx } from 'preact/jsx-runtime';
import { useState, useRef, useCallback, useEffect } from 'preact/hooks';
import { Layer } from './UNSAFE_Layer.js';
import './UNSAFE_Modal.js';
import './UNSAFE_FocusTrap.js';
import { getActiveElement, focusWithin, focusOn } from './utils/PRIVATE_tabbableUtils.js';
import { normalizePosition } from './utils/PRIVATE_floatingUtils.js';
import './utils/PRIVATE_clientHints.js';
import { useOutsideClick } from './hooks/UNSAFE_useOutsideClick.js';
import './hooks/UNSAFE_useAnimation.js';
import { useUser } from './hooks/UNSAFE_useUser.js';
import { useComponentTheme } from './hooks/UNSAFE_useComponentTheme.js';
import { colorInterpolations } from './utils/UNSAFE_interpolations/colors.js';
import { mergeInterpolations } from './utils/UNSAFE_mergeInterpolations.js';
import { DrawerPopupRedwoodTheme } from './UNSAFE_DrawerPopup/themes/redwood/DrawerPopupTheme.js';
import { u as useAnimation } from './useAnimation-50c5f5fb.js';
import { g as getClientHints } from './clientHints-26cce6ec.js';
import { F as FocusTrap } from './FocusTrap-9dc31155.js';
import { M as Modal } from './Modal-33f98fb6.js';
import 'preact/compat';
import './index-f26154f2.js';
import 'preact';
import './Common.js';
import './Common/themes.js';
import './Common/themes/redwood/theme.js';
import './Common/themes/themeContract.css.js';
import './useThemeInterpolations-48ee20a7.js';
import './hooks/UNSAFE_useColorScheme.js';
import './hooks/UNSAFE_useScale.js';
import './utils/UNSAFE_interpolations/theme.js';
import './UNSAFE_Theme.js';
import './utils-9a0cb8dc.js';
import './utils/UNSAFE_classNames.js';
import './classNames-f414daad.js';
import './_curry1-7629ff3f.js';
import './_curry3-bb17e901.js';
import './_curry2-820ed778.js';
import './_has-057b6f90.js';
import './useModal-e580c081.js';
import './UNSAFE_Modal/themes/ModalStyles.css.js';
import './ModalStyles.styles.css';
import './vanilla-extract-recipes-createRuntimeFn.esm-3311d9ef.js';

import './_arity-cb2c60f3.js';
import './utils/UNSAFE_arrayUtils.js';
import './utils/UNSAFE_logger.js';
import './UNSAFE_DrawerPopup/themes/redwood/DrawerPopupBaseTheme.css.js';
import './UNSAFE_DrawerPopup/themes/redwood/DrawerPopupBaseTheme.styles.css';
import './UNSAFE_DrawerPopup/themes/DrawerPopupStyles.css.js';
import './DrawerPopupStyles.styles.css';
import './UNSAFE_DrawerPopup/themes/redwood/DrawerPopupVariants.css.js';
import './DrawerPopupVariants.styles.css';

// Constants
const displayModefullWidthThreshold = 600;
const zero = '0px';
const duration = 250;
const getElementHeight = (element) => {
    return Math.round(element.offsetHeight);
};
const getElementWidth = (element) => {
    return Math.round(element.getBoundingClientRect().width);
};
/**
 * A drawer popup adds a single slide-in side content alongside some primary content to an application window.
 *
 * This drawer always overlays the page and can be placed at the 'start', 'end' or 'bottom' edge.
 */
const DrawerPopup = ({ children, isOpen = false, autoFocusRef, placement = 'start', modality = 'modal', onClose, onTransitionEnd, 'aria-label': ariaLabel, 'aria-labelledby': ariaLabelledBy, 'aria-describedby': ariaDescribedBy, ...props }) => {
    // Initialize states
    const [status, setStatus] = useState(isOpen ? 'initial' : 'unmounted');
    const [visibility, setVisibility] = useState('hidden');
    const [isOutsideClickDisabled, setIsOutsideClickDisabled] = useState(!isOpen);
    const [displayModeHorizontal, setDisplayModeHorizontal] = useState('overlay');
    const rootRef = useRef(null);
    const launcherRef = useRef(null);
    const isBottomPlacement = placement === 'bottom';
    // Animation config
    const animationStates = {
        opening: () => {
            if (isBottomPlacement) {
                return {
                    from: {
                        translateY: getTranslateY()
                    },
                    to: {
                        translateY: zero
                    },
                    options: {
                        duration: duration
                    }
                };
            }
            else {
                return {
                    from: {
                        translateX: getTranslateX()
                    },
                    to: {
                        translateX: zero
                    },
                    options: {
                        duration: duration
                    }
                };
            }
        },
        closing: () => {
            if (isBottomPlacement) {
                return {
                    from: {
                        translateY: zero
                    },
                    to: {
                        translateY: getTranslateY()
                    },
                    options: {
                        duration: duration
                    }
                };
            }
            else {
                return {
                    from: {
                        translateX: zero
                    },
                    to: {
                        translateX: getTranslateX()
                    },
                    options: {
                        duration: duration
                    }
                };
            }
        }
    };
    // Normalizing position
    const { direction } = useUser();
    const getNormalizedPlacement = () => {
        return normalizePosition(placement, direction);
    };
    const getTranslateX = () => {
        return `${getNormalizedPlacement() === 'right' ? '' : '-'}${getElementWidth(rootRef.current)}px`;
    };
    const getTranslateY = () => {
        return `${getElementHeight(rootRef.current)}px`;
    };
    // Animation
    const { nodeRef } = useAnimation(status, {
        animationStates,
        isAnimatedOnMount: true,
        onAnimationEnd: useCallback(() => {
            if (status === 'opening') {
                onTransitionEnd?.(true);
            }
            else if (!isOpen) {
                nodeRef(null);
                setVisibility('hidden');
                setStatus('unmounted');
                onTransitionEnd?.(false);
            }
        }, [status, isOpen])
    });
    useEffect(() => {
        // 1. Ignore status update on initial render
        if (status === 'unmounted' && !isOpen) {
            return;
        }
        // 2. Mount visually hidden component
        // Component gets mounted, but will be visually hidden to avoid flickering
        // Flickering happens because it gets rendered before animation hook repositions
        // it in next render cycle
        if (status === 'unmounted' && isOpen) {
            setStatus('initial');
            return;
        }
        // 3. Setup animation
        // Component has been mounted.
        // We will kick out animation as node is already present in DOM.
        // To avoid flickering, we still keep it visually hidden until the next render cycle.
        if (status === 'initial' && isOpen) {
            nodeRef(rootRef.current);
            setIsOutsideClickDisabled(false);
            setStatus('opening');
            return;
        }
        // 3. Unhide component. It becomes visible.
        if (status === 'opening' && isOpen) {
            setVisibility('visible');
            return;
        }
        // 4. Closing
        if (!isOpen) {
            setIsOutsideClickDisabled(true);
            setStatus('closing');
        }
    }, [isOpen, status]);
    // Launcher handler
    useEffect(() => {
        if (status === 'opening') {
            // Remember launcher
            const activeElement = getActiveElement();
            launcherRef.current = activeElement === document.body ? document.body : activeElement;
            // Register F6 key handler to enter the Popup
            launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);
        }
        if (status === 'closing') {
            return () => {
                // Deregister F6 key handler
                launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);
            };
        }
        return;
    }, [status]);
    const launcherKeyDownCallback = (event) => {
        // Moves focus from launcher (must have focus) back to the Drawer
        if (launcherRef.current === getActiveElement() && event.code === 'F6') {
            // Prevent default F6 handlers.
            // F6 is a standard Chrome address bar shortcut on Windows.
            event.preventDefault();
            event.stopPropagation();
            // Focus on first tabbable in a container or container itself if there is none
            focusWithin(rootRef.current);
        }
    };
    const handleKeyDown = useCallback((event) => {
        const launcherEl = launcherRef.current;
        switch (event.code) {
            case 'Escape': {
                onClose?.({ reason: 'escapeKey' });
                break;
            }
            case 'F6':
                // Prevent default F6 handlers.
                // F6 is a standard Chrome address bar shortcut on Windows.
                event.preventDefault();
                event.stopPropagation();
                // Focus launcher
                if (launcherEl) {
                    focusOn(launcherEl);
                }
                break;
        }
    }, [onClose]);
    // OutsideClick handler
    const handleOutsideClick = useCallback(() => {
        // Trigger onClose event with outside click detail
        onClose?.({ reason: 'outsideClick' });
    }, [onClose]);
    useOutsideClick({
        isDisabled: isOutsideClickDisabled,
        ref: rootRef,
        handler: handleOutsideClick
    });
    // Drawer placement
    const getDrawerPlacement = () => {
        if (isBottomPlacement) {
            return placement;
        }
        else {
            if (direction === 'rtl') {
                return placement === 'start' ? 'right' : 'left';
            }
            else {
                return placement === 'start' ? 'left' : 'right';
            }
        }
    };
    // Window resize handler
    // Handles display mode: Overlay <> Full overlay (full width side drawers)
    const handleResize = () => {
        const viewportWidth = getViewportWidth();
        if (displayModeHorizontal === 'overlay' && viewportWidth < displayModefullWidthThreshold) {
            setDisplayModeHorizontal('fullOverlay');
        }
        if (displayModeHorizontal === 'fullOverlay' && viewportWidth > displayModefullWidthThreshold) {
            setDisplayModeHorizontal('overlay');
        }
    };
    const clientHints = getClientHints();
    const getViewportWidth = () => {
        if (clientHints.platform === 'ios') {
            // On ios window.innerWidth is not recommended way of measuring the viewport
            return document.documentElement.clientWidth;
        }
        return window.innerWidth;
    };
    useEffect(() => {
        const root = rootRef.current;
        if (root) {
            const resizeObserver = new ResizeObserver(() => {
                handleResize();
            });
            resizeObserver.observe(document.body);
            return () => {
                resizeObserver.unobserve(document.body);
            };
        }
        return undefined;
    }, [handleResize]);
    // Styles
    const { classes } = useComponentTheme(DrawerPopupRedwoodTheme, {
        placement: getDrawerPlacement(),
        visibility,
        displayModeHorizontal
    });
    const interpolations = [...Object.values(colorInterpolations)];
    const styleInterpolations = mergeInterpolations(interpolations);
    const { ...styles } = styleInterpolations(props);
    const renderDrawer = () => {
        return (jsx("div", { ref: rootRef, className: classes, style: styles, tabIndex: -1, role: "dialog", onKeyDown: handleKeyDown, "aria-label": ariaLabel, "aria-labeledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, children: jsx(FocusTrap, { autoFocusRef: autoFocusRef, children: children }) }));
    };
    const isMounted = status !== 'unmounted';
    if (isMounted) {
        // Modal vs. modelss upper wrapper
        if (modality === 'modal') {
            return jsx(Modal, { isOpen: isMounted, children: renderDrawer() });
        }
        else {
            return jsx(Layer, { children: renderDrawer() });
        }
    }
    return null;
};

export { DrawerPopup };
//# sourceMappingURL=UNSAFE_DrawerPopup.js.map
