{"version":3,"file":"FocusTrap-9dc31155.js","sources":["../../src/UNSAFE_FocusTrap/FocusGuard.tsx","../../src/UNSAFE_FocusTrap/FocusTrap.tsx"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\n\ntype Props = {\n  onFocus: (event: FocusEvent) => void;\n};\n\nconst styles = {\n  guard: cssProps`${{\n    height: '0px',\n    left: 0,\n    position: 'fixed',\n    top: 0,\n    width: '1px'\n  }}`\n};\n\n/**\n * Styled FocusTrap sub-component to render non-visible focus guards\n */\nconst FocusGuard = forwardRef(({ onFocus }: Props, guardRef: ForwardedRef<HTMLDivElement>) => {\n  return <div class={styles.guard} onFocus={onFocus} ref={guardRef} tabIndex={0} />;\n});\n\nexport default FocusGuard;\n","/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\nimport { ComponentChildren, Fragment, RefObject } from 'preact';\nimport { useCallback, useEffect, useRef } from 'preact/compat';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { cssProps } from '@oracle/oraclejet-cssprops';\nimport {\n  focusOn,\n  focusOnEnd,\n  focusOnStart,\n  focusWithin,\n  getActiveElement,\n  isTabbableElement\n} from '../utils/PRIVATE_tabbableUtils';\nimport FocusGuard from './FocusGuard';\n\ntype Props = {\n  children: ComponentChildren;\n  /**\n   * Optional Ref to an element to focus on when component mounts\n   * @default - undefined - behavior is to focus on first tabbableElement\n   */\n  autoFocusRef?: RefObject<HTMLElement | null>;\n\n  /**\n   * Sets whether focus is managed and whether guards are present\n   * @default false\n   */\n  isDisabled?: boolean;\n\n  /**\n   * Why a isDisabled prop as compared to ONLY supporting conditional rendering?\n   *\n   *   1) We need an actual HTML Element for the trap, conditional rendering an element potentially breaks consumer CSS\n   *   2) Conditional rendering can short-circuit event bubbling in preact and lead to expected events not bubbling.\n   */\n\n  /**\n   * Optional Ref to element to focus on when component un-mounts, false to disable.\n   * @default - undefined - behavior is to focus on the original activeElement when focus trap was enabled\n   */\n  restoreFocusRef?: RefObject<HTMLElement> | false;\n};\n\n/**\n * Trap focus within a DOM node.  When a user hits Tab or Shift+Tab, focus remains in the focus trap.\n */\nexport const FocusTrap = ({\n  autoFocusRef,\n  children,\n  isDisabled = false,\n  restoreFocusRef\n}: Props) => {\n  const trapRef = useRef<HTMLDivElement>(null);\n  const startGuardRef = useRef<HTMLDivElement>(null);\n  const endGuardRef = useRef<HTMLDivElement>(null);\n  const lastActiveElementRef = useRef<HTMLElement | null>(null);\n\n  // classes to be set on the children wrapper\n  const classes = classNames([childrenStyles]);\n\n  /**\n   * contain focus if trap is enabled, and target is not already contained\n   *\n   * calling cases for side-effect of setting focus\n   *   - on initial mount of (enabled) trap, where target is not inside trap\n   *   - on enabling of a disabled trap, where target is not inside trap\n   *   - target of click event is outside of trap.\n   */\n  const conditionallyContainFocus = useCallback(\n    (target: HTMLElement | null) => {\n      const trap = trapRef.current;\n      //  short-circuit, if trap or target not valid\n      if (isDisabled || !trap || !target) return;\n\n      // just update ref if, target already has focus\n      if (target && hasFocus([trap, startGuardRef.current, endGuardRef.current], target)) {\n        lastActiveElementRef.current = target;\n        return;\n      }\n\n      // set focus to last active tab-stop if lastElement is defined and inside trap\n      if (lastActiveElementRef.current) {\n        focusOn(lastActiveElementRef.current);\n      } else {\n        // otherwise just contain focus within trap as target is outside enabled trap and we have no last-known tab-stop\n        focusWithin(trap);\n      }\n    },\n    [isDisabled]\n  );\n\n  // loop focus\n  const handleStartGuardOnFocus = (event: FocusEvent) => {\n    if (isDisabled || !trapRef.current) return;\n    focusOnEnd(trapRef.current);\n\n    // prevent scroll jump and bubbling this event up as a focus event\n    event.stopPropagation();\n    event.preventDefault();\n  };\n\n  const handleEndGuardOnFocus = (event: FocusEvent) => {\n    if (isDisabled || !trapRef.current) return;\n    focusOnStart(trapRef.current);\n\n    // prevent scroll jump and bubbling guard event up as a focus event\n    event.stopPropagation();\n    event.preventDefault();\n  };\n\n  const handleTrapOnFocus = (event: FocusEvent) => {\n    lastActiveElementRef.current = event.target as HTMLElement;\n  };\n\n  // handle initial render or re-render as enabled\n  useEffect(() => {\n    const trap = trapRef.current;\n    if (!trap || isDisabled) return;\n\n    const originalActiveElement = getActiveElement(trap);\n\n    // init focus\n    if (autoFocusRef && autoFocusRef.current) {\n      focusOn(autoFocusRef.current);\n    } else {\n      conditionallyContainFocus(originalActiveElement);\n    }\n\n    const restoreFocusRefForCleanup = restoreFocusRef;\n\n    return () => {\n      if (restoreFocusRefForCleanup === false) return;\n      restoreFocusAfterUnmount(restoreFocusRefForCleanup?.current || originalActiveElement);\n    };\n  }, [autoFocusRef, conditionallyContainFocus, isDisabled, restoreFocusRef]);\n\n  return (\n    <Fragment>\n      {!isDisabled && <FocusGuard onFocus={handleStartGuardOnFocus} ref={startGuardRef} />}\n      <div onFocus={handleTrapOnFocus} ref={trapRef} class={classes}>\n        {children}\n      </div>\n      {!isDisabled && <FocusGuard onFocus={handleEndGuardOnFocus} ref={endGuardRef} />}\n    </Fragment>\n  );\n};\n\n// setTimeout ensures that unmount lifecycle has completed\nconst restoreFocusAfterUnmount = (element: HTMLElement | null) => {\n  if (element && isTabbableElement(element)) {\n    setTimeout(() => {\n      focusOn(element);\n    }, 0);\n  }\n};\n\n// is focus already contained?\nconst hasFocus = (elements: (HTMLElement | null)[], target: Element) => {\n  if (elements.length === 0) return false;\n  const activeElement = target ?? getActiveElement(elements[0] as Node);\n  return elements.some((el) => el === activeElement || el?.contains(activeElement));\n};\n\n// remove margins from children\nconst childrenStyles = cssProps`${{\n  /* @ts-ignore */\n  '& > *': {\n    marginTop: '0 !important',\n    marginBottom: '0 !important',\n    marginLeft: '0 !important',\n    marginRight: '0 !important'\n  }\n}}`;\n"],"names":["styles","FocusGuard","forwardRef","onFocus","guardRef","_jsx","class","guard","ref","tabIndex","FocusTrap","autoFocusRef","children","isDisabled","restoreFocusRef","trapRef","useRef","startGuardRef","endGuardRef","lastActiveElementRef","conditionallyContainFocus","useCallback","target","trap","current","hasFocus","focusOn","handleStartGuardOnFocus","event","focusOnEnd","handleEndGuardOnFocus","focusOnStart","handleTrapOnFocus","originalActiveElement","getActiveElement","restoreFocusAfterUnmount","restoreFocusRefForCleanup","element","isTabbableElement","elements","length","childrenStyles"],"mappings":"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"}