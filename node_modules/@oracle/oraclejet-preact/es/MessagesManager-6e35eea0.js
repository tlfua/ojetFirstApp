/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx } from 'preact/jsx-runtime';
import { Fragment } from 'preact';
import { useState, useRef, useCallback, useLayoutEffect } from 'preact/hooks';
import { Transition, TransitionGroup } from './PRIVATE_TransitionGroup.js';
import './hooks/UNSAFE_useAnimation.js';
import { useMessagesContext } from './hooks/UNSAFE_useMessagesContext.js';
import { u as useAnimation } from './useAnimation-50c5f5fb.js';

const DEFAULT_ANIMATION_STATES = {};
/**
 * A intermediary component that handles animation for the messages component.
 *
 * The expected flow is as follows:
 * 1. message removed from the data
 * 2. onExiting called and a callback is passed which needs to be called to complete the transition
 * 3. state set to "exiting" in this component
 * 4. triggers useAnimation to perform the exit animation
 * 5. onAnimationEnd is called after the animation, which invokes the callback provided earlier
 * 6. onExited is called (done when the callback mentioned above is called)
 * 7. message is removed from the UI
 *
 * @param param0 Props of the message component
 */
function MessageTransition({ animationStates = DEFAULT_ANIMATION_STATES, initialAnimationStyles, onEntering, onExiting, ...transitionProps }) {
    const [state, setState] = useState('entering');
    const animationCallbackRef = useRef();
    const busyStateResolveRef = useRef();
    const { controller, nodeRef } = useAnimation(state, {
        animationStates,
        isAnimatedOnMount: true,
        onAnimationEnd: useCallback(() => {
            // resolve animation callbacks & busyStates
            animationCallbackRef.current?.();
            animationCallbackRef.current = undefined;
            busyStateResolveRef.current?.();
            busyStateResolveRef.current = undefined;
        }, [])
    });
    const { addBusyState } = useMessagesContext();
    const onEnteringCallback = useCallback((node, callback, metadata) => {
        // cancel any existing animation
        if (animationCallbackRef.current) {
            animationCallbackRef.current = undefined;
            controller.cancel();
        }
        // resolve any existing busyState
        busyStateResolveRef.current?.();
        busyStateResolveRef.current = undefined;
        onEntering?.(node, undefined, metadata);
        // start the animation and set the callback & busyState
        setState('entering');
        // if there is no animation configured, resolve immediately
        if (animationStates['entering'] === undefined &&
            animationStates['exiting => entering'] === undefined) {
            callback?.();
            return;
        }
        animationCallbackRef.current = callback;
        busyStateResolveRef.current = addBusyState?.('messages animating');
    }, [animationStates, controller, addBusyState, onEntering]);
    const onExitingCallback = useCallback((node, callback, metadata) => {
        // cancel any existing animation
        if (animationCallbackRef.current) {
            animationCallbackRef.current = undefined;
            controller.cancel();
        }
        // resolve any existing busyState
        busyStateResolveRef.current?.();
        busyStateResolveRef.current = undefined;
        onExiting?.(node, undefined, metadata);
        // start the animation and set the callback & busyState
        setState('exiting');
        // if there is no animation configured, resolve immediately
        if (animationStates['exiting'] === undefined &&
            animationStates['entering => exiting'] === undefined) {
            callback?.();
            return;
        }
        animationCallbackRef.current = callback;
        busyStateResolveRef.current = addBusyState?.('messages animating');
    }, [animationStates, controller, addBusyState, onExiting]);
    // if animation is interrupted, the busyState may be left hanging. So clear that on unmount
    // Note: When using a class-based component inside a functional component, the timings of
    // componentDidMount and useEffect might differ. So, in order to guarantee the registration
    // of the cleanup function, use useLayoutEffect instead of useEffect. This way we can make sure
    // the cleanup registers at all times.
    useLayoutEffect(() => () => busyStateResolveRef.current?.(), []);
    return (jsx("div", { ref: nodeRef, style: initialAnimationStyles, children: jsx(Transition, { ...transitionProps, onEntering: onEnteringCallback, onExiting: onExitingCallback }) }));
}

/**
 * The component that renders individual messages for the provided data.
 */
function MessagesManager({ data, animationStates, children, initialAnimationStyles, onMessageWillRemove }) {
    /**
     * Handles when a message has finished to exit.
     *
     * @param node The corresponding message element
     * @param callback A callback function to be called after the animation is complete
     */
    const handleExited = useCallback(async (node, metadata) => {
        metadata && onMessageWillRemove?.(metadata.key, metadata.index, node);
    }, [onMessageWillRemove]);
    return (jsx(TransitionGroup, { elementType: Fragment, children: data.map((item, index) => (jsx(MessageTransition, { animationStates: animationStates, initialAnimationStyles: initialAnimationStyles, metadata: { index, key: item.key }, onExited: handleExited, children: children?.({ index, item }) }, item.key))) }));
}

export { MessagesManager as M };
//# sourceMappingURL=MessagesManager-6e35eea0.js.map
