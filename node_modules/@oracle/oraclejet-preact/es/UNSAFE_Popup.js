/* @oracle/oraclejet-preact: 15.1.2 */
import { jsx } from 'preact/jsx-runtime';
import { useEffect, useState, useRef, useMemo, useCallback, useLayoutEffect } from 'preact/hooks';
import './UNSAFE_Floating.js';
import { getActiveElement, focusWithin, focusOn } from './utils/PRIVATE_tabbableUtils.js';
import { mergeRefs } from './utils/PRIVATE_refUtils.js';
import './UNSAFE_FocusTrap.js';
import { Layer } from './UNSAFE_Layer.js';
import { forwardRef } from 'preact/compat';
import { useAnimationStatus } from './hooks/PRIVATE_useAnimationStatus.js';
import { normalizePosition } from './utils/PRIVATE_floatingUtils.js';
import { useUser } from './hooks/UNSAFE_useUser.js';
import { useComponentTheme } from './hooks/UNSAFE_useComponentTheme.js';
import { popupVars } from './UNSAFE_Popup/themes/PopupContract.css.js';
import './utils/UNSAFE_stringUtils.js';
import './utils/UNSAFE_classNames.js';
import { PopupRedwoodTheme } from './UNSAFE_Popup/themes/redwood/PopupTheme.js';
import { g as getVarName } from './stringUtils-5f2d2e94.js';
import { F as Floating } from './Floating-2d909840.js';
import { c as classNames } from './classNames-f414daad.js';
import { F as FocusTrap } from './FocusTrap-9dc31155.js';
import './index-326d7a5f.js';
import './index-f26154f2.js';
import 'preact';
import './Common.js';
import './Common/themes.js';
import './Common/themes/redwood/theme.js';
import './Common/themes/themeContract.css.js';
import './hooks/UNSAFE_useOutsideClick.js';
import './utils/UNSAFE_arrayUtils.js';
import './utils/UNSAFE_logger.js';
import './_curry1-7629ff3f.js';
import './_curry2-820ed778.js';
import './utils-9a0cb8dc.js';
import './UNSAFE_Floating/themes/redwood/FloatingTheme.js';
import './UNSAFE_Floating/themes/FloatingStyles.css.js';
import './FloatingStyles.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.css.js';
import './UNSAFE_Floating/themes/redwood/FloatingBaseTheme.styles.css';
import './UNSAFE_Floating/themes/redwood/FloatingVariants.css.js';
import './vanilla-extract-recipes-createRuntimeFn.esm-3311d9ef.js';
import './vanilla-extract-dynamic.esm-33365337.js';
import './UNSAFE_Floating/themes/FloatingContract.css.js';
import './_arity-cb2c60f3.js';
import './_curry3-bb17e901.js';
import './useThemeInterpolations-48ee20a7.js';
import './hooks/UNSAFE_useColorScheme.js';
import './hooks/UNSAFE_useScale.js';
import './utils/UNSAFE_interpolations/theme.js';
import './UNSAFE_Theme.js';
import './utils/UNSAFE_mergeInterpolations.js';
import './_has-057b6f90.js';
import './hooks/UNSAFE_useAnimation.js';
import './useAnimation-50c5f5fb.js';
import './UNSAFE_Popup/themes/redwood/PopupBaseTheme.css.js';
import './UNSAFE_Popup/themes/redwood/PopupBaseTheme.styles.css';
import './UNSAFE_Popup/themes/redwood/PopupVariants.css.js';
import './PopupStyles.styles.css';


const animationStates = {
    opening: (node) => {
        const realPlacement = logicalSide(node.placement, node.direction);
        return {
            //zoomIn
            from: {
                scaleX: 0,
                scaleY: 0,
                opacity: 0,
                transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]
            },
            to: {
                scaleX: 1,
                scaleY: 1,
                opacity: 1,
                transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]
            },
            options: {
                duration: 200
            }
        };
    },
    closing: (node) => {
        const realPlacement = logicalSide(node.placement, node.direction);
        return {
            //zoomOut
            from: {
                scaleX: 1,
                scaleY: 1,
                opacity: 1,
                transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]
            },
            to: {
                scaleX: 0,
                scaleY: 0,
                opacity: 0,
                transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]
            },
            options: {
                duration: 200
            }
        };
    }
};
const _ANIMATION_TRANSFORM_ORIGIN_RULES = {
    top: 'center bottom',
    'top-right': 'right bottom',
    'top-left': 'left bottom',
    'top-right-corner': 'left bottom',
    'top-left-corner': 'right bottom',
    right: 'left center',
    'right-top': 'left top',
    'right-bottom': 'left bottom',
    'right-top-corner': 'left bottom',
    'right-bottom-corner': 'left top',
    bottom: 'center top',
    'bottom-right': 'right top',
    'bottom-left': 'left top',
    'bottom-right-corner': 'left top',
    'bottom-left-corner': 'right top',
    left: 'right center',
    'left-top': 'right top',
    'left-bottom': 'right bottom',
    'left-top-corner': 'right bottom',
    'left-bottom-corner': 'right top'
};
const logicalSide = (placement, direction) => {
    if (placement == null || direction == null)
        return 'bottom';
    const side = placement.split('-')[0];
    const alignment = placement.split('-')[1];
    const corner = placement.split('-')[2];
    const physicalSide = normalizePosition(side, direction);
    const placements = [
        'top',
        'top-right',
        'top-left',
        'top-right-corner',
        'top-left-corner',
        'right',
        'right-top',
        'right-bottom',
        'right-top-corner',
        'right-bottom-corner',
        'bottom',
        'bottom-right',
        'bottom-left',
        'bottom-right-corner',
        'bottom-left-corner',
        'left',
        'left-top',
        'left-bottom',
        'left-top-corner',
        'left-bottom-corner'
    ];
    const newPlacement = placements.filter((placement) => (alignment &&
        corner &&
        placement === `${physicalSide}-${normalizePosition(alignment, direction)}-${corner}`) ||
        (alignment &&
            !corner &&
            placement === `${physicalSide}-${normalizePosition(alignment, direction)}`) ||
        (!alignment && placement === `${physicalSide}`))[0];
    if (!newPlacement) {
        return 'bottom';
    }
    return newPlacement;
};
function usePopupAnimation(props) {
    const { isOpen, isAnimatedOnMount, onTransitionEnd, placement } = props;
    const { direction } = useUser();
    const { setAnimationElementRef, animationElementRef, status } = useAnimationStatus({
        isOpen: isOpen,
        isAnimatedOnMount: isAnimatedOnMount,
        animationStates,
        onTransitionEnd
    });
    const popupElementRef = animationElementRef;
    //This is needed for the case if popup flips and changes the placement.
    useEffect(() => {
        if (popupElementRef != null && popupElementRef.current != null && status != 'unmounted') {
            popupElementRef.current.placement = placement;
            popupElementRef.current.direction = direction;
        }
    }, [popupElementRef, placement, direction, status]);
    return { setAnimationElementRef, status };
}

/**
 * A popup temporarily 'pops up' content in the foreground.
 */
const Popup = forwardRef(({ anchorRef, children, isOpen = false, offset = { mainAxis: 0, crossAxis: 0 }, flipOptions = { mainAxis: true, crossAxis: true }, shiftOptions = { mainAxis: false, crossAxis: false }, onClose, initialFocus = 'auto', onClickOutside, placement = 'top', tail = 'none', onTransitionEnd, role = 'tooltip' }, ref) => {
    const [trapDisabled, setTrapDisabled] = useState(true);
    const launcherRef = useRef(null);
    const [popupBgColor, setPopupBgColor] = useState();
    const contentWrapperRef = useRef(null);
    //The animationPlacement is used for the case of flip.
    const [animationPlacement, setAnimationPlacement] = useState(placement);
    function launcherKeyDownCallback(event) {
        if (launcherRef.current === getActiveElement() && event.code === 'F6') {
            // Prevent default F6 handlers.
            // F6 is a standard Chrome address bar shortcut on Windows.
            event.preventDefault();
            event.stopPropagation();
            focusWithin(contentWrapperRef.current);
        }
    }
    const _onTransitionEnd = (isOpen) => {
        if (isOpen) {
            setInitialFocus();
            onTransitionEnd?.(true);
        }
        else {
            onTransitionEnd?.(false);
        }
    };
    // Animation
    const { setAnimationElementRef, status } = usePopupAnimation({
        isOpen,
        isAnimatedOnMount: true,
        onTransitionEnd: _onTransitionEnd,
        placement: animationPlacement
    });
    const stableRef = useMemo(() => mergeRefs(setAnimationElementRef, ref), [setAnimationElementRef, ref]);
    const returnFocus = () => {
        // Try to return focus to 1.launcher or 2.anchor
        const launcherEl = launcherRef.current;
        const anchorEl = anchorRef.current;
        if (launcherEl) {
            focusOn(launcherEl);
            // Checking instanceof to avoid Coords type that can not be focused
        }
        else if (anchorEl && anchorEl instanceof Element) {
            focusOn(anchorEl);
        }
    };
    useEffect(() => {
        // Init closing
        if (!isOpen && status === 'opening') {
            // Only actively return focus to the launcher or anchor if the popup contained focus.
            // Otherwise, focus is already elsewhere on the page and should not be forced back
            // because that could reopen the popup again, which essentially prevents the user from
            // moving focus out of the launcher.
            if (contentWrapperRef.current?.contains(getActiveElement())) {
                returnFocus();
            }
        }
    }, [isOpen, status]);
    // Launcher handler
    useEffect(() => {
        if (isOpen && anchorRef.current instanceof Element) {
            // Remember launcher
            if (getActiveElement() === document.body) {
                launcherRef.current = anchorRef.current;
            }
            else {
                launcherRef.current = getActiveElement();
            }
            // Register F6 key handler to enter the Popup
            launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);
        }
        return () => {
            // Deregister F6 key handler
            launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);
        };
    }, [isOpen]);
    const setInitialFocus = () => {
        let derivedInitialFocus = initialFocus;
        if (initialFocus === 'auto') {
            // Modeless mode - do not steal focus by default
            derivedInitialFocus = 'none';
        }
        // Case: 'popup'
        // Focus on Popup container
        if (derivedInitialFocus === 'popup') {
            focusOn(contentWrapperRef.current);
        }
        // Case: 'firstFocusable'
        // Focus on first tabbable in the Popup container or container itself if there is none
        if (derivedInitialFocus === 'firstFocusable') {
            focusWithin(contentWrapperRef.current);
        }
    };
    const getMainAxisOffset = (offset) => {
        let calcOffset = 0;
        if (offset) {
            // @ts-ignore as OffsetFunction is going to be removed
            // Property 'mainAxis' does not exist on type 'OffsetFunction'.
            calcOffset = typeof offset === 'number' ? offset : offset.mainAxis || 0;
            if (tail === 'simple') {
                calcOffset += 5;
            }
        }
        return calcOffset;
    };
    const getCrossAxisOffset = (offset) => {
        if (!offset) {
            return 0;
        }
        else {
            // @ts-ignore as OffsetFunction is going to be removed
            // Property 'crossAxis' does not exist on type 'OffsetFunction'.
            return typeof offset === 'number' ? 0 : offset.crossAxis || 0;
        }
    };
    const finalOffset = {
        mainAxis: getMainAxisOffset(offset),
        crossAxis: getCrossAxisOffset(offset)
    };
    // Preact FocusEvent mapping
    // onFocus - focusin
    // onBlur - focusout
    //
    // https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/relatedTarget
    // Event name   target                           relatedTarget
    // blur         The EventTarget losing focus     The EventTarget receiving focus (if any).
    // focus        The EventTarget receiving focus  The EventTarget losing focus (if any)
    // focusin      The EventTarget receiving focus  The EventTarget losing focus (if any)
    // focusout     The EventTarget losing focus     The EventTarget receiving focus (if any)
    const handleOnFocus = (event) => {
        // Executing this listener means that element receiving focus lives within Popup.
        // We are checking which element is loosing focus to avoid activating FocusTrap when focus
        // travels among elements within FocusTrap.
        // To enable FocusTrap the element that looses focus must live out of the Popup or is Popup's container.
        if (!contentWrapperRef.current?.contains(event.relatedTarget) ||
            event.relatedTarget === contentWrapperRef.current) {
            // Do not activate focusTrap if the event.target is Popup itself - if we clicked on Popup's container
            // We should be able to focus Popup container without activating FocusTrap
            if (event.target != contentWrapperRef.current) {
                // Enable FocusTrap.
                setTrapDisabled(false);
            }
        }
    };
    const handleOnBlur = (event) => {
        // Executing this listener means that an element living within Popup is loosing focus.
        // We are checking which element is receiving focus to avoid disabling FocusTrap when focs
        // travels among elements within FocusTrap.
        // To disable FocusTrap element the element that receives focus must live out of the Popup or is Popup's container.
        if (!contentWrapperRef.current?.contains(event.relatedTarget) ||
            event.relatedTarget === contentWrapperRef.current) {
            // Disable FocusTrap.
            setTrapDisabled(true);
        }
    };
    const handlePopupKeyDown = (event) => {
        const currentlyFocusedEl = getActiveElement();
        const wrapperEl = contentWrapperRef.current;
        const launcherEl = launcherRef.current;
        if (wrapperEl === currentlyFocusedEl || wrapperEl?.contains(currentlyFocusedEl)) {
            switch (event.code) {
                case 'Escape': {
                    onClose?.(event);
                    break;
                }
                case 'F6':
                    // Prevent default F6 handlers.
                    // F6 is a standard Chrome address bar shortcut on Windows.
                    event.preventDefault();
                    event.stopPropagation();
                    // Focus launcher
                    if (launcherEl) {
                        focusOn(launcherEl);
                    }
                    // Disable FocusTrap
                    setTrapDisabled(true);
                    break;
                case 'Tab':
                    // If tabbing out of the popup when the popup itself has focus and the focus trap is
                    // disabled, transfer focus back to the launcher.  Don't let the browser then
                    // transfer focus itself from there like it normally would.
                    if (event.target === contentWrapperRef.current && trapDisabled) {
                        // Focus launcher
                        if (launcherEl) {
                            focusOn(launcherEl);
                            // Prevent the browser from transferring focus itself.
                            event.preventDefault();
                        }
                    }
                    break;
            }
        }
    };
    const onPosition = useCallback((data) => {
        if (placement !== data.placement) {
            //if flips happens we need to change the placement in the animations.
            setAnimationPlacement(data.placement);
        }
    }, [setAnimationPlacement, placement]);
    useLayoutEffect(() => {
        if (status === 'unmounted' ||
            contentWrapperRef.current == null ||
            popupBgColor != null ||
            tail === 'none')
            return;
        const backgroundColorVar = getVarName(popupVars.backgroundColor);
        const computedStyle = getComputedStyle(contentWrapperRef.current);
        setPopupBgColor(computedStyle.getPropertyValue(backgroundColorVar));
    }, [status, contentWrapperRef, popupBgColor, tail]);
    // Styles
    const { baseTheme, classes } = useComponentTheme(PopupRedwoodTheme);
    const isMounted = status !== 'unmounted';
    return (isMounted && (jsx(Layer, { children: jsx(Floating, { ref: stableRef, backgroundColor: popupBgColor, anchorRef: anchorRef, placement: placement, offsetValue: finalOffset, flipOptions: flipOptions, shiftOptions: shiftOptions, onClickOutside: onClickOutside, tail: tail, onPosition: onPosition, children: jsx("div", { ref: contentWrapperRef, tabIndex: -1, role: role, className: classNames([baseTheme, classes]), onFocus: handleOnFocus, onBlur: handleOnBlur, onKeyDown: handlePopupKeyDown, children: jsx(FocusTrap, { isDisabled: trapDisabled, restoreFocusRef: false, children: children }) }) }) })));
});

export { Popup };
//# sourceMappingURL=UNSAFE_Popup.js.map
