"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OjDataGrid = void 0;
const selenium_webdriver_1 = require("selenium-webdriver");
const OjDataGridBase_1 = require("./OjDataGridBase");
const __1 = require("../../");
/**
 * The component WebElement for [oj-data-grid](../../jsdocs/oj.ojDataGrid.html).
 * Do not instantiate this class directly, instead, use
 * [ojDataGrid](../modules/elements.html#ojDataGrid).
 */
class OjDataGrid extends OjDataGridBase_1.OjDataGridBase {
    // Put overrides here
    /**
     * This method exists to get content that is intended to interact with. This is not a method to verify data or that template rendering is correct.
     * For those cases unit test the data, template, style function etc.
     *
     * @param {cellSubId} subId information about the cell to get contents of
     * @param {By} by The lookup to pass into findElements
     * @returns {Promise<Array.<WebElement>|null>} If no cell is found matching the id, returns null.
     *          Otherwise: On Zero Match return an empty list. On One Match returns list of one WebElement only. On One+ Match returns list with all matching instance.
     *          If cell renderer/template/slot is not specified the promise will be rejected with an error message.
     * @ojdeprecated {since:"10.0.0", description:"This api is deprecated. Please use findCell"}
     */
    async getCellContents(itemLocator) {
        let datagridCell = null;
        let key = itemLocator.key;
        let rowIndex = key.rowIndex;
        let columnIndex = key.columnIndex;
        let rowKey = key.rowKey;
        let columnKey = key.columnKey;
        let cellMatch = null;
        let cells = await this.findElements(selenium_webdriver_1.By.css('.oj-datagrid-cell'));
        for (let i = 0; i < cells.length; i++) {
            let cell = cells[i];
            cellMatch = await this.getDriver().executeScript([
                'var cellContext = arguments[0]["data-oj-cellContext"];',
                'var cellRowIndex  = cellContext.indexes.row;',
                'var cellColumnIndex  = cellContext.indexes.column;',
                'var cellRowKey  = cellContext.keys.row;',
                'var cellColumnKey = cellContext.keys.column;',
                'if ((cellRowIndex === arguments[1] || cellRowKey === arguments[3]) &&',
                '(cellColumnIndex === arguments[2] || cellColumnKey === arguments[4])) {',
                '  return true;',
                '}',
                'return false;'
            ].join('\n'), cell, rowIndex, columnIndex, rowKey, columnKey);
            if (cellMatch) {
                datagridCell = cell;
            }
        }
        return datagridCell;
    }
    async findCell(itemLocator) {
        let rowIndex = itemLocator.rowIndex;
        let columnIndex = itemLocator.columnIndex;
        let rowKey = itemLocator.rowKey;
        let columnKey = itemLocator.columnKey;
        let datagridCell = null;
        await this.whenBusyContextReady();
        datagridCell = await this.getDriver().executeAsyncScript(`
      var element = arguments[0];
      var rowIndex = arguments[1];
      var columnIndex = arguments[2];
      var rowKey = arguments[3];
      var columnKey = arguments[4];
      var done = arguments[5];
      require([\'ojs/ojcore\'], function(oj) { 
        const cells = element.querySelectorAll('.oj-datagrid-cell');
        let cell;
        for (let i = 0; i < cells.length; i++) {
          var cellContext = cells[i]["data-oj-cellContext"];
          var cellRowIndex  = cellContext.indexes.row;
          var cellColumnIndex  = cellContext.indexes.column;
          var cellRowKey  = cellContext.keys.row;
          var cellColumnKey = cellContext.keys.column;
          if ((cellRowIndex === rowIndex || cellRowKey === rowKey) &&
          (cellColumnIndex === columnIndex || cellColumnKey === columnKey)) {
            cell = cells[i];
          }
        }
        done(cell);
      })`, this, rowIndex, columnIndex, rowKey, columnKey);
        if (datagridCell) {
            return (0, __1.slotProxy)(datagridCell, this);
        }
        else {
            throw Error(`No corresponding cell found for the itemLocator`);
        }
    }
    /**
     * This method exists to get content that is intended to interact with. This is not a method to verify data or that template rendering is correct.
     * For those cases unit test the data, template, style function etc.
     *
     * @param {headerSubId} subId information about the header to get contents of, if level not specified will default to 0
     * @param {By} by The lookup to pass into findElements
     * @returns {Promise<Array.<WebElement>|null>} If no header is found matching the id, returns null.
     *          Otherwise: On Zero Match return an empty list. On One Match returns list of one WebElement only. On One+ Match returns list with all matching instance.
     *          If header renderer/template/slot is not specified the promise will be rejected with an error message.
     * @ojdeprecated {since:"10.0.0", description:"This api is deprecated. Please use findHeader"}
     */
    async getHeaderContents(subId, by) {
        await this.whenReady();
        let axis = subId.axis;
        let key = subId.key;
        let index = subId.index;
        let level = subId.level != null ? subId.level : 0;
        let headerProperty = await this.getHeader();
        // getProperty should change all members that are functions to string representation not null
        if (headerProperty[axis].renderer === null) {
            return Promise.reject(new Error('No renderer to inspect content of, please see the method documentation.'));
        }
        let headerMatch = null;
        let header = null;
        let headers = await this.findElements(selenium_webdriver_1.By.css('.oj-datagrid-' + axis.replace('End', '-end') + '-header-cell'));
        for (let i = 0; i < headers.length; i++) {
            header = headers[i];
            headerMatch = await this.getDriver().executeScript([
                'var headerContext = arguments[0]["data-oj-cellContext"];',
                'var headerIndex = headerContext.index;',
                'var headerKey = headerContext.key;',
                'var headerLevel = headerContext.level;',
                'if (headerKey === arguments[1] || ',
                '(headerIndex === arguments[2] && headerLevel === arguments[3])) {',
                '  return true;',
                '}',
                'return false;'
            ].join('\n'), header, key, index, level);
            if (headerMatch) {
                return header.findElements(by);
            }
        }
        return null;
    }
    async findHeader(itemLocator) {
        await this.whenReady();
        let axis = itemLocator.axis;
        let key = itemLocator.key;
        let index = itemLocator.index;
        let level = itemLocator.level != null ? itemLocator.level : 0;
        let header = null;
        header = await this.getDriver().executeAsyncScript(`
      var element = arguments[0];
      var axis = arguments[1];
      var key = arguments[2];
      var index = arguments[3];
      var level = arguments[4];
      var done = arguments[5];
      require([\'ojs/ojcore\'], function(oj) {
        const headers = element.querySelectorAll('.oj-datagrid-' + axis.replace('End', '-end') + '-header-cell');
        let header;
        for (let i = 0; i < headers.length; i++) {
          var headerContext = headers[i]["data-oj-cellContext"];
          var headerIndex = headerContext.index;
          var headerKey = headerContext.key;
          var headerLevel = headerContext.level;
          if (headerKey === key || (headerIndex === index && headerLevel === level)) {
            header = headers[i];
          }
        } 
        done(header);
      })`, this, axis, key, index, level);
        if (header) {
            return (0, __1.slotProxy)(header, this);
        }
        else {
            throw Error(`No corresponding header found for the itemLocator`);
        }
    }
    /**
     * This method exists to get content that is intended to interact with. This is not a method to verify data or that template rendering is correct.
     * For those cases unit test the data, template, style function etc.
     *
     * @param {labelSubId} subId information about the label to get contents of, if level not specified will default to 0
     * @param {By} by The lookup to pass into findElements
     * @returns {Promise<Array.<WebElement>|null>} If no label is found matching the id, returns null.
     *          Otherwise: On Zero Match return an empty list. On One Match returns list of one WebElement only. On One+ Match returns list with all matching instance.
     *          If label renderer/template/slot is not specified the promise will be rejected with an error message.
     * @ojdeprecated {since:"10.0.0", description:"This api is deprecated. Please use findLabel"}
     */
    async getLabelContents(subId, by) {
        await this.whenReady();
        let axis = subId.axis;
        let level = subId.level != null ? subId.level : 0;
        let headerProperty = await this.getHeader();
        // getProperty should change all members that are functions to string representation not null
        if (headerProperty[axis].label.renderer === null) {
            return Promise.reject(new Error('No renderer to inspect content of, please see the method documentation.'));
        }
        let labelMatch = null;
        let label = null;
        let labels = await this.findElements(selenium_webdriver_1.By.css('.oj-datagrid-' + axis.replace('End', '-end') + '-label'));
        for (let i = 0; i < labels.length; i++) {
            label = labels[i];
            labelMatch = await this.getDriver().executeScript([
                'var labelContext = arguments[0]["data-oj-cellContext"];',
                'var labelLevel = labelContext.level;',
                'if (labelLevel === arguments[1]) {',
                '  return true;',
                '}',
                'return false;'
            ].join('\n'), label, level);
            if (labelMatch) {
                return label.findElements(by);
            }
        }
        return null;
    }
    async findLabel(itemLocator) {
        await this.whenReady();
        let axis = itemLocator.axis;
        let level = itemLocator.level != null ? itemLocator.level : 0;
        let headerLabel = null;
        headerLabel = await this.getDriver().executeAsyncScript(`
      var element = arguments[0];
      var axis = arguments[1];
      var level = arguments[2];
      var done = arguments[3];
      require([\'ojs/ojcore\'], function(oj) {
        let labels = element.querySelectorAll('.oj-datagrid-' + axis.replace('End', '-end') + '-label');
        let label;
        for (let i = 0; i < labels.length; i++) {  
          var labelContext = labels[i]["data-oj-cellContext"];
          var labelLevel = labelContext.level;
          if (labelLevel === level) {
            label = labels[i];
          }
        }
        done(label);
      })`, this, axis, level);
        if (headerLabel) {
            return (0, __1.slotProxy)(headerLabel, this);
        }
        else {
            throw Error(`No corresponding headerlabel found for the itemLocator`);
        }
    }
}
exports.OjDataGrid = OjDataGrid;
//# sourceMappingURL=OjDataGrid.js.map