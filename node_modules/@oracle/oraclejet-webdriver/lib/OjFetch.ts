import { WebDriver } from 'selenium-webdriver';

/**
 * The ClientFetch call interface
 */
export interface ClientFetch {
  fetch(
    driver: WebDriver,
    requestInfo: MarshalableRequestInfo,
    responseInfo: MarshalableResponseInfo,
    init?: MarshalableRequestInit
  ): Promise<MarshaledResponse>;
}

export type BodyAs = 'json' | 'text';

export interface MarshalableBodyAsJSON {
  kind: 'json';
  body: any;
}

export interface MarshalableBodyAsText {
  kind: 'text';
  body: string;
}

export type MarshalableBody = MarshalableBodyAsJSON | MarshalableBodyAsText;

export type MarshalableHeaders = Record<string, string>;

export interface MarshalableResponseInfo {
  responseBodyAs: BodyAs;
}

export type MarshalableRequestInfo = string;

// types from lib.dom that we can inline if we have to
// type RequestCache = "default" | "no-store" | "reload" | "no-cache" | "force-cache" | "only-if-cached";
// type RequestCredentials = "omit" | "same-origin" | "include";
// type RequestMode = "navigate" | "same-origin" | "no-cors" | "cors";
// type RequestRedirect = "follow" | "error" | "manual";
// type ReferrerPolicy = "" | "no-referrer" | "no-referrer-when-downgrade" | "same-origin" | "origin" | "strict-origin" | "origin-when-cross-origin" | "strict-origin-when-cross-origin" | "unsafe-url";
// All we got rid of completely are the abortSignal (which doesn't make senses) and window (which can only be set to null for now anyway)
/**
 * An interface used to describe the Request for
 * a browser fetch call.  The headers and json fields are json objects.
 */
export interface MarshalableRequestInit {
  body?: MarshalableBody | null;
  cache?: RequestCache;
  credentials?: RequestCredentials;
  headers?: MarshalableHeaders;
  integrity?: string;
  keepalive?: boolean;
  method?: string; // it would have been nicer if this was defined with the known methods | string
  mode?: RequestMode;
  redirect?: RequestRedirect;
  referrer?: string;
  referrerPolicy?: ReferrerPolicy;
}

// type ResponseType = "basic" | "cors" | "default" | "error" | "opaque" | "opaqueredirect";
/**
 * An interface used to describe the summary results of a Response object from
 * a browser fetch call.  The headers and json fields are json objects.
 */
export interface MarshaledResponse {
  readonly body: Readonly<MarshalableBody>;
  readonly headers: Readonly<MarshalableHeaders>;
  readonly ok: boolean;
  readonly redirected: boolean;
  readonly status: number;
  readonly statusText: string;
  readonly type: ResponseType;
  readonly url: string;
}

// An internal structure for what is returned by the async call

interface AsyncResponse {
  readonly mbody: Readonly<MarshalableBody>;
  readonly marshalableHeaders: Readonly<MarshalableHeaders>;
  readonly ok: boolean;
  readonly redirected: boolean;
  readonly status: number;
  readonly statusText: string;
  readonly type: ResponseType;
  readonly url: string;
  readonly error: string;
}

export class OjFetch implements ClientFetch {
  async fetch(
    driver: WebDriver,
    requestInfo: MarshalableRequestInfo,
    responseInfo: MarshalableResponseInfo,
    init?: MarshalableRequestInit
  ): Promise<MarshaledResponse> {
    // webdriver's async call marshalls objects on callback, so we have to unmarshall back into promise
    // We need to retrieve the body and headers during remote call, to use for recreation.
    let retResults: Promise<MarshaledResponse>;
    const rInfo = JSON.stringify(requestInfo, null, 2);
    const remoteScript = `var input=arguments[0], info=arguments[1], init=arguments[2],  callback = arguments[arguments.length - 1], resp = {};
      fetch(input,init)
         .then(function(response) { 
          resp.ok = response.ok;
          resp.redirected = response.redirected;
          resp.status = response.status;
          resp.statusText = response.statusText;
          resp.type = response.type;
          resp.url = response.url;

           resp.marshalableHeaders = {};          
           response.headers.forEach(function(val, key) {
              resp.marshalableHeaders[key] = val; 
           });         
           if(info.responseBodyAs == "json") {
             response.json().
             then(function(json) {  resp.mbody = { "kind":"json", "body": json}; callback(resp);})
             .catch(function(error) { resp.error = "Fetch error on json(): " + error; callback(resp); });
           } else {
             response.text().then(function(text) { resp.mbody = { "kind":"text", "body": text}; callback(resp);})
             .catch(function(error) { resp.error = "Fetch error on text(): " + error; callback(resp);});
           }                                      
         })
         .catch(function(error) {         
          resp.error = "Fetch threw an exception: " + error;
          callback(resp);
          })`;

    try {
      // the browser fetch api RequestInit varies from the MarshalableRequestInit so we must convert.
      let fetchInit: any;
      if (init) {
        fetchInit = init;
        if (init.body) {
          fetchInit.body = init.body.body;
        }
      }
      let resp: AsyncResponse = (await driver.executeAsyncScript(
        remoteScript,
        requestInfo,
        responseInfo,
        fetchInit
      )) as AsyncResponse;
      // console.log("resp = " + JSON.stringify(resp,null,2));
      let myResponse: MarshaledResponse = {
        body: resp.mbody,
        headers: resp.marshalableHeaders,
        ok: resp.ok,
        redirected: resp.redirected,
        status: resp.status,
        statusText: resp.statusText,
        type: resp.type,
        url: resp.url
      };
      // console.log("myResponse = " + JSON.stringify(myResponse,null,2));
      if (resp.error) {
        return Promise.reject(
          'Response encountered error: ' +
            resp.error +
            '(requestInfo = ' +
            rInfo +
            ', response = ' +
            JSON.stringify(resp, null, 2) +
            ' status = ' +
            resp.status +
            ')'
        );
      }
      retResults = Promise.resolve(myResponse);
    } catch (err) {
      retResults = Promise.reject(
        'Unable to read Response: ' + err + '(requestInfo = ' + rInfo + ')'
      );
    }

    return retResults;
  }
}
