"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Expectation = void 0;
/**
 * The class can be used to build ChaiJS BDD style assertions that can be
 * asserted against a running application from a WebDriverJS test. It supports
 * a subset of assertions specified in the following documentation:
 * {@link https://www.chaijs.com/api/bdd/}.
 *
 * The following assertions are currently not supported:
 *   instanceof, throw, respondTo, satisfy, itself, change, increase, decrease, by
 *
 */
class Expectation {
    /**
     * Create an Expectation to be evaluated on the client against the underlying
     * data model.
     * @param expression An expression statement to be evaluated for this Expectation
     * against the underlying viewmodel/page var
     */
    constructor(expression) {
        this.assertion = {
            expression,
            chain: []
        };
    }
    chainGetter(name) {
        this.assertion.chain.push(name);
        return this;
    }
    chainFunction(name, ...args) {
        this.assertion.chain.push({
            name,
            args
        });
        return this;
    }
    get to() {
        return this.chainGetter('to');
    }
    get be() {
        return this.chainGetter('be');
    }
    get been() {
        return this.chainGetter('been');
    }
    get is() {
        return this.chainGetter('is');
    }
    get that() {
        return this.chainGetter('that');
    }
    get which() {
        return this.chainGetter('which');
    }
    get and() {
        return this.chainGetter('and');
    }
    get has() {
        return this.chainGetter('has');
    }
    get have() {
        return this.chainGetter('have');
    }
    get with() {
        return this.chainGetter('with');
    }
    get at() {
        return this.chainGetter('at');
    }
    get of() {
        return this.chainGetter('of');
    }
    get same() {
        return this.chainGetter('same');
    }
    get but() {
        return this.chainGetter('but');
    }
    get does() {
        return this.chainGetter('does');
    }
    get still() {
        return this.chainGetter('still');
    }
    get not() {
        return this.chainGetter('not');
    }
    get deep() {
        return this.chainGetter('deep');
    }
    get nested() {
        return this.chainGetter('nested');
    }
    get own() {
        return this.chainGetter('own');
    }
    get ordered() {
        return this.chainGetter('ordered');
    }
    get any() {
        return this.chainGetter('any');
    }
    get all() {
        return this.chainGetter('all');
    }
    get ok() {
        return this.chainGetter('ok');
    }
    get true() {
        return this.chainGetter('true');
    }
    get false() {
        return this.chainGetter('false');
    }
    get null() {
        return this.chainGetter('null');
    }
    get undefined() {
        return this.chainGetter('undefined');
    }
    get NaN() {
        return this.chainGetter('NaN');
    }
    get exist() {
        return this.chainGetter('exist');
    }
    get empty() {
        return this.chainGetter('empty');
    }
    get arguments() {
        return this.chainGetter('arguments');
    }
    get extensible() {
        return this.chainGetter('extensible');
    }
    get sealed() {
        return this.chainGetter('sealed');
    }
    get frozen() {
        return this.chainGetter('frozen');
    }
    get finite() {
        return this.chainGetter('finite');
    }
    a(type, msg) {
        return this.chainFunction('a', type, msg);
    }
    include(val, msg) {
        return this.chainFunction('include', val, msg);
    }
    equal(val, msg) {
        return this.chainFunction('equal', val, msg);
    }
    eql(obj, msg) {
        return this.chainFunction('eql', obj, msg);
    }
    above(n, msg) {
        return this.chainFunction('above', n, msg);
    }
    least(n, msg) {
        return this.chainFunction('least', n, msg);
    }
    below(n, msg) {
        return this.chainFunction('below', n, msg);
    }
    most(n, msg) {
        return this.chainFunction('most', n, msg);
    }
    within(start, finish, msg) {
        return this.chainFunction('within', start, finish, msg);
    }
    property(name, val, msg) {
        return this.chainFunction('property', name, val, msg);
    }
    ownPropertyDescriptor(name, descriptor, msg) {
        return this.chainFunction('ownPropertyDescriptor', name, descriptor, msg);
    }
    lengthOf(n, msg) {
        return this.chainFunction('lengthOf', n, msg);
    }
    match(re, msg) {
        // can't json stringify regex so store the source string representation so we can
        // recreate the regex on the client
        return this.chainFunction('match', re.source, msg);
    }
    string(str, msg) {
        return this.chainFunction('string', str, msg);
    }
    keys(...keys) {
        return this.chainFunction('keys', ...keys);
    }
    closeTo(expected, delta, msg) {
        return this.chainFunction('closeTo', expected, delta, msg);
    }
    members(set, msg) {
        return this.chainFunction('members', set, msg);
    }
    oneOf(list, msg) {
        return this.chainFunction('oneOf', list, msg);
    }
    fail(...args) {
        return this.chainFunction('fail', ...args);
    }
}
exports.Expectation = Expectation;
//# sourceMappingURL=Expectation.js.map