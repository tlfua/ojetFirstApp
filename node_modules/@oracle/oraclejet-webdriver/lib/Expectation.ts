/**
 * The class can be used to build ChaiJS BDD style assertions that can be
 * asserted against a running application from a WebDriverJS test. It supports
 * a subset of assertions specified in the following documentation:
 * {@link https://www.chaijs.com/api/bdd/}.
 *
 * The following assertions are currently not supported:
 *   instanceof, throw, respondTo, satisfy, itself, change, increase, decrease, by
 *
 */
class Expectation<T = any> {
  assertion: {
    expression: string;
    chain: any[];
  };

  /**
   * Create an Expectation to be evaluated on the client against the underlying
   * data model.
   * @param expression An expression statement to be evaluated for this Expectation
   * against the underlying viewmodel/page var
   */
  constructor(expression: string) {
    this.assertion = {
      expression,
      chain: []
    };
  }

  chainGetter(name: string): Expectation<T> {
    this.assertion.chain.push(name);
    return this;
  }

  chainFunction(name: string, ...args: any[]): Expectation<T> {
    this.assertion.chain.push({
      name,
      args
    });
    return this;
  }

  get to(): Expectation<T> {
    return this.chainGetter('to');
  }

  get be(): Expectation<T> {
    return this.chainGetter('be');
  }

  get been(): Expectation<T> {
    return this.chainGetter('been');
  }

  get is(): Expectation<T> {
    return this.chainGetter('is');
  }

  get that(): Expectation<T> {
    return this.chainGetter('that');
  }

  get which(): Expectation<T> {
    return this.chainGetter('which');
  }

  get and(): Expectation<T> {
    return this.chainGetter('and');
  }

  get has(): Expectation<T> {
    return this.chainGetter('has');
  }

  get have(): Expectation<T> {
    return this.chainGetter('have');
  }

  get with(): Expectation<T> {
    return this.chainGetter('with');
  }

  get at(): Expectation<T> {
    return this.chainGetter('at');
  }

  get of(): Expectation<T> {
    return this.chainGetter('of');
  }

  get same(): Expectation<T> {
    return this.chainGetter('same');
  }

  get but(): Expectation<T> {
    return this.chainGetter('but');
  }

  get does(): Expectation<T> {
    return this.chainGetter('does');
  }

  get still(): Expectation<T> {
    return this.chainGetter('still');
  }

  get not(): Expectation<T> {
    return this.chainGetter('not');
  }

  get deep(): Expectation<T> {
    return this.chainGetter('deep');
  }

  get nested(): Expectation<T> {
    return this.chainGetter('nested');
  }

  get own(): Expectation<T> {
    return this.chainGetter('own');
  }

  get ordered(): Expectation<T> {
    return this.chainGetter('ordered');
  }

  get any(): Expectation<T> {
    return this.chainGetter('any');
  }

  get all(): Expectation<T> {
    return this.chainGetter('all');
  }

  get ok(): Expectation<T> {
    return this.chainGetter('ok');
  }

  get true(): Expectation<T> {
    return this.chainGetter('true');
  }

  get false(): Expectation<T> {
    return this.chainGetter('false');
  }

  get null(): Expectation<T> {
    return this.chainGetter('null');
  }

  get undefined(): Expectation<T> {
    return this.chainGetter('undefined');
  }

  get NaN(): Expectation<T> {
    return this.chainGetter('NaN');
  }

  get exist(): Expectation<T> {
    return this.chainGetter('exist');
  }

  get empty(): Expectation<T> {
    return this.chainGetter('empty');
  }

  get arguments(): Expectation<T> {
    return this.chainGetter('arguments');
  }

  get extensible(): Expectation<T> {
    return this.chainGetter('extensible');
  }

  get sealed(): Expectation<T> {
    return this.chainGetter('sealed');
  }

  get frozen(): Expectation<T> {
    return this.chainGetter('frozen');
  }

  get finite(): Expectation<T> {
    return this.chainGetter('finite');
  }

  a(type: string, msg?: string): Expectation<T> {
    return this.chainFunction('a', type, msg);
  }

  include(val: any, msg?: string): Expectation<T> {
    return this.chainFunction('include', val, msg);
  }

  equal(val: any, msg?: string): Expectation<T> {
    return this.chainFunction('equal', val, msg);
  }

  eql(obj: object, msg?: string): Expectation<T> {
    return this.chainFunction('eql', obj, msg);
  }

  above(n: number, msg?: string): Expectation<T> {
    return this.chainFunction('above', n, msg);
  }

  least(n: number, msg?: string): Expectation<T> {
    return this.chainFunction('least', n, msg);
  }

  below(n: number, msg?: string): Expectation<T> {
    return this.chainFunction('below', n, msg);
  }

  most(n: number, msg?: string): Expectation<T> {
    return this.chainFunction('most', n, msg);
  }

  within(start: number, finish: number, msg?: string): Expectation<T> {
    return this.chainFunction('within', start, finish, msg);
  }

  property(name: string, val?: any, msg?: string): Expectation<T> {
    return this.chainFunction('property', name, val, msg);
  }

  ownPropertyDescriptor(name: string, descriptor?: object, msg?: string) {
    return this.chainFunction('ownPropertyDescriptor', name, descriptor, msg);
  }

  lengthOf(n: number, msg?: string): Expectation<T> {
    return this.chainFunction('lengthOf', n, msg);
  }

  match(re: RegExp, msg?: string): Expectation<T> {
    // can't json stringify regex so store the source string representation so we can
    // recreate the regex on the client
    return this.chainFunction('match', re.source, msg);
  }

  string(str: string, msg?: string): Expectation<T> {
    return this.chainFunction('string', str, msg);
  }

  keys(...keys: Array<string | object | Array<string>>): Expectation<T> {
    return this.chainFunction('keys', ...keys);
  }

  closeTo(expected: number, delta: number, msg?: string): Expectation<T> {
    return this.chainFunction('closeTo', expected, delta, msg);
  }

  members(set: any[], msg?: string): Expectation<T> {
    return this.chainFunction('members', set, msg);
  }

  oneOf(list: any[], msg?: string): Expectation<T> {
    return this.chainFunction('oneOf', list, msg);
  }

  fail(...args: any[]): Expectation<T> {
    return this.chainFunction('fail', ...args);
  }
}

export { Expectation };
