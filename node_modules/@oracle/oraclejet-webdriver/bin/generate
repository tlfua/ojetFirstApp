#!/usr/bin/env node

/**
 * Generate a component WebElement package from its metadata descriptor
 */

'use strict';

const fs = require('fs');
const path = require('path');

// Map known types to an output type. Used by getSanitizedType() to ensure that
// component types can be mapped to valid TypeScript types.
const KNOWN_TYPES = {
  // Known good types
  boolean: 'boolean',
  null: 'null',
  number: 'number',
  object: 'object',
  string: 'string',
  tuple: 'tuple',
  undefined: 'undefined',
  void: 'void',
  any: 'any',
  // Known bad types. Convert to valid types
  function: 'null',
  promise: 'null',
  array: 'Array<unknown>'
};
// Map of reserved property names. Used to ensure that a superclass's mutator
// isn't overridden by one generated from properties.
const RESERVED_PROPS = {
  metadata: 'metadataProperty',
  size: 'sizeProperty',
  text: 'textProperty'
};

let args = [...process.argv];
// Read CLI args
const templatesArgRegex = /^--templates=/;
let customTemplates = args.find((arg) => arg.match(templatesArgRegex));
if (customTemplates) {
  customTemplates = customTemplates.split(/=/)[1];
}
args = args.filter((arg) => !arg.match(templatesArgRegex));

const noSamples = args.some((arg) => arg === '--no-samples');
args = args.filter((arg) => arg !== '--no-samples');

const withGetters = !args.some((arg) => arg === '--no-prop-getters');
args = args.filter((arg) => arg !== '--no-prop-getters');

const verboseNames = args.some((arg) => arg === '--verbose-names');
args = args.filter((arg) => arg !== '--verbose-names');

const node = args.shift();
const cmd = args.shift();
const mdPath = args.shift();
let pkgDir = args.shift() || '.';

const defaultTemplates = path.join(path.dirname(cmd), 'templates');

if (!mdPath) {
  console.log(`Usage: ${path.basename(
    cmd
  )} [--templates=<dir>] [--no-samples] [--no-prop-getters] [--verbose-names] <metadata|-> [<output dir>]
<metadata>
  a file path to component metadata (component.json)
  "-" read metadata from stdin
--templates A directory path containing override templates to be used during generation.
  The default templates are found in ${path.dirname(cmd)}/templates. If --templates
  is specified, any files in the given directory matching the default ones will
  be used. Not all template files must exist in the given directory--only the ones
  that should override the defaults.
--no-samples Do not produce the sample files package.json, tsocnfig.json, or element-test.spec.ts
--no-prop-getters Do not produce property getters. If a property supports writeback,
  it will only receive a changeProp method. Note that if a component does not
  have any writeback properties, using this switch will not generate any output.
--verbose-names Use verbose names in the WebElement locator function and class names,
  i.e., 'findInputText' instead of 'inputText'
        'InputTextWebElement' instead of 'InputText'
        'InputTextWebElementBase' instead of 'InputTextBase'
`);
  return;
}

// Main function, executed as async IIFE so that we can await on getMetadata()
(async function () {
  const mdContents = await getMetadata(mdPath);
  const md = JSON.parse(mdContents);
  const packName = md.pack;
  const name = md.name;
  const fullName = packName ? `${packName}-${name}` : name;
  const version = md.version || '0.0.1';
  let className = titleCase(name);
  const shortClassName = className;
  let camelName = camelCase(name);
  const shortCamelName = camelName;
  const properties = md.properties;
  const hasEvents = Object.keys(md.events || {}).length;

  if (verboseNames) {
    className = `${className}WebElement`;
    camelName = `find${titleCase(camelName)}`;
  }

  if (md.type === 'pack') {
    console.log(`Pack definition ${mdPath} not supported`);
    process.exit(0);
  } else if (md.subcomponentType === 'data') {
    console.log(`Not generating for data sub-component ${mdPath}`);
    process.exit(0);
  }

  // Package output dir is CCA's name
  pkgDir += path.sep + name;
  mkDirParents(pkgDir);

  // Create baseclass.ts content
  let content = [];
  let types = [];
  Object.keys(properties || {}).forEach((propName) => {
    const property = properties[propName];
    const typeDef = getTypeDefinition(propName, property);
    let type = typeDef.type;
    const desc = getHTMLEscapedText(property.description) || '';

    if (type && !isUnsupported(property)) {
      const deprecated = getDeprecation(property);
      // Extended properties for "object" type--only applied if prop is writeback
      // or generating getters for app public props
      if (typeDef.typeDecl.length && (isMutable(property) || withGetters)) {
        types = types.concat(typeDef.typeDecl);
      }
      // Mutable propertyes get "changeNNN" function
      if (isMutable(property)) {
        content = content.concat(indent(getSetterContent(propName, type, desc, deprecated)));
      }
      if (withGetters) {
        content = content.concat(indent(getGetterContent(propName, type, desc, deprecated)));
      }
    }
  });

  if (content.length || hasEvents) {
    const substitutions = {
      '@NAME@': fullName,
      '@CLASSNAME@': className,
      '@SHORTCLASSNAME@': shortClassName,
      '@VERSION@': version,
      '@CONTENT@': content.join('\n'),
      '@TYPES@': types.join('\n'),
      '@CAMELNAME@': camelName,
      '@SHORTCAMELNAME@': shortCamelName
    };
    if (!noSamples) {
      copy('package.json-template', path.join(pkgDir, 'package.json'), substitutions);
      copy('tsconfig.json-template', path.join(pkgDir, 'tsconfig.json'));
      copy('element-test.spec.ts-template', path.join(pkgDir, 'element-test.spec.ts'), substitutions);
    }

    copy('baseclass.ts-template', path.join(pkgDir, `${className}Base.ts`), substitutions);
    copy('class.ts-template', path.join(pkgDir, `${className}.ts`), substitutions);
    copy('index.ts-template', path.join(pkgDir, 'index.ts'), substitutions);

    console.log('Generated WebElement package in ' + pkgDir);
  } else {
    console.log('No accessible properties or events for component. Not generating WebElement.');
  }
})();

/**
 * Get the data type for the given declared type.  This function ensures that
 * the declared type is legal in TypeScript by checking for known types in JET
 * components that should be mapped to others.
 * @param {string} name The property's name
 * @param {object} props The property's object describing itself
 * @return {object} An object describing the data type.  Object keys are "type" "typeDecl"
 * <code>
 *  {
 *    "type": string,
 *    "typeDecl": string[]
 *  }
 * </code>
 */
function getTypeDefinition(name, props) {
  let origType = getSanitizedType(props.type);
  if (!origType && getDeprecation(props)) {
    origType = 'unknown';
  }
  const types = (origType || '').split('|');
  let decls = [];
  // Iterate through all types if multiples exist ("string|number|...")
  types.forEach(function (type, i) {
    if (type.match(/^object$|Array<object>/i)) {
      const decl = getObjectType(name, type, props);
      types[i] = decl.type;
      decls = decls.concat(decl.typeDecl);
    }
  });
  return {
    type: types.join('|'),
    typeDecl: decls
  };
}

/**
 * Get the data type for the given declared type.  This function ensures that
 * the declared type is legal in TypeScript by checking for known types in JET
 * components that should be mapped to others.
 * JET-specific types such as KeySet, DataProvider cannot be converted to TypeScript,
 * and this function will return 'undefined' or anything it doesn't know about.
 * @param {string} origType The original delcared data type
 * @return {string} The data type inferred from the declared type, or undefined
 * if no known good type exists.
 */
function getSanitizedType(origType) {
  if (!origType) {
    return origType;
  }
  // Check for multiple types "string|number|object ..."
  if (origType.indexOf('|') > -1) {
    let parts = [];
    origType.split('|').forEach((type) => {
      type = getSanitizedType(type);
      type && parts.push(type);
    });
    return parts.join('|');
  }
  // Check against KNOWN_TYPES for mapped data type
  let sanitizedType = KNOWN_TYPES[origType.toLowerCase()];
  // Parameterized types
  const typeParams = origType.match(/([a-z\.]+)<(.+?)>/i);
  if (typeParams) {
    const generic = typeParams[1];
    const params = typeParams[2];
    // Paramterized Object not supported
    if (generic.match(/^object/i)) {
      sanitizedType = 'unknown';
    } else {
      // Get sanitized type for each param type
      const paramTypes = [];
      params.split(',').forEach((p) => {
        const sp = getSanitizedType(p);
        sp && paramTypes.push(sp);
      });
      if (paramTypes.length) {
        sanitizedType = `${generic}<${paramTypes.join(',')}>`;
      }
    }
  }
  return sanitizedType;
}

/**
 * Given a property whose type is "object" or "Array<object>", get its Type
 * definition.
 * @param {string} name The property's name
 * @param {string} type The property's type
 * @param {object} props The property descriptor, whose own "properties" object will
 * be converted to a type declaration
 * @return {object} An object containing the Type declaration for the properties, i.e.
 * "type" - a type string
 * "typeDecl" - array of strings containing any type definitions for the generic
 * object types
 */
function getObjectType(name, type, props) {
  let buf = [];
  const typeProps = type.match(/^array</i)
    ? getProperty('extension.vbdt.itemProperties', props)
    : props.properties;

  if (typeProps) {
    const typeInArray = type.match(/^Array/);
    type = titleCase(name);
    buf.push('export interface ' + type + ' {');
    if (typeInArray) {
      type = 'Array<' + type + '>';
    }
    let nestedDecl = [];
    // Iterate through all property types and build their definitions
    Object.keys(typeProps).forEach((propName) => {
      const prop = typeProps[propName];
      const desc = getHTMLEscapedText(typeProps[propName].description) || '';
      let type = getSanitizedType(typeProps[propName].type);
      // Nested object type
      if (type && type.match(/object|Array<object>/i)) {
        const decl = getObjectType(name + titleCase(propName), type, typeProps[propName]);
        type = decl.type;
        nestedDecl = nestedDecl.concat(decl.typeDecl);
      }
      if (type && type !== 'null') {
        const deprecation = getDeprecation(prop);
        buf = buf.concat(indent([
          '/**',
          ` * ${desc}`,
          deprecation && ` * ${deprecation}`,
          ' */'
        ].filter(Boolean)));
        buf = buf.concat(indent([`${propName}: ${type};`]));
      }
    });
    buf.push('}');
    buf = buf.concat(nestedDecl);
  }
  return {
    type: type,
    typeDecl: buf
  };
}

/**
 * Convenience function to retrieve a property within an object using dot-notation.
 * This is espcially useful when a nested property's parents MAY NOT exist, and
 * we don't want to have to test for every parent level to get to the property.
 * @param {string} propName The dot-notated property name
 * @param {object} obj The root object in which to search for the property
 * @return {any} The property value
 */
function getProperty(propName, obj) {
  if (!obj) {
    return obj;
  }
  if (propName in obj) {
    return obj[propName];
  } else if (propName.match(/\./)) {
    const parts = propName.split('.');
    const root = parts.shift();
    return getProperty(parts.join('.'), obj[root]);
  }
}

/**
 * Ensure that the given text is sanitized so that it can be displayed as markup.
 * @param {string} text The text to be sanitized
 * @return {string} The HTML-sanitized text
 */
function getHTMLEscapedText(text) {
  text = (text || '').replace(/</g, '&lt;');
  return text;
}

/**
 * Convenience function to create a nested directory and all of its parents, if
 * necessary. Equivalent to "mkdir -p my/child/dir"
 * @param {string} dirname The path-separated directory name
 */
function mkDirParents(dirname) {
  // Loop thru dirnames to make parent dirs
  const parents = [];
  dirname.split(path.sep).forEach(function (dir) {
    try {
      parents.push(dir);
      fs.mkdirSync(parents.join(path.sep));
    } catch (e) {}
  });
}

/**
 * Get the accessor function name for the given property
 * @param {string} prop The property name
 * @return {string} The property's accessor name
 */
function getGetterName(prop) {
  prop = getAlternativePropName(prop);
  return 'get' + titleCase(prop);
}
/**
 * Get the mutator functio nname for the given property
 * @param {string} prop The property name
 * @return {string} The property's mutator name
 */
function getSetterName(prop) {
  prop = getAlternativePropName(prop);
  return 'change' + titleCase(prop);
}
/**
 * Get an alternate name for the given property name, if one exists. This function
 * checks against reserved property names which shouldn't be overridden. If the
 * given property name is reserved, it will return an alternative name, otherwise,
 * it will return the same (given) name.
 * @param {string} prop The property name
 * @return {string} The alternative property name or the original one, if not
 * reserved.
 */
function getAlternativePropName(prop) {
  return RESERVED_PROPS[prop] || prop;
}

/**
 * Get the contents of the accessor (getter) function for the given property.
 * @param {string} prop The property name to be set
 * @param {string} type The property type
 * @param {string} desc A description of the property
 * @param {string} deprecated A deprecation message for the property
 * @return {string[]} The getter function contents as a string[], each line as an
 * array element
 */
function getGetterContent(prop, type, desc, deprecated) {
  return getTemplate('property-getter.ts-template', {
    '@PROPERTY@': prop,
    '@TYPE@': type,
    '@DESCRIPTION@': desc,
    '@FUNCTION@': getGetterName(prop),
    '@DEPRECATED@': deprecated
  }).split('\n');
}

/**
 * Get the contents of the mutator (setter) function for the given property.
 * @param {string} prop The property name to be set
 * @param {string} type The property type
 * @param {string} desc A description of the property
 * @param {string} deprecated A deprecation message for the property
 * @return {string[]} The setter function contents as a string[], each line as an
 * array element
 */
function getSetterContent(prop, type, desc, deprecated) {
  return getTemplate('property-setter.ts-template', {
    '@PROPERTY@': prop,
    '@TYPE@': type,
    '@DESCRIPTION@': desc,
    '@FUNCTION@': getSetterName(prop),
    '@DEPRECATED@': deprecated
  }).split('\n');
}

/**
 * Convert 'dashed-name' to 'dashedName'
 * @param {string} name
 * @return {string} The camel-cased name
 */
function camelCase(name) {
  return name.replace(/[^a-z0-9](.)/gi, function (v) {
    return v[1].toUpperCase();
  });
}

/**
 * Convert 'dashed-name' to 'DashedName'
 * @param {string} name
 * @return {string} The title-cased name
 */
function titleCase(name) {
  name = camelCase(name);
  return name.charAt(0).toUpperCase() + name.substring(1);
}

/**
 * Indent lines by padding with the given number of spaces. This function modifies
 * the contents of the original array inline.
 * @param {string[]} src The original source array of lines to indent
 * @param {number=} spaces Optional spaces to indent. Defaults to 2
 * @return {Array<string>} The original src string[]
 */
function indent(src, spaces) {
  if (spaces === undefined) {
    spaces = 2;
  }
  for (let i = 0, len = src.length; i < len; i++) {
    const line = src[i];
    if (line) {
      src[i] = new Array(spaces + 1).join(' ') + line;
    }
  }
  return src;
}

/**
 * Get the deprecation information for the given proeprty
 * @param property The property object
 * @returns {string} The deprecation message for the property. Blank if not
 * deprecated.
 */
function getDeprecation(property) {
  const weStatuses = getProperty('extension.webelement.exceptionStatus', property);
  const statuses = weStatuses || property.status;
  const status = statuses && statuses[0];
  // Property getter deprecation can only apply when there's 1 status
  // and no target (applies to entire property)
  if (statuses && statuses.length === 1 && !status.target && status.type === 'deprecated') {
    return `@deprecated Since ${status.since}. ${status.description}`;
  }
  return '';
}

/**
 * Tests whether the property is supported for WebElement use
 * @param property
 */
function isUnsupported(property) {
  const weStatuses = getProperty('extension.webelement.exceptionStatus', property);
  return weStatuses && weStatuses.some((s) => s.type === 'unsupported');
}
/**
 * Tests whether the property should generate both getter and setter accessors
 * @param property
 */
function isMutable(property) {
  const weStatuses = getProperty('extension.webelement.exceptionStatus', property);
  const getterOnly = weStatuses && weStatuses.some((s) => s.type === 'getterOnly');
  return !(getterOnly || property.readOnly) && property.writeback;
}

/**
 * Copy the contents of the source file to the destination, optionally substituting
 * key values.
 * @param {string} templateName The name of the template file to copy. If an override
 * template exists for the given name, it'll be used in place of the default.
 * @param {string} dest The path to the destination file
 * @param {object} filters An object of filters to replace during the copy.  The
 * object keys are the tokens to be replaced with their values.
 */
function copy(templateName, dest, filters) {
  let contents = getTemplate(templateName, filters);
  fs.writeFileSync(dest, contents, { mode: 0o644 });
}

/**
 * Get the contents of the named template, either from the custom or default
 * template dir.
 * @param {string} templateName The name of the template
 * @param {object} filters A map of filter keys-to-values to substitute in the
 * template contents
 * @returns {string} The contents of the template
 */
function getTemplate(templateName, filters) {
  let srcFile = path.join(customTemplates || '--NON-EXISTENT--', templateName);
  if (!fs.existsSync(srcFile)) {
    srcFile = path.join(defaultTemplates, templateName);
  }
  let contents = fs.readFileSync(srcFile, 'utf8');
  Object.keys(filters || {}).forEach(function (key) {
    // Use function to return 'val' to prevent values containing RegExp
    // patterns like "$&" from repeating the key
    function val() {
      return filters[key];
    }
    while (contents.indexOf(key) > -1) {
      contents = contents.replace(key, val);
    }
  });
  return contents;
}

/**
 * Get the metadata given the metadata path.  If the path is "-", read from stdin.
 * @param {string} mdPath The path to the metadata.  Can be a file path or stdin.
 * @return {string} The metadata JSON contents
 */
async function getMetadata(mdPath) {
  let md;
  if (mdPath === '-') {
    md = await readStdin();
  } else {
    md = fs.readFileSync(mdPath, 'utf8');
  }
  return md;
}

/**
 * Fetch the JET metadata object for the given element, whose name is embedded
 * as the "&element=" parameter in the URL.
 *
 * @return Promise<string> A Promise which resolves to the metadata contents string
 */
function readStdin() {
  process.stdin.resume();
  process.stdin.setEncoding('utf8');

  const md = [];
  return new Promise(function (resolve, reject) {
    process.stdin.on('data', (chunk) => {
      md.push(chunk);
    });
    process.stdin.on('end', () => resolve(md.join('\n')));
  });
}
