{"version":3,"file":"PRIVATE_useVizSelection.js","sources":["../../../src/hooks/PRIVATE_useVizSelection/useSelection.ts"],"sourcesContent":["/**\n * @license\n * Copyright (c) %FIRST_YEAR% %CURRENT_YEAR%, Oracle and/or its affiliates.\n * The Universal Permissive License (UPL), Version 1.0\n * as shown at https://oss.oracle.com/licenses/upl/\n * @ignore\n */\n\nimport { useCallback } from 'preact/hooks';\n\ntype SelectionMode = 'none' | 'single' | 'multiple';\ntype SelectionDetail<K> = {\n  ids: K[];\n};\ntype SelectionBehavior = 'toggle' | 'replace';\n\nconst NAVKEYS = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];\n\n/**\n * Compares if two sets are equal.\n */\nconst isEqual = <T>(setA: Set<T>, setB: Set<T>) => {\n  return setA.size === setB.size && [...setA].every((value) => setB.has(value));\n};\n\n/**\n * Handles the selection.\n * @param itemId The id of the item.\n * @param selectedIds The set of selected item ids.\n * @param selectionMode The selection mode.\n * @param selectionBehavior The selection behavior. If 'toggle', unselected item will be selected and\n * vice versa. If 'replace', the item will replace the previous selection.\n * @param onChange The callback to trigger when selection changes.\n */\nconst handleSelect = <K>(\n  itemId: K | undefined,\n  selectedIds: Set<K>,\n  selectionMode: SelectionMode,\n  selectionBehavior: SelectionBehavior,\n  onChange?: (detail: SelectionDetail<K>) => void\n) => {\n  let ids = new Set<K>([]);\n  if (itemId != null) {\n    ids = new Set(selectedIds);\n    const isSelected = selectedIds.has(itemId);\n\n    if (selectionBehavior === 'toggle') {\n      if (isSelected) {\n        ids.delete(itemId);\n      } else if (selectionMode === 'single') {\n        ids = new Set([itemId]); // only selection\n      } else {\n        ids.add(itemId); // add to selection in \"multiple\" selectionMode\n      }\n    } else if (!isSelected) {\n      // In \"multiple\" selection mode, only replace selection if unselected item is selected.\n      // In \"single\" selection mode, only need to replace if unselected item is selected.\n      ids = new Set([itemId]);\n    }\n  }\n\n  if (!isEqual(ids, selectedIds)) {\n    onChange?.({ ids: [...ids] });\n  }\n};\n\ntype Props<K> = {\n  selection?: K[];\n  selectionMode?: SelectionMode;\n  idExtracter: (event: Event) => K | undefined;\n  onChange?: (detail: SelectionDetail<K>) => void;\n};\n\n/**\n * The hook to handle the selection behavior in vizualization components.\n */\nexport function useSelection<K>({\n  selection = [],\n  selectionMode = 'none',\n  idExtracter,\n  onChange\n}: Props<K>) {\n  const onPointerUp = useCallback(\n    (event: PointerEvent) => {\n      const key = idExtracter(event);\n      const isMeta = event.metaKey;\n      const isCtrl = event.ctrlKey;\n      if (key == null && (isMeta || isCtrl)) {\n        return;\n      }\n      handleSelect(\n        key,\n        new Set(selection),\n        selectionMode,\n        isMeta || isCtrl || event.pointerType === 'touch' ? 'toggle' : 'replace',\n        onChange\n      );\n    },\n    [selection, selectionMode, onChange]\n  );\n\n  const onContextMenu = useCallback(\n    (event: MouseEvent) => {\n      const key = idExtracter(event);\n      const isCtrl = event.ctrlKey;\n      handleSelect(key, new Set(selection), selectionMode, isCtrl ? 'toggle' : 'replace', onChange);\n    },\n    [selection, selectionMode, onChange]\n  );\n\n  const onKeyUp = useCallback(\n    (event: KeyboardEvent) => {\n      const isShift = event.shiftKey;\n      const isSpaceCtrl = event.ctrlKey && event.key === ' ';\n      const isArrowKey = NAVKEYS.indexOf(event.key) !== -1;\n      const itemKey = idExtracter(event);\n\n      if (isArrowKey || isSpaceCtrl) {\n        const behavior = isShift || isSpaceCtrl ? 'toggle' : 'replace';\n        handleSelect(itemKey, new Set(selection), selectionMode, behavior, onChange);\n      }\n    },\n    [selection, selectionMode, onChange]\n  );\n\n  return selectionMode === 'none' || onChange == null\n    ? {}\n    : { onKeyUp, onContextMenu, onPointerUp };\n}\n"],"names":["NAVKEYS","handleSelect","itemId","selectedIds","selectionMode","selectionBehavior","onChange","ids","Set","isSelected","has","delete","add","setA","setB","size","every","value","selection","idExtracter","onPointerUp","useCallback","event","key","isMeta","metaKey","isCtrl","ctrlKey","pointerType","onContextMenu","onKeyUp","isShift","shiftKey","isSpaceCtrl","isArrowKey","indexOf","itemKey","behavior"],"mappings":"8DAgBA,MAAMA,EAAU,CAAC,UAAW,YAAa,YAAa,cAkBhDC,EAAe,CACnBC,EACAC,EACAC,EACAC,EACAC,KAEA,IAAIC,EAAM,IAAIC,IAAO,IACrB,GAAc,MAAVN,EAAgB,CAClBK,EAAM,IAAIC,IAAIL,GACd,MAAMM,EAAaN,EAAYO,IAAIR,GAET,WAAtBG,EACEI,EACFF,EAAII,OAAOT,GACgB,WAAlBE,EACTG,EAAM,IAAIC,IAAI,CAACN,IAEfK,EAAIK,IAAIV,GAEAO,IAGVF,EAAM,IAAIC,IAAI,CAACN,IAElB,CAtCa,IAAIW,EAAcC,IAwCdX,GAxCAU,EAwCLN,GAvCDQ,OAASD,EAAKC,MAAQ,IAAIF,GAAMG,OAAOC,GAAUH,EAAKJ,IAAIO,MAwCpEX,IAAW,CAAEC,IAAK,IAAIA,IACvB,iBAaa,UAAgBW,UAC9BA,EAAY,GAAEd,cACdA,EAAgB,OAAMe,YACtBA,EAAWb,SACXA,IAEA,MAAMc,EAAcC,eACjBC,IACC,MAAMC,EAAMJ,EAAYG,GAClBE,EAASF,EAAMG,QACfC,EAASJ,EAAMK,QACV,MAAPJ,IAAgBC,GAAUE,IAG9BzB,EACEsB,EACA,IAAIf,IAAIU,GACRd,EACAoB,GAAUE,GAAgC,UAAtBJ,EAAMM,YAA0B,SAAW,UAC/DtB,EACD,GAEH,CAACY,EAAWd,EAAeE,IAGvBuB,EAAgBR,eACnBC,IACC,MAAMC,EAAMJ,EAAYG,GAClBI,EAASJ,EAAMK,QACrB1B,EAAasB,EAAK,IAAIf,IAAIU,GAAYd,EAAesB,EAAS,SAAW,UAAWpB,EAAS,GAE/F,CAACY,EAAWd,EAAeE,IAGvBwB,EAAUT,eACbC,IACC,MAAMS,EAAUT,EAAMU,SAChBC,EAAcX,EAAMK,SAAyB,MAAdL,EAAMC,IACrCW,GAA6C,IAAhClC,EAAQmC,QAAQb,EAAMC,KACnCa,EAAUjB,EAAYG,GAE5B,GAAIY,GAAcD,EAAa,CAC7B,MAAMI,EAAWN,GAAWE,EAAc,SAAW,UACrDhC,EAAamC,EAAS,IAAI5B,IAAIU,GAAYd,EAAeiC,EAAU/B,EACpE,IAEH,CAACY,EAAWd,EAAeE,IAG7B,MAAyB,SAAlBF,GAAwC,MAAZE,EAC/B,CAAE,EACF,CAAEwB,UAASD,gBAAeT,cAChC"}