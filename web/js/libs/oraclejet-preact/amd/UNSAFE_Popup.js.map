{"version":3,"file":"UNSAFE_Popup.js","sources":["../../src/UNSAFE_Popup/usePopupAnimation.ts","../../src/UNSAFE_Popup/Popup.tsx"],"sourcesContent":["import { Placement, RtlSide } from '../UNSAFE_Floating';\nimport {\n  useAnimationStatus,\n  AnimationStatus,\n  AnimationStatusProps\n} from '../hooks/PRIVATE_useAnimationStatus';\nimport { normalizePosition } from '../utils/PRIVATE_floatingUtils';\nimport { useUser } from '../hooks/UNSAFE_useUser';\nimport { useEffect } from 'preact/hooks';\n\n/**\n * The placement and direction aware HTML element\n * The useAnimation hook do not allow to change dynamically the animation states,\n * but allows a function that returns animation states config. The function takes\n * the animated node of type <E extends HTMLElement> as an argument. This could be used\n * to extend HTMLElement with placement and direction.\n */\ntype AnimationPopupElement = HTMLElement & {\n  placement?: Placement;\n  direction?: 'ltr' | 'rtl';\n};\n\ntype PopupAnimationProps = Omit<AnimationStatusProps, 'animationStates'> & {\n  placement: Placement;\n};\n\nconst animationStates = {\n  opening: (node: AnimationPopupElement) => {\n    const realPlacement = logicalSide(node.placement, node.direction);\n    return {\n      //zoomIn\n      from: {\n        scaleX: 0,\n        scaleY: 0,\n        opacity: 0,\n        transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]\n      },\n      to: {\n        scaleX: 1,\n        scaleY: 1,\n        opacity: 1,\n        transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]\n      },\n      options: {\n        duration: 200\n      }\n    };\n  },\n  closing: (node: AnimationPopupElement) => {\n    const realPlacement = logicalSide(node.placement, node.direction);\n    return {\n      //zoomOut\n      from: {\n        scaleX: 1,\n        scaleY: 1,\n        opacity: 1,\n        transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]\n      },\n      to: {\n        scaleX: 0,\n        scaleY: 0,\n        opacity: 0,\n        transformOrigin: _ANIMATION_TRANSFORM_ORIGIN_RULES[realPlacement]\n      },\n      options: {\n        duration: 200\n      }\n    };\n  }\n};\n\nconst _ANIMATION_TRANSFORM_ORIGIN_RULES = {\n  top: 'center bottom',\n  'top-right': 'right bottom',\n  'top-left': 'left bottom',\n  'top-right-corner': 'left bottom',\n  'top-left-corner': 'right bottom',\n  right: 'left center',\n  'right-top': 'left top',\n  'right-bottom': 'left bottom',\n  'right-top-corner': 'left bottom',\n  'right-bottom-corner': 'left top',\n  bottom: 'center top',\n  'bottom-right': 'right top',\n  'bottom-left': 'left top',\n  'bottom-right-corner': 'left top',\n  'bottom-left-corner': 'right top',\n  left: 'right center',\n  'left-top': 'right top',\n  'left-bottom': 'right bottom',\n  'left-top-corner': 'right bottom',\n  'left-bottom-corner': 'right top'\n};\n\ntype RealPlacement =\n  | 'top'\n  | 'top-right'\n  | 'top-left'\n  | 'top-right-corner'\n  | 'top-left-corner'\n  | 'right'\n  | 'right-top'\n  | 'right-bottom'\n  | 'right-top-corner'\n  | 'right-bottom-corner'\n  | 'bottom'\n  | 'bottom-right'\n  | 'bottom-left'\n  | 'bottom-right-corner'\n  | 'bottom-left-corner'\n  | 'left'\n  | 'left-top'\n  | 'left-bottom'\n  | 'left-top-corner'\n  | 'left-bottom-corner';\n\nconst logicalSide = (\n  placement: Placement | undefined,\n  direction: 'rtl' | 'ltr' | undefined\n): RealPlacement => {\n  if (placement == null || direction == null) return 'bottom';\n  const side = placement.split('-')[0] as RtlSide;\n  const alignment = placement.split('-')[1] as RtlSide;\n  const corner = placement.split('-')[2];\n  const physicalSide = normalizePosition(side, direction);\n  const placements: Array<RealPlacement> = [\n    'top',\n    'top-right',\n    'top-left',\n    'top-right-corner',\n    'top-left-corner',\n    'right',\n    'right-top',\n    'right-bottom',\n    'right-top-corner',\n    'right-bottom-corner',\n    'bottom',\n    'bottom-right',\n    'bottom-left',\n    'bottom-right-corner',\n    'bottom-left-corner',\n    'left',\n    'left-top',\n    'left-bottom',\n    'left-top-corner',\n    'left-bottom-corner'\n  ];\n  const newPlacement: RealPlacement = placements.filter(\n    (placement) =>\n      (alignment &&\n        corner &&\n        placement === `${physicalSide}-${normalizePosition(alignment, direction)}-${corner}`) ||\n      (alignment &&\n        !corner &&\n        placement === `${physicalSide}-${normalizePosition(alignment, direction)}`) ||\n      (!alignment && placement === `${physicalSide}`)\n  )[0];\n  if (!newPlacement) {\n    return 'bottom';\n  }\n\n  return newPlacement;\n};\n\nexport function usePopupAnimation(props: PopupAnimationProps): {\n  status: AnimationStatus;\n  setAnimationElementRef: (node: HTMLElement | null) => void;\n} {\n  const { isOpen, isAnimatedOnMount, onTransitionEnd, placement } = props;\n  const { direction } = useUser();\n  const { setAnimationElementRef, animationElementRef, status } =\n    useAnimationStatus<AnimationPopupElement>({\n      isOpen: isOpen,\n      isAnimatedOnMount: isAnimatedOnMount,\n      animationStates,\n      onTransitionEnd\n    });\n  const popupElementRef = animationElementRef;\n\n  //This is needed for the case if popup flips and changes the placement.\n  useEffect(() => {\n    if (popupElementRef != null && popupElementRef.current != null && status != 'unmounted') {\n      popupElementRef.current.placement = placement;\n      popupElementRef.current.direction = direction;\n    }\n  }, [popupElementRef, placement, direction, status]);\n  return { setAnimationElementRef, status };\n}\n","import { JSX, RefObject } from 'preact';\nimport { useState, useEffect, useLayoutEffect, useMemo, useRef, useCallback } from 'preact/hooks';\nimport {\n  Floating,\n  Offset,\n  Placement,\n  Coords,\n  FlipOptions,\n  ShiftOptions,\n  PositionData\n} from '../UNSAFE_Floating';\nimport { focusOn, focusWithin, getActiveElement } from '../utils/PRIVATE_tabbableUtils';\nimport { mergeRefs } from '../utils/PRIVATE_refUtils';\nimport { FocusTrap } from '../UNSAFE_FocusTrap';\nimport { Layer } from '../UNSAFE_Layer';\nimport { forwardRef, ForwardedRef } from 'preact/compat';\nimport { HTMLAttributesSignalExcluded } from '../utils/UNSAFE_attributeUtils';\nimport { usePopupAnimation } from './usePopupAnimation';\n\n// Style imports\nimport { useComponentTheme } from '../hooks/UNSAFE_useComponentTheme';\nimport { popupVars } from './themes/PopupContract.css';\nimport { getVarName } from '../utils/UNSAFE_stringUtils';\nimport { Property } from 'csstype';\nimport { classNames } from '../utils/UNSAFE_classNames';\nimport { PopupRedwoodTheme } from './themes/redwood/PopupTheme';\n\ntype IntrinsicProps = Pick<JSX.HTMLAttributes<HTMLDivElement>, 'children'>;\n\ntype Props = IntrinsicProps & {\n  /**\n   * Specifies whether the Popup is open.\n   */\n  isOpen: boolean;\n  /**\n   * Specifies Popup's anchor. Popup is placed relatively to its anchor.\n   */\n  anchorRef: RefObject<HTMLElement | Coords>;\n  /**\n   * Specifies placement of the Popup relative to the anchor.\n   */\n  placement?: Placement;\n  /**\n   * Specifies displacement of the Popup from the anchor element placement along the specified axes.\n   * The offset object consists of mainAxis and crossAxis properties. The direction in which these properties\n   * are applied depends on the current value of the position property.\n   *\n   * The <code>mainAxis</code> property represents the distance between the Popup and the anchor.\n   * The <code>crossAxis</code> property represents the deviation in the opposite axis to the main axis - the skidding between the Popup and the anchor.\n   */\n  offset?: Offset;\n  /**\n   * Specifies whether a floating Popup changes placement to the opposite side to be kept in view when a collision is detected.\n   *\n   * The flipOptions object consists of mainAxis and crossAxis properties.\n   * The <code>mainAxis</code> runs along the side of the Popup element.\n   * The <code>crossAxis</code> runs along the alignment of the Popup element.\n   */\n  flipOptions?: FlipOptions;\n  /**\n   * Specifies whether a floating Popup shifts along axis to be kept in view when a collision is detected.\n   * Note that if both 'flip' and 'shift' are enabled on respective axis, the flip will take precedence.\n   *\n   * The shiftOptions object consists of mainAxis and crossAxis properties.\n   * The <code>mainAxis</code> runs along the side of the Popup element.\n   * The <code>crossAxis</code> runs along the alignment of the Popup element.\n   */\n  shiftOptions?: ShiftOptions;\n  /**\n   * Specifies if the Popup sets focus to its content when initially open.\n   * A value of none prevents the popup from setting focus when open.\n   *\n   * <code>auto</code> in modeless mode resolves to none.\n   * <code>none</code> prevents the popup from setting focus when open.\n   * <code>popup</code> sets focus to the root popup container (good choice for touch platforms).\n   * <code>firstFocusable</code> defines that a popup should set focus to the first focusable element within the popup's content.\n   */\n  initialFocus?: 'auto' | 'none' | 'popup' | 'firstFocusable';\n  /**\n   * Specifies callback triggered when a user clicks outside Popup.\n   */\n  onClickOutside?: (event: MouseEvent) => void;\n  /**\n   * Specifies callback triggered when a user tries to close a Popup through UI interaction.\n   * The parent should listen to this event and close the Popup. If the parent fails to remove\n   * the Popup, then no change will be done in the UI by the component.\n   */\n  onClose?: (event: KeyboardEvent) => void;\n  /**\n   * Specifies Popup's tail. Simple tail is an arrow pointing to Popup's anchor.\n   */\n  tail?: 'none' | 'simple';\n  /**\n   * Specifies callback triggered after the animation ends.\n   */\n  onTransitionEnd?: (value: boolean) => void;\n  /**\n   * Specifies the ARIA role type. Depending on how the popup is used in the page, the page developer should choose from the following:\n   * <code>tooltip</code> defines contextual popup that displays a description for an element. This is added automatically if not already specified.\n   * <code>dialog</code> defines an application window that is designed to interrupt the current processing of an application in order to prompt the user to enter information or require a response.\n   * <code>alertdialog</code> defines type of dialog that contains an alert message, where initial focus goes to an element within the dialog.\n   */\n  role?: HTMLAttributesSignalExcluded['role'];\n};\n\n/**\n * A popup temporarily 'pops up' content in the foreground.\n */\nexport const Popup = forwardRef(\n  (\n    {\n      anchorRef,\n      children,\n      isOpen = false,\n      offset = { mainAxis: 0, crossAxis: 0 },\n      flipOptions = { mainAxis: true, crossAxis: true },\n      shiftOptions = { mainAxis: false, crossAxis: false },\n      onClose,\n      initialFocus = 'auto',\n      onClickOutside,\n      placement = 'top',\n      tail = 'none',\n      onTransitionEnd,\n      role = 'tooltip'\n    }: Props,\n    ref: ForwardedRef<HTMLElement | null>\n  ) => {\n    const [trapDisabled, setTrapDisabled] = useState<boolean>(true);\n    const launcherRef = useRef<HTMLElement | null>(null);\n    const [popupBgColor, setPopupBgColor] = useState<Property.BackgroundColor>();\n\n    const contentWrapperRef = useRef<HTMLDivElement | null>(null);\n\n    //The animationPlacement is used for the case of flip.\n    const [animationPlacement, setAnimationPlacement] = useState<Placement>(placement);\n\n    function launcherKeyDownCallback(event: KeyboardEvent): void {\n      if (launcherRef.current === getActiveElement() && event.code === 'F6') {\n        // Prevent default F6 handlers.\n        // F6 is a standard Chrome address bar shortcut on Windows.\n        event.preventDefault();\n        event.stopPropagation();\n\n        focusWithin(contentWrapperRef.current as HTMLElement);\n      }\n    }\n\n    const _onTransitionEnd = (isOpen: boolean) => {\n      if (isOpen) {\n        setInitialFocus();\n        onTransitionEnd?.(true);\n      } else {\n        onTransitionEnd?.(false);\n      }\n    };\n\n    // Animation\n    const { setAnimationElementRef, status } = usePopupAnimation({\n      isOpen,\n      isAnimatedOnMount: true,\n      onTransitionEnd: _onTransitionEnd,\n      placement: animationPlacement\n    });\n    const stableRef = useMemo(\n      () => mergeRefs(setAnimationElementRef, ref),\n      [setAnimationElementRef, ref]\n    );\n\n    const returnFocus = () => {\n      // Try to return focus to 1.launcher or 2.anchor\n      const launcherEl = launcherRef.current;\n      const anchorEl = anchorRef.current;\n\n      if (launcherEl) {\n        focusOn(launcherEl);\n        // Checking instanceof to avoid Coords type that can not be focused\n      } else if (anchorEl && anchorEl instanceof Element) {\n        focusOn(anchorEl);\n      }\n    };\n    useEffect(() => {\n      // Init closing\n      if (!isOpen && status === 'opening') {\n        // Only actively return focus to the launcher or anchor if the popup contained focus.\n        // Otherwise, focus is already elsewhere on the page and should not be forced back\n        // because that could reopen the popup again, which essentially prevents the user from\n        // moving focus out of the launcher.\n        if (contentWrapperRef.current?.contains(getActiveElement())) {\n          returnFocus();\n        }\n      }\n    }, [isOpen, status]);\n\n    // Launcher handler\n    useEffect(() => {\n      if (isOpen && anchorRef.current instanceof Element) {\n        // Remember launcher\n        if (getActiveElement() === document.body) {\n          launcherRef.current = anchorRef.current as HTMLElement;\n        } else {\n          launcherRef.current = getActiveElement();\n        }\n\n        // Register F6 key handler to enter the Popup\n        launcherRef.current?.addEventListener('keydown', launcherKeyDownCallback);\n      }\n      return () => {\n        // Deregister F6 key handler\n        launcherRef.current?.removeEventListener('keydown', launcherKeyDownCallback);\n      };\n    }, [isOpen]);\n\n    const setInitialFocus = () => {\n      let derivedInitialFocus = initialFocus;\n      if (initialFocus === 'auto') {\n        // Modeless mode - do not steal focus by default\n        derivedInitialFocus = 'none';\n      }\n\n      // Case: 'popup'\n      // Focus on Popup container\n      if (derivedInitialFocus === 'popup') {\n        focusOn(contentWrapperRef.current as HTMLElement);\n      }\n\n      // Case: 'firstFocusable'\n      // Focus on first tabbable in the Popup container or container itself if there is none\n      if (derivedInitialFocus === 'firstFocusable') {\n        focusWithin(contentWrapperRef.current as HTMLElement);\n      }\n    };\n\n    const getMainAxisOffset = (offset?: Offset) => {\n      let calcOffset = 0;\n      if (offset) {\n        // @ts-ignore as OffsetFunction is going to be removed\n        // Property 'mainAxis' does not exist on type 'OffsetFunction'.\n        calcOffset = typeof offset === 'number' ? offset : offset.mainAxis || 0;\n        if (tail === 'simple') {\n          calcOffset += 5;\n        }\n      }\n      return calcOffset;\n    };\n\n    const getCrossAxisOffset = (offset?: Offset) => {\n      if (!offset) {\n        return 0;\n      } else {\n        // @ts-ignore as OffsetFunction is going to be removed\n        // Property 'crossAxis' does not exist on type 'OffsetFunction'.\n        return typeof offset === 'number' ? 0 : offset.crossAxis || 0;\n      }\n    };\n\n    const finalOffset = {\n      mainAxis: getMainAxisOffset(offset),\n      crossAxis: getCrossAxisOffset(offset)\n    };\n\n    // Preact FocusEvent mapping\n    // onFocus - focusin\n    // onBlur - focusout\n    //\n    // https://developer.mozilla.org/en-US/docs/Web/API/FocusEvent/relatedTarget\n    // Event name   target                           relatedTarget\n    // blur         The EventTarget losing focus     The EventTarget receiving focus (if any).\n    // focus        The EventTarget receiving focus  The EventTarget losing focus (if any)\n    // focusin      The EventTarget receiving focus  The EventTarget losing focus (if any)\n    // focusout     The EventTarget losing focus     The EventTarget receiving focus (if any)\n    const handleOnFocus = (event: FocusEvent) => {\n      // Executing this listener means that element receiving focus lives within Popup.\n      // We are checking which element is loosing focus to avoid activating FocusTrap when focus\n      // travels among elements within FocusTrap.\n      // To enable FocusTrap the element that looses focus must live out of the Popup or is Popup's container.\n      if (\n        !contentWrapperRef.current?.contains(event.relatedTarget as Element) ||\n        event.relatedTarget === contentWrapperRef.current\n      ) {\n        // Do not activate focusTrap if the event.target is Popup itself - if we clicked on Popup's container\n        // We should be able to focus Popup container without activating FocusTrap\n        if (event.target != contentWrapperRef.current) {\n          // Enable FocusTrap.\n          setTrapDisabled(false);\n        }\n      }\n    };\n    const handleOnBlur = (event: FocusEvent) => {\n      // Executing this listener means that an element living within Popup is loosing focus.\n      // We are checking which element is receiving focus to avoid disabling FocusTrap when focs\n      // travels among elements within FocusTrap.\n      // To disable FocusTrap element the element that receives focus must live out of the Popup or is Popup's container.\n      if (\n        !contentWrapperRef.current?.contains(event.relatedTarget as Element) ||\n        event.relatedTarget === contentWrapperRef.current\n      ) {\n        // Disable FocusTrap.\n        setTrapDisabled(true);\n      }\n    };\n\n    const handlePopupKeyDown = (event: KeyboardEvent) => {\n      const currentlyFocusedEl = getActiveElement();\n      const wrapperEl = contentWrapperRef.current;\n      const launcherEl = launcherRef.current;\n      if (wrapperEl === currentlyFocusedEl || wrapperEl?.contains(currentlyFocusedEl)) {\n        switch (event.code) {\n          case 'Escape': {\n            onClose?.(event);\n            break;\n          }\n          case 'F6':\n            // Prevent default F6 handlers.\n            // F6 is a standard Chrome address bar shortcut on Windows.\n            event.preventDefault();\n            event.stopPropagation();\n\n            // Focus launcher\n            if (launcherEl) {\n              focusOn(launcherEl);\n            }\n            // Disable FocusTrap\n            setTrapDisabled(true);\n            break;\n          case 'Tab':\n            // If tabbing out of the popup when the popup itself has focus and the focus trap is\n            // disabled, transfer focus back to the launcher.  Don't let the browser then\n            // transfer focus itself from there like it normally would.\n            if (event.target === contentWrapperRef.current && trapDisabled) {\n              // Focus launcher\n              if (launcherEl) {\n                focusOn(launcherEl);\n\n                // Prevent the browser from transferring focus itself.\n                event.preventDefault();\n              }\n            }\n            break;\n        }\n      }\n    };\n\n    const onPosition = useCallback(\n      (data: PositionData) => {\n        if (placement !== data.placement) {\n          //if flips happens we need to change the placement in the animations.\n          setAnimationPlacement(data.placement);\n        }\n      },\n      [setAnimationPlacement, placement]\n    );\n\n    useLayoutEffect(() => {\n      if (\n        status === 'unmounted' ||\n        contentWrapperRef.current == null ||\n        popupBgColor != null ||\n        tail === 'none'\n      )\n        return;\n\n      const backgroundColorVar = getVarName(popupVars.backgroundColor);\n      const computedStyle = getComputedStyle(contentWrapperRef.current!);\n      setPopupBgColor(computedStyle.getPropertyValue(backgroundColorVar));\n    }, [status, contentWrapperRef, popupBgColor, tail]);\n\n    // Styles\n    const { baseTheme, classes } = useComponentTheme(PopupRedwoodTheme);\n    const isMounted = status !== 'unmounted';\n    return (\n      isMounted && (\n        <Layer>\n          <Floating\n            ref={stableRef}\n            backgroundColor={popupBgColor}\n            anchorRef={anchorRef}\n            placement={placement}\n            offsetValue={finalOffset}\n            flipOptions={flipOptions}\n            shiftOptions={shiftOptions}\n            onClickOutside={onClickOutside}\n            tail={tail}\n            onPosition={onPosition}>\n            <div\n              ref={contentWrapperRef}\n              tabIndex={-1}\n              role={role}\n              className={classNames([baseTheme, classes])}\n              onFocus={handleOnFocus}\n              onBlur={handleOnBlur}\n              onKeyDown={handlePopupKeyDown}>\n              {/*Setting restoreFocusRef to false because otherwise FocusTrap is stealing the focus back when :*/}\n              {/*we click outside of modeless Popup (that keeps being open).*/}\n              <FocusTrap isDisabled={trapDisabled} restoreFocusRef={false}>\n                {children}\n              </FocusTrap>\n            </div>\n          </Floating>\n        </Layer>\n      )\n    );\n  }\n);\n"],"names":["animationStates","opening","node","realPlacement","logicalSide","placement","direction","from","scaleX","scaleY","opacity","transformOrigin","_ANIMATION_TRANSFORM_ORIGIN_RULES","to","options","duration","closing","top","right","bottom","left","side","split","alignment","corner","physicalSide","normalizePosition","newPlacement","filter","Popup","forwardRef","anchorRef","children","isOpen","offset","mainAxis","crossAxis","flipOptions","shiftOptions","onClose","initialFocus","onClickOutside","tail","onTransitionEnd","role","ref","trapDisabled","setTrapDisabled","useState","launcherRef","useRef","popupBgColor","setPopupBgColor","contentWrapperRef","animationPlacement","setAnimationPlacement","launcherKeyDownCallback","event","current","getActiveElement","code","preventDefault","stopPropagation","focusWithin","setAnimationElementRef","status","props","isAnimatedOnMount","useUser","animationElementRef","useAnimationStatus","popupElementRef","useEffect","usePopupAnimation","setInitialFocus","stableRef","useMemo","mergeRefs","contains","launcherEl","anchorEl","focusOn","Element","returnFocus","document","body","addEventListener","removeEventListener","derivedInitialFocus","finalOffset","calcOffset","getMainAxisOffset","getCrossAxisOffset","onPosition","useCallback","data","useLayoutEffect","backgroundColorVar","getVarName","popupVars","backgroundColor","computedStyle","getComputedStyle","getPropertyValue","baseTheme","classes","useComponentTheme","PopupRedwoodTheme","_jsx","Layer","jsx","Floating","offsetValue","tabIndex","className","classNames","onFocus","relatedTarget","target","onBlur","onKeyDown","currentlyFocusedEl","wrapperEl","FocusTrap","isDisabled","restoreFocusRef"],"mappings":"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"}